<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" type="image/x-icon" href="/favicon.ico">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
	<link rel="manifest" href="/manifest.json">
    <title>Creature Builder AI</title>
	<style>
		:root {
			--primary: #2a2d3e;
			--secondary: #1a1c2a;
			--accent: #6c5ce7;
			--text: #e2e2e2;
			--border: #3f4255;
			--hover: #8075e5;
		}

		/* Base Reset - Keep Existing */
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		/* Body Styles - Keep Existing */
		body {
			font-family: 'Segoe UI', system-ui, sans-serif;
			background-color: var(--secondary);
			color: var(--text);
			min-height: 100vh;
			margin: 0;
			padding: 0;
		}

		/* Main Wrapper - Keep Existing */
		.main-wrapper {
			display: flex;
			justify-content: center;
			align-items: center;
			height: calc(100vh - 72px);
			padding: 10px;
		}

		/* Container - Updated */
		.container {
			width: 85vw;  
			height: 85vh;
			background: var(--primary);
			border-radius: 15px;
			display: grid;
			grid-template-columns: 1.2fr 0.8fr;
			gap: 15px;
			position: relative;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			padding: 15px;
			overflow: hidden;
		}

		/* Gradient Borders - Keep Existing */
		.container::before,
		.container::after {
			content: '';
			position: absolute;
			width: 4px;
			height: 100%;
			background: linear-gradient(to bottom, var(--accent), transparent);
		}

		.container::before { left: 0; border-radius: 15px 0 0 15px; }
		.container::after { right: 0; border-radius: 0 15px 15px 0; }

		/* History Strip - Updated */
		#history-strip {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 110px;
			background: var(--primary);
			display: flex;
			flex-direction: column;
			gap: 8px;
			padding: 8px;
			overflow-y: auto;
			overflow-x: hidden;
			border-radius: 15px 0 0 15px;
			border-right: 2px solid var(--border);
			scrollbar-width: thin;
			scrollbar-color: var(--accent) var(--secondary);
		}

		#history-strip::-webkit-scrollbar {
			width: 6px;
		}

		#history-strip::-webkit-scrollbar-track {
			background: var(--secondary);
		}

		#history-strip::-webkit-scrollbar-thumb {
			background: var(--accent);
			border-radius: 3px;
		}

		/* History Item - Updated */
		.history-item {
			width: 95px;
			height: 95px;
			min-height: 95px;
			border: 2px solid var(--border);
			border-radius: 6px;
			overflow: hidden;
			cursor: pointer;
			transition: all 0.2s;
			position: relative;
		}

		.history-item:hover {
			border-color: var(--accent);
			transform: translateY(-2px);
		}

		.history-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			padding: 0;
			margin: 0;
		}

		/* Removing settings overlay display */
		.history-item .settings {
			display: none;
		}

		/* Left Panel - Updated */
		#left-panel {
			position: relative;
			display: flex;
			flex-direction: column;
			gap: 10px;
			height: 100%;
			overflow: hidden;
			padding-left: 120px;
			padding-right: 10px;
		}

		/* Title - Keep Existing */
		h1 {
			font-size: 24px;
			background: linear-gradient(45deg, var(--accent), #a29bfe);
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
			text-align: center;
			margin: 0;
			padding: 0;
		}

		/* Creature Display - Updated */
		#creature-display {
			flex: 1;
			background: var(--secondary);
			border-radius: 10px;
			display: flex;
			align-items: center;
			justify-content: center;
			border: 2px solid var(--border);
			overflow: hidden;
			margin: 0;
		}

		#creature-display img {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
			display: block;
		}

		#right-panel {
			display: flex;
			flex-direction: column;
			gap: 15px;
			height: 100%;
			overflow: hidden;
		}

		.options {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			gap: 8px;
			padding-right: 5px;
		}

		/* Option cells */
		.option {
			background: var(--secondary);
			padding: 4px;
			border-radius: 8px;
			border: 1px solid var(--border);
			height: auto;
			display: flex;
			flex-direction: column;
			gap: 2px;
		}

		/* Label styling */
		.option h3 {
			margin: 0;
			font-size: 12px;  /* Smaller than option text */
			color: var(--accent);
			line-height: 1;
			text-align: left;
			padding-left: 2px;
		}

		/* Controls row */
		.controls {
			display: grid;
			grid-template-columns: auto 1fr auto;
			gap: 4px;
			align-items: center;
			height: 28px;
		}

		/* Buttons */
		.controls button {
			width: 28px;
			height: 28px;
			padding: 0;
			border: none;
			background: var(--accent);
			color: white;
			border-radius: 6px;
			cursor: pointer;
			font-size: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		/* Center option text */
		.choice {
			text-align: center;
			padding: 4px;
			background: var(--primary);
			border-radius: 6px;
			border: 1px solid var(--border);
			font-size: 14px;  /* Slightly larger than label */
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.controls button:hover {
			background: var(--hover);
		}

		#chat-section {
			position: relative;
			display: flex;
			flex-direction: column;
			gap: 8px;
			height: 450px;  /* Fixed height that won't expand */
			padding: 0 2px;
		}

		#chat-output {
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
			background: var(--secondary);
			border-radius: 8px;
			padding: 10px;
			border: 1px solid var(--border);
			white-space: pre-line;  /* Changed from normal to pre-line to preserve line breaks */
			font-size: 14px;
			line-height: 1.4;
			word-wrap: break-word;
			margin-bottom: 8px;
		}		
		
		#chat-output p {
			margin-bottom: 10px;
		}

		#chat-input {
			width: calc(100% - 8px);
			margin: 0 4px;  /* Fixed margin syntax: 0 vertical, 4px horizontal */
			padding: 8px;
			background: var(--secondary);
			border: 1px solid var(--border);
			border-radius: 8px;
			color: var(--text);
			font-size: 14px;
			flex: 0 0 auto;
			outline-offset: 2px;  /* Give the outline some space */
		}

		.chat-input-container {
			display: flex;
			gap: 0;
			width: 100%;
		}

		#chat-input {
			width: calc(100% - 44px);
			border-radius: 8px 0 0 8px;
			border-right: none;
		}

		#send-btn {
			width: 40px;
			background: var(--accent);
			color: white;
			border: 1px solid var(--accent);
			border-radius: 0 8px 8px 0;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		#send-btn:hover {
			background: var(--hover);
		}

		#chat-input::placeholder {
			color: var(--text);
			opacity: 0.6;
		}

		#generate-btn {
			padding: 8px;
			background: var(--accent);
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			font-size: 14px;
			transition: background 0.2s;
			flex: 0 0 auto; /* Prevent shrinking */
		}

		#generate-btn:hover {
			background: var(--hover);
		}
		
		/* Loading animation keyframes */
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/* Loading spinner */
		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 4px solid var(--secondary);
			border-top: 4px solid var(--accent);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: 0 auto;
		}

		.loading-text {
			color: var(--text);
			text-align: center;
			margin-top: 15px;
			font-size: 14px;
			opacity: 0.8;
		}

		/* Container for loader */
		.loading-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100%;
		}
		
		.title-container {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 15px;
			margin: 0;
			padding: 5px 0;
		}

		.registration-button {
			margin: 0;
			padding: 0;
		}

		.registration-button button {
			background: var(--accent);
			color: white;
			border: none;
			padding: 5px 15px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			transition: background 0.2s;
			white-space: nowrap;
		}

		.registration-button button:hover {
			background: var(--hover);
		}

		.modal {
			display: none;
			position: fixed;
			z-index: 1000;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
		}

		.modal-content {
			background-color: var(--primary);
			margin: 15% auto;
			padding: 20px;
			border: 2px solid var(--accent);
			border-radius: 10px;
			width: 300px;
			position: relative;
		}

		.close {
			color: var(--text);
			float: right;
			font-size: 28px;
			font-weight: bold;
			cursor: pointer;
		}

		.close:hover {
			color: var(--accent);
		}

		.modal-content h2 {
			color: var(--accent);
			margin-bottom: 15px;
		}
		
		.modal-content input {
			width: 100%;
			padding: 8px;
			margin: 10px 0;
			background: var(--secondary);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			text-transform: uppercase;
		}

		.modal-content button {
			background: var(--accent);
			color: white;
			border: none;
			padding: 8px 20px;
			border-radius: 4px;
			cursor: pointer;
			width: 100%;
			margin-top: 10px;
		}

		.modal-content button:hover {
			background: var(--hover);
		}

		.error {
			color: #ff6b6b;
			font-size: 12px;
			margin-top: 5px;
			min-height: 15px;
		}

		.registered {
			background: var(--secondary) !important;
			cursor: default !important;
		}
		
		.locked-choice {
			color: #ff6b6b !important;
			font-weight: bold;
		}

		.history-locked-placeholder {
			background: var(--secondary);
			border: 2px dashed var(--border);
			display: flex;
			align-items: center;
			justify-content: center;
			color: #ff6b6b;
			font-size: 20px;
			cursor: not-allowed;
		}

		.option.locked .controls button {
			background: var(--secondary);
			cursor: not-allowed;
		}

		.option.locked .controls button::after {
			content: '🔒';
			font-size: 12px;
		}

		.option.locked .choice {
			color: #ff6b6b;
		}

		.code-actions {
			margin-top: 20px;
			display: flex;
			gap: 10px;
			flex-direction: column;
		}

		.secondary-btn {
			background: var(--secondary);
			color: var(--text);
			border: 1px solid var(--border);
			padding: 8px 20px;
			border-radius: 4px;
			cursor: pointer;
			width: 100%;
			transition: all 0.2s;
		}

		.secondary-btn:hover {
			border-color: var(--accent);
			background: var(--primary);
		}

		.warning-btn {
			background: #ff6b6b;
			color: white;
			border: none;
			padding: 8px 20px;
			border-radius: 4px;
			cursor: pointer;
			width: 100%;
			margin-top: 10px;
		}

		.code-display {
			background: var(--secondary);
			padding: 10px;
			border-radius: 4px;
			text-align: center;
			font-family: monospace;
			font-size: 18px;
			margin: 10px 0;
		}

		.premium-info {
			background: linear-gradient(to right, rgba(108, 92, 231, 0.1), rgba(108, 92, 231, 0.05));
			border-left: 3px solid var(--accent);
			padding: 2px 8px; /* MINIMAL padding */
			margin: 0;
			border-radius: 8px;
		}

		.premium-header {
			color: var(--accent);
			font-weight: bold;
			margin: 0;
			padding: 0;
		}

		.premium-features {
			list-style: none;
			padding: 0;
			margin: 0;
		}

		.premium-features li {
			margin: 0;
			padding: 0;
			color: #a8a8a8;
			line-height: 1; /* NO extra line height */
		}

		.premium-note {
			color: var(--accent);
			margin: 0;
			padding: 0;
			font-style: italic;
		}

		.option.locked {
			position: relative;
			overflow: hidden;
		}

		.option.locked::after {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(45deg, rgba(108, 92, 231, 0), rgba(108, 92, 231, 0.1), rgba(108, 92, 231, 0));
			background-size: 200% 200%;
			animation: pulse 2s ease-in-out infinite;
		}

		@keyframes pulse {
			0% { background-position: 0% 0%; }
			50% { background-position: 100% 100%; }
			100% { background-position: 0% 0%; }
		}

		/* Mobile-first base adjustments */
		@media screen and (max-width: 768px) {
			:root {
				--nav-height: 72px;
			}

			.main-wrapper {
				height: auto;
				min-height: calc(100vh - var(--nav-height));
				padding: 10px;
			}

			.container {
				width: 100%;
				height: auto;
				min-height: calc(100vh - var(--nav-height) - 20px);
				grid-template-columns: 1fr;
				gap: 10px;
				padding: 10px;
			}

			#left-panel {
				padding-left: 0;
				padding-right: 0;
				order: 1;
			}

			#history-strip {
				position: relative;
				width: 100%;
				height: 110px;
				flex-direction: row;
				overflow-x: auto;
				overflow-y: hidden;
				border-right: none;
				border-bottom: 2px solid var(--border);
				padding: 8px;
				margin-bottom: 10px;
			}

			.history-item {
				flex: 0 0 95px;
				margin-right: 8px;
			}

			#creature-display {
				min-height: 300px;
				max-height: 40vh;
			}

			.title-container {
				flex-direction: column;
				gap: 8px;
				padding: 10px 0;
			}

			#right-panel {
				order: 2;
				gap: 10px;
			}

			.options {
				grid-template-columns: repeat(1, 1fr);
				gap: 6px;
			}

			/* Stack options in two columns for slightly larger phones */
			@media (min-width: 480px) {
				.options {
					grid-template-columns: repeat(2, 1fr);
				}
			}

			#chat-section {
				height: auto;
				min-height: 200px;
				max-height: 300px;
			}

			#chat-input {
				width: 100%;
				margin: 0;
			}

			/* Add send button container */
			.chat-input-container {
				display: flex;
				gap: 8px;
				padding: 0 4px;
			}

			#chat-input {
				flex: 1;
			}

			#send-btn {
				padding: 8px 16px;
				background: var(--accent);
				color: white;
				border: none;
				border-radius: 8px;
				cursor: pointer;
				font-size: 14px;
			}

			#send-btn:hover {
				background: var(--hover);
			}

			/* Adjust modal for mobile */
			.modal-content {
				width: 90%;
				max-width: 350px;
				margin: 20% auto;
			}
		}

		/* Landscape orientation adjustments */
		@media screen and (max-width: 768px) and (orientation: landscape) {
			.container {
				grid-template-columns: 1fr 1fr;
			}

			#creature-display {
				min-height: 200px;
			}

			.options {
				grid-template-columns: repeat(2, 1fr);
			}

			#chat-section {
				max-height: 150px;
			}
		}

		/* Small height screens */
		@media screen and (max-height: 600px) {
			#creature-display {
				min-height: 200px;
			}

			#chat-section {
				max-height: 150px;
			}
		}

		/* Ensure minimum tap target sizes */
		@media (hover: none) and (pointer: coarse) {
			.controls button {
				min-width: 36px;
				min-height: 36px;
			}

			#send-btn,
			#generate-btn {
				min-height: 44px;
			}

			input,
			button {
				font-size: 16px; /* Prevent auto-zoom on iOS */
			}
		}

    </style>
</head>
<body>
    <script src="/js/nav-loader.js"></script>
    <div class="main-wrapper">
        <div class="container">
			<div id="left-panel">
				<div id="history-strip"></div>
				<div class="title-container">
					<div id="registration-status" class="registration-button">
						<button id="register-btn">ENTER UNLOCK CODE</button>
					</div>
					<h1>Creature Builder AI</h1>
				</div>
				<div id="creature-display">
					<p>Your creature will appear here.</p>
				</div>
			</div>

            <div id="right-panel">
                <div class="options">
                    <div class="option" data-type="Eyes">
                        <h3>Eyes</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Round</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Nose">
                        <h3>Nose</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Pointy</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Ears">
                        <h3>Ears</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Large</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Hair">
                        <h3>Hair</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Straight</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Type">
                        <h3>Type</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Humanoid</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Background">
                        <h3>Background</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Forest</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Style">
                        <h3>Style</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Realistic</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Style2">
                        <h3>Style 2</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Elegant</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Item">
                        <h3>Item</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">None</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                    <div class="option" data-type="Outfit">
                        <h3>Outfit</h3>
                        <div class="controls">
                            <button class="prev">←</button>
                            <span class="choice">Natural</span>
                            <button class="next">→</button>
                        </div>
                    </div>
                </div>

				<div id="chat-section">
					<div id="chat-output"></div>
					<div class="chat-input-container">
						<input type="text" id="chat-input" placeholder="Describe your creature to the AI...">
						<button id="send-btn">➤</button>
					</div>
					<button id="generate-btn">Generate Creature</button>
				</div>
            </div>
        </div>
    </div>
	<div id="register-modal" class="modal">
		<div class="modal-content">
			<span class="close">&times;</span>
			<h2>Enter Unlock Code</h2>
			
			<!-- Registration view -->
			<div id="registration-view">
				<p>Please enter your 6-character unlock code:</p>
				<input type="text" id="unlock-code" maxlength="6" placeholder="XXXXXX">
				<p id="code-error" class="error"></p>
				<button id="submit-code">Submit</button>
				
				<div class="code-actions">
					<button id="get-code-btn" class="secondary-btn">Get Free Code</button>
					<button id="donate-btn" class="secondary-btn">❤️ Support Development</button>
				</div>
			</div>

			<!-- Registered status view -->
			<div id="registered-view" style="display: none;">
				<p>Currently registered with code:</p>
				<p id="current-code" class="code-display"></p>
				<button id="return-to-demo" class="warning-btn">Return to Demo Mode</button>
				<button id="donate-btn-reg" class="secondary-btn">❤️ Support Development</button>
			</div>
		</div>
	</div>
    <script>

		function cleanAndInitializeStorage() {
			// Clear out any broken history
			localStorage.removeItem('creatureHistory');
			localStorage.removeItem('generations');
			
			// Initialize with empty history
			localStorage.setItem('creatureHistory', JSON.stringify([]));
		}

		const DEMO_RESTRICTIONS = {
			unregisteredOptions: {
				Eyes: ["Round", "Slanted"],
				Nose: ["Pointy", "Flat"],
				Ears: ["Large", "Pointy"],
				Hair: ["Straight", "Curly"],
				Type: ["Humanoid", "Feline"],
				Background: ["Forest", "Desert"],
				Style: ["Realistic"],
				Style2: ["Elegant"],
				Item: ["None"],
				Outfit: ["Natural"]
			},
			maxHistoryItems: 3,
			
			// Add these two methods
			hasFeatureAccess: function(feature, value) {
				const isRegistered = localStorage.getItem('registered') === 'true';
				if (isRegistered) {
					return true;  // Registered users have access to everything
				}
				// Unregistered users are limited to demo options
				return this.unregisteredOptions[feature]?.includes(value) || false;
			},
			
			getAvailableOptions: function(feature) {
				const isRegistered = localStorage.getItem('registered') === 'true';
				return isRegistered ? FEATURE_OPTIONS[feature] : this.unregisteredOptions[feature];
			}
		};

		const PREMIUM_INFO_HTML = `
			<div class="premium-info">
				<p class="premium-header">🔓 Unlock Premium Features:</p>
				<ul class="premium-features">
					<li>✨ 11 Unique Style Options</li>
					<li>🎭 11 Style Effects</li>
					<li>⚔️ Magical Items & Artifacts</li>
					<li>👘 Custom Outfits & Armor</li>
					<li>📸 Save up to 50 Creatures</li>
				</ul>
				<p class="premium-note">Get your free unlock code to access all features!</p>
			</div>`;


		function initializeOptions(isRegistered) {
			const lockedFeatures = ['Style', 'Style2', 'Item', 'Outfit']; // Features to lock for unregistered users

			document.querySelectorAll('.option').forEach(option => {
				const type = option.dataset.type;
				const isLocked = !isRegistered && lockedFeatures.includes(type);

				// Add or remove locked class
				option.classList.toggle('locked', isLocked);

				const choices = isRegistered ? FEATURE_OPTIONS[type] : DEMO_RESTRICTIONS.unregisteredOptions[type];
				const choiceSpan = option.querySelector('.choice');

				// Handle locked features
				if (isLocked) {
					choiceSpan.textContent = 'LOCKED';
					choiceSpan.classList.add('locked-choice');
				} else {
					choiceSpan.classList.remove('locked-choice');
				}

				// Reset to a valid choice if necessary
				const currentValue = choiceSpan.textContent;
				if (!choices.includes(currentValue) || currentValue === 'LOCKED') {
					choiceSpan.textContent = choices[0];
					localStorage.setItem(type, choices[0]);
				}

				// Attach or reattach event listeners
				const prevBtn = option.querySelector('.prev');
				const nextBtn = option.querySelector('.next');

				if (isLocked) {
					prevBtn.disabled = true;
					nextBtn.disabled = true;
				} else {
					prevBtn.disabled = false;
					nextBtn.disabled = false;

					// Ensure event listeners are properly bound
					prevBtn.onclick = () => {
						let currentIndex = choices.indexOf(choiceSpan.textContent);
						currentIndex = (currentIndex - 1 + choices.length) % choices.length;
						choiceSpan.textContent = choices[currentIndex];
						localStorage.setItem(type, choices[currentIndex]);
					};

					nextBtn.onclick = () => {
						let currentIndex = choices.indexOf(choiceSpan.textContent);
						currentIndex = (currentIndex + 1) % choices.length;
						choiceSpan.textContent = choices[currentIndex];
						localStorage.setItem(type, choices[currentIndex]);
					};
				}
			});
		}

	
		const invalidCodes = [
			'123456', '012345', '543210', '654321', '111111', '222222', '333333',
			'444444', '555555', '666666', '777777', '888888', '999999', '000000',
			'AAAAAA', 'BBBBBB', 'CCCCCC', 'DDDDDD', 'EEEEEE', 'FFFFFF'
		];

		const isValidFormat = (code) => {
			return /^[A-Z0-9]{6}$/.test(code);
		};

		const isTooSimple = (code) => {
			return invalidCodes.includes(code) || 
				   /^(.)\1+$/.test(code) || // Repeated characters
				   /^(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F){6}$/.test(code); // Sequential characters
		};	
	
		document.addEventListener('DOMContentLoaded', () => {
			const isRegistered = localStorage.getItem('registered') === 'true';
			const registerBtn = document.getElementById('register-btn');
			const chatOutput = document.getElementById('chat-output');

			if (isRegistered) {
				registerBtn.textContent = 'REGISTERED';
				registerBtn.classList.add('registered');
				// Clear any premium info if registered
				chatOutput.innerHTML = '';
			} else {
				// Only show premium info if NOT registered
				chatOutput.innerHTML = PREMIUM_INFO_HTML;
			}

			// Initialize options based on registration status
			initializeOptions(isRegistered);
		});


		// Modal functionality
		const modal = document.getElementById('register-modal');
		const registerBtn = document.getElementById('register-btn');
		const closeBtn = document.querySelector('.close');
		const submitBtn = document.getElementById('submit-code');
		const codeInput = document.getElementById('unlock-code');
		const errorText = document.getElementById('code-error');

		registerBtn.onclick = () => {
			const isRegistered = localStorage.getItem('registered') === 'true';
			if (isRegistered) {
				// Show registered status view
				document.getElementById('registration-view').style.display = 'none';
				document.getElementById('registered-view').style.display = 'block';
				document.getElementById('current-code').textContent = 
					localStorage.getItem('unlock-code') || 'Unknown';
			} else {
				// Show registration view
				document.getElementById('registration-view').style.display = 'block';
				document.getElementById('registered-view').style.display = 'none';
			}
			modal.style.display = 'block';
		};

		// Add code generator function
		function generateUnlockCode() {
			const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
			let code;
			do {
				code = '';
				for(let i = 0; i < 6; i++) {
					code += chars[Math.floor(Math.random() * chars.length)];
				}
			} while(isTooSimple(code)); // Reuse your existing validation
			return code;
		}

		// Button handlers for free code and donation
		document.getElementById('get-code-btn').onclick = () => {
			const code = generateUnlockCode();
			document.getElementById('unlock-code').value = code;
		};

		document.getElementById('donate-btn').onclick = 
		document.getElementById('donate-btn-reg').onclick = () => {
			window.open('https://paypal.me/ReverendDrTolerant?country.x=US&locale.x=en_US', '_blank');
		};

		// Return to demo mode handler
		document.getElementById('return-to-demo').onclick = () => {
			if(confirm('Are you sure you want to return to demo mode? You can always register again later.')) {
				localStorage.removeItem('registered');
				localStorage.removeItem('unlock-code');
				registerBtn.textContent = 'ENTER UNLOCK CODE';
				registerBtn.classList.remove('registered');
				initializeOptions(false);
				updateHistoryStrip();
				modal.style.display = 'none';

				// Clear chat and show premium info
				const chatOutput = document.getElementById('chat-output');
				chatOutput.innerHTML = PREMIUM_INFO_HTML;
				
				// Reset to demo mode
				window.location.reload();
			}
		};

		closeBtn.onclick = () => {
			modal.style.display = 'none';
			codeInput.value = '';
			errorText.textContent = '';
		};

		window.onclick = (event) => {
			if (event.target === modal) {
				modal.style.display = 'none';
				codeInput.value = '';
				errorText.textContent = '';
			}
		};

		codeInput.addEventListener('input', (e) => {
			e.target.value = e.target.value.toUpperCase();
		});

		submitBtn.onclick = () => {
			const code = codeInput.value.toUpperCase();
			
			if (!isValidFormat(code)) {
				errorText.textContent = 'Code must be 6 alphanumeric characters';
				return;
			}
			
			if (isTooSimple(code)) {
				errorText.textContent = 'Invalid code format. Try something more complex.';
				return;
			}
			
			// Valid code entered - unlock everything
			localStorage.setItem('registered', 'true');
			localStorage.setItem('unlock-code', code); // Store the code used
			registerBtn.textContent = 'REGISTERED';
			registerBtn.classList.add('registered');
			
			// Remove all locked states
			document.querySelectorAll('.option.locked').forEach(option => {
				option.classList.remove('locked');
				const choiceSpan = option.querySelector('.choice');
				choiceSpan.classList.remove('locked-choice');
			});
			
			// Clear chat and remove premium info
			const chatOutput = document.getElementById('chat-output');
			chatOutput.innerHTML = ''; // Clear the chat window
			
			// Reinitialize options with full feature set
			initializeOptions(true);
			
			// Update history strip with potentially more items
			updateHistoryStrip();
			
			// Close modal and clean up
			modal.style.display = 'none';
			codeInput.value = '';
			errorText.textContent = '';
		};

	
		const FEATURE_OPTIONS = {
			Eyes: ["Piercing", "Slanted", "Glowing", "Sharp", "Alien", "Compound", "Ethereal", "Crystalline", "Predatory", "Ancient", "Blazing"],
			Nose: ["Sculpted", "Flat", "Beak-like", "Button", "Ridged", "Snout", "Reptilian", "Minimal", "Textured", "Insectoid", "Inset"],
			Ears: ["Large", "Pointed", "Rounded", "Feral", "Fin-like", "Feathered", "Spiral", "Runic", "Mechanical", "Camouflaged", "Pierced"],
			Hair: ["Flowing", "Wild", "Windswept", "Sleek", "Tentacular", "Feathered", "Spiked", "Prismatic", "Ethereal", "Shifting", "Crowned"],
			Type: ["Humanoid", "Feline", "Canine", "Synthetic", "Draconic", "Insectoid", "Aquatic", "Avian", "Elemental", "Celestial", "Infernal"],
			Background: ["Misty Forest", "Barren Desert", "Neon Cityscape", "Stellar Void", "Abyssal Depths", "Jagged Peaks", "Molten Realm", "Prismatic Cavern", "Cosmic Expanse", "Forgotten Sanctum", "Hellscape"],
			Style: ["Mythic", "Technological", "Urban", "Ethereal", "Industrial", "Spectral", "Dark", "Primordial", "Astral", "Legendary", "Transcendent"],
			Style2: ["Elegant", "Fierce", "Enigmatic", "Timeless", "Futuristic", "Mystical", "Shadowy", "Primal", "Luminous", "Cryptic", "Supernatural"],
			Item: ["Arcane Staff", "Runic Blade", "Resonance Orb", "Forbidden Tome", "Quantum Prism", "Ancient Relic", "Quantum Device", "Alchemical Vial", "Celestial Artifact", "Void Essence", "Infernal Sigil"],
			Outfit: ["Mystic Robes", "Battle Armor", "Biomechanical", "Energy Weave", "Tribal Vestments", "Regal Attire", "Spectral Garment", "War Regalia", "Cosmic Raiment", "Bare Essence", "Hellforged Plate"]
		};

        const CreatureState = {
            currentSettings: {},
            
            // Initialize settings from localStorage
            init() {
                Object.keys(FEATURE_OPTIONS).forEach(feature => {
                    this.currentSettings[feature] = localStorage.getItem(feature) || FEATURE_OPTIONS[feature][0];
                });
                return this.currentSettings;
            },

            // Get current settings
            getSettings() {
                return this.currentSettings;
            },

            // Update a single setting
            updateSetting(feature, value) {
                if (FEATURE_OPTIONS[feature] && FEATURE_OPTIONS[feature].includes(value)) {
                    this.currentSettings[feature] = value;
                    localStorage.setItem(feature, value);
                    updateFeature(feature, value);
                    return true;
                }
                return false;
            },

            // Update multiple settings
            updateSettings(settings) {
                Object.entries(settings).forEach(([feature, value]) => {
                    this.updateSetting(feature, value);
                });
            },

            // Convert settings to string format
            toString() {
                return Object.entries(this.currentSettings)
                    .map(([feature, value]) => `${feature}:${value}`)
                    .join(',');
            }
        };

        // Initialize state
        CreatureState.init();

		const FULL_AI_INSTRUCTIONS = `You are an AI assistant controlling a creature generator with these exact options: ${JSON.stringify(FEATURE_OPTIONS)}. Rules: 1. Choose only from these options. 2. When user requests changes, select closest matching options. ALL SETTINGS ARE COMPLETELY INDEPENDENT - changing one setting must NEVER automatically change another unless specifically requested. Random generations MUST use entirely different options from previous settings. 3. First provide a brief, vivid description of the creature that can be used as an image generation prompt. 4. Then on a new line after your description, add your settings in this format: SETTINGS:Eyes:[option],Nose:[option],Ears:[option],Hair:[option],Type:[option],Background:[option],Style:[option],Style2:[option],Item:[option],Outfit:[option]. 5. The ANALYZE command can be used on its own line to receive a description of how the current creature appears. Example response: A mystical feline creature with alien-like glowing eyes, perched in an ancient forest clearing. Its elegant crystal horns catch the morning light while mystical runes dance around an ancient staff in its grasp. SETTINGS:Eyes:Glowing,Nose:Dragon-like,Ears:Horn-like,Hair:Crystal,Type:Feline,Background:Forest,Style:Mythical,Style2:Magical,Item:Staff,Outfit:Mystical. When analyzing the current image, respond with ONLY the word ANALYZE on its own line. After receiving image analysis, you can discuss the creature and suggest changes based on what you see. To check current settings before making changes, respond with ONLY the word SETTINGS on its own line to receive the current configuration.`;

		const DEMO_AI_INSTRUCTIONS = `You are an AI assistant controlling a creature generator with these DEMO options - only use these specific choices: Eyes:[Round,Slanted], Nose:[Pointy,Flat], Ears:[Large,Pointy], Hair:[Straight,Curly], Type:[Humanoid,Feline], Background:[Forest,Desert]. Style, Style2, Item and Outfit features are locked in demo mode. Rules: 1. Choose only from these limited options. 2. When user requests changes, select closest matching options from the demo choices only. 3. First provide a brief, vivid description of the creature that can be used as an image generation prompt, omitting any mention of locked features or features set to "None". 4. Then on a new line after your description, add your settings in this format: SETTINGS:Eyes:[option],Nose:[option],Ears:[option],Hair:[option],Type:[option],Background:[option]. Note: This is a demo version with limited options. Register to unlock Style, Style2, Item, Outfit features and many more creature options! Example response: A humanoid creature with round eyes and large pointed ears, its straight hair flowing in the desert wind. SETTINGS:Eyes:Round,Ears:Large,Hair:Straight,Type:Humanoid,Background:Desert. The ANALYZE and SETTINGS commands work the same as full version.`;

		function updateFeature(type, value) {
			const option = document.querySelector(`[data-type="${type}"]`);
			if (option) {
				// Only update if user has access to this feature/value
				if (DEMO_RESTRICTIONS.hasFeatureAccess(type, value)) {
					const choiceSpan = option.querySelector('.choice');
					choiceSpan.textContent = value;
					localStorage.setItem(type, value);
				}
			}
		}

		function showLoading() {
			const display = document.getElementById('creature-display');
			display.innerHTML = `
				<div class="loading-container">
					<div class="loading-spinner"></div>
					<div class="loading-text">Generating your creature...</div>
					<div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">
						This may take a few moments
					</div>
				</div>
			`;
		}

		function showDefault() {
			const display = document.getElementById('creature-display');
			display.innerHTML = `<p>Your creature will appear here.</p>`;
		}

		// Add this function to handle image to base64 conversion
		async function imageToBase64(imageUrl) {
			try {
				const response = await fetch(imageUrl);
				const blob = await response.blob();
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onloadend = () => {
						const base64String = reader.result.split(',')[1];
						resolve(base64String);
					};
					reader.onerror = reject;
					reader.readAsDataURL(blob);
				});
			} catch (error) {
				console.error('Error converting image to base64:', error);
				throw error;
			}
		}

		function formatImagePrompt(settings) {
			const isRegistered = localStorage.getItem('registered') === 'true';
			
			// Base prompt structure with placeholders - different for demo vs full
			const promptTemplate = isRegistered ? 
				"Imagine a {TYPE} being with {EYES} eyes, {EARS} ears, " + 
				"{HAIR} hair and a {NOSE} nose that is holding a {ITEM} " + 
				"while wearing {OUTFIT} attire in a {BACKGROUND} setting. " + 
				"Render in a {STYLE} style with {STYLE2} characteristics" :
				"Imagine a {TYPE} being with {EYES} eyes, {EARS} ears, " + 
				"{HAIR} hair" + (settings.Nose !== 'None' ? " and a {NOSE} nose" : "") + 
				" in a {BACKGROUND} setting";

			// Clean up settings values for natural language
			const formattedSettings = {
				TYPE: settings.Type?.toUpperCase() || '',
				EYES: settings.Eyes?.toUpperCase() || '',
				EARS: settings.Ears?.toUpperCase() || '',
				HAIR: settings.Hair?.toUpperCase() || '',
				NOSE: settings.Nose !== 'None' ? settings.Nose?.toUpperCase() : '',
				BACKGROUND: settings.Background?.toUpperCase() || ''
			};

			// Only add locked features if registered
			if (isRegistered) {
				Object.assign(formattedSettings, {
					ITEM: settings.Item !== 'None' ? settings.Item?.toUpperCase() : '',
					OUTFIT: settings.Outfit !== 'None' ? settings.Outfit?.toUpperCase() : '',
					STYLE: settings.Style?.toUpperCase() || '',
					STYLE2: settings.Style2?.toUpperCase() || ''
				});
			}

			// Replace placeholders with actual values
			let prompt = promptTemplate;
			for (const [key, value] of Object.entries(formattedSettings)) {
				prompt = prompt.replace(`{${key}}`, value);
			}

			// Clean up any remaining placeholders and multiple spaces
			prompt = prompt.replace(/\{[A-Z]+\}/g, '')
						  .replace(/\s+/g, ' ')
						  .replace(/\s+\./g, '.')
						  .trim();

			return prompt;
		}

		async function handleAnalyzeCommand(userMessage, currentSettings) {
			const analysis = await analyzeCreature();
			if (!analysis) {
				return "I was unable to analyze the image.";
			}

			const settingsStr = Object.entries(currentSettings)
				.map(([key, value]) => `${key}:${value}`)
				.join(',');

			const response = await fetch('https://text.pollinations.ai/', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					messages: [
						{
							role: 'system',
							content: localStorage.getItem('registered') === 'true' ? 
								FULL_AI_INSTRUCTIONS : DEMO_AI_INSTRUCTIONS
						},
						{
							role: 'user',
							content: `Current settings are: SETTINGS:${settingsStr}\n${userMessage}\n${analysis}`
						}
					],
					model: 'openai',
					private: true
				})
			});

			return await response.text();
		}

		async function analyzeCreature() {
			const creatureImage = document.querySelector('#creature-display img');
			if (!creatureImage) {
				return null;
			}

			try {
				const base64Image = await imageToBase64(creatureImage.src);
				const currentSettings = {};
				document.querySelectorAll('.option').forEach(option => {
					const type = option.dataset.type;
					const choice = option.querySelector('.choice').textContent;
					currentSettings[type] = choice;
				});

				const settingsStr = Object.entries(currentSettings)
					.map(([key, value]) => `${key}:${value}`)
					.join(',');

				const prompt = `Current settings are: SETTINGS:${settingsStr}\nDescribe EXACTLY everything you see in this image including gender and rendering styles used.`;
				
				const requestBody = {
					"messages": [
						{
							"role": "user",
							"content": [
								{ "type": "text", "text": prompt },
								{ "type": "image_url", "image_url": { "url": `data:image/jpeg;base64,${base64Image}` } }
							]
						}
					],
					"model": "openai",
					"jsonMode": false
				};

				const response = await fetch('https://text.pollinations.ai/', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(requestBody)
				});

				const description = await response.text();
				return description.trim();
			} catch (error) {
				console.error('Error analyzing creature:', error);
				return null;
			}
		}

		// Add this helper function to check if settings actually changed
		function didSettingsChange(oldSettings, newSettings) {
			return Object.entries(newSettings).some(([key, value]) => 
				oldSettings[key] !== value
			);
		}

		function saveToHistory(imageUrl, settings) {
			// Don't save if we don't have valid data
			if (!imageUrl || !settings) {
				console.warn('Invalid image data, not saving to history');
				return;
			}

			try {
				let history = JSON.parse(localStorage.getItem('creatureHistory') || '[]');
				const isRegistered = localStorage.getItem('registered') === 'true';
				
				// Create history entry with base64 image data
				const img = document.querySelector('#creature-display img');
				if (!img) {
					console.warn('No image found to save');
					return;
				}

				// Create a canvas to get image data
				const canvas = document.createElement('canvas');
				canvas.width = img.naturalWidth;
				canvas.height = img.naturalHeight;
				const ctx = canvas.getContext('2d');
				ctx.drawImage(img, 0, 0);
				const base64Image = canvas.toDataURL('image/jpeg', 0.8); // Compress to JPEG with 0.8 quality

				const historyEntry = {
					imageData: base64Image, // Store the actual image data instead of URL
					settings,
					timestamp: Date.now()
				};
				
				// Add to beginning of history
				history.unshift(historyEntry);
				
				// Apply appropriate limit
				const limit = isRegistered ? 50 : DEMO_RESTRICTIONS.maxHistoryItems;
				history = history.slice(0, limit);
				
				// Save updated history
				localStorage.setItem('creatureHistory', JSON.stringify(history));
				
				// Update the display
				updateHistoryStrip();
			} catch (error) {
				console.error('Error saving to history:', error);
			}
		}

		function setupHistoryItemEvents() {
			document.querySelectorAll('.history-item').forEach(item => {
				// Remove any existing event listeners
				item.removeEventListener('click', handleHistoryItemClick);
				
				// Add new click event listener
				item.addEventListener('click', handleHistoryItemClick);
			});
		}

		function handleHistoryItemClick(event) {
			event.stopPropagation();
			const historyItem = event.currentTarget;
			
			// Get the image URL
			const imageUrl = historyItem.querySelector('img').src;
			
			// Parse the settings from the settings div
			const settingsDiv = historyItem.querySelector('.settings');
			const settingsText = settingsDiv.textContent;
			const settings = {};
			
			settingsText.split('\n').forEach(line => {
				const [key, value] = line.split(':').map(s => s.trim());
				if (key && value) {
					settings[key] = value;
				}
			});
			
			// Call restoreCreature with both pieces of data
			restoreCreature(imageUrl, settings);
		}

		function updateHistoryStrip() {
			const historyStrip = document.getElementById('history-strip');
			let history = JSON.parse(localStorage.getItem('creatureHistory') || '[]');
			const isRegistered = localStorage.getItem('registered') === 'true';
			
			// Filter out any entries without imageData
			history = history.filter(item => item.imageData);
			
			// Trim history to demo limit for unregistered users
			const displayHistory = isRegistered ? history : history.slice(0, DEMO_RESTRICTIONS.maxHistoryItems);
			
			let html = '';
			
			// Add actual history items using stored base64 image data
			html += displayHistory.map(item => `
				<div class="history-item">
					<img src="${item.imageData}" alt="Historical creature">
					<div class="settings">${formatSettings(item.settings)}</div>
				</div>
			`).join('');
			
			// Add locked placeholders if not registered
			if (!isRegistered) {
				const numPlaceholders = 5;
				for (let i = 0; i < numPlaceholders; i++) {
					html += `
						<div class="history-item history-locked-placeholder">
							🔒
						</div>
					`;
				}
			}
			
			historyStrip.innerHTML = html;
			setupHistoryItemEvents();
		}

		function cleanupHistory() {
			try {
				let history = JSON.parse(localStorage.getItem('creatureHistory') || '[]');
				// Remove any entries without valid imageData
				history = history.filter(item => item && item.imageData && item.settings);
				localStorage.setItem('creatureHistory', JSON.stringify(history));
				updateHistoryStrip();
			} catch (error) {
				console.error('Error cleaning history:', error);
				localStorage.setItem('creatureHistory', JSON.stringify([]));
			}
		}

		// Update window load event
		window.addEventListener('load', () => {
			updateHistoryStrip();
		});

		// Add this helper function to verify current settings
		function getCurrentSettings() {
			const currentSettings = {};
			document.querySelectorAll('.option').forEach(option => {
				const type = option.dataset.type;
				const choice = option.querySelector('.choice').textContent;
				currentSettings[type] = choice;
			});
			return currentSettings;
		}

		// Update the formatSettings function to be more robust
		function formatSettings(settings) {
			if (!settings) return '';
			return Object.entries(settings)
				.filter(([key, value]) => key && value) // Ensure valid key-value pairs
				.map(([key, value]) => `${key}: ${value}`)
				.join('\n');
		}

		// Updated restoreCreature function
		function restoreCreature(imageData, settings) {
			// Check if we're dealing with a URL or base64 data
			const imageSource = imageData.startsWith('data:') ? imageData : imageData;
			
			// First, update the display image
			const displayContainer = document.getElementById('creature-display');
			displayContainer.innerHTML = `<img src="${imageSource}" alt="Generated Creature">`;
			
			// Update all option controls in the UI
			Object.entries(settings).forEach(([feature, value]) => {
				// Find the option element for this feature
				const option = document.querySelector(`[data-type="${feature}"]`);
				if (option) {
					// Update the visible choice text
					const choiceSpan = option.querySelector('.choice');
					if (choiceSpan) {
						choiceSpan.textContent = value;
					}
					
					// Update the current index for the feature
					const choices = FEATURE_OPTIONS[feature];
					if (choices) {
						const currentIndex = choices.indexOf(value);
						option.dataset.currentIndex = currentIndex;
					}
					
					// Store in localStorage
					localStorage.setItem(feature, value);
				}
			});
			
			// Update CreatureState if it exists
			if (typeof CreatureState !== 'undefined') {
				CreatureState.updateSettings(settings);
			}
			
			// Dispatch a custom event to notify that settings have been updated
			const updateEvent = new CustomEvent('settingsUpdated', { 
				detail: { settings: settings }
			});
			document.dispatchEvent(updateEvent);
		}

		function formatImageUrl(settings) {
			const promptText = Object.entries(settings)
				.map(([key, value]) => `${key.toLowerCase()}: ${value.toLowerCase()}`)
				.join(", ");
			const seed = Math.floor(Math.random() * 9999999);
			return `https://image.pollinations.ai/prompt/${encodeURIComponent(promptText)}?seed=${seed}&nologo=true&private=true&model=flux&enhance=true`;
		}

		async function parseAIResponse(response_text, userMessage) {
			const lines = response_text.split('\n');
			let description = [];
			
			for (const line of lines) {
				if (line.trim() === 'ANALYZE') {
					const analysis = await analyzeCreature();
					if (analysis) {
						// First get current settings
						const currentSettings = {};
						document.querySelectorAll('.option').forEach(option => {
							const type = option.dataset.type;
							const choice = option.querySelector('.choice').textContent;
							currentSettings[type] = choice;
						});

						// Format settings string
						const settingsStr = Object.entries(currentSettings)
							.map(([key, value]) => `${key}:${value}`)
							.join(',');

						// Now send message with current settings included
						const response = await fetch('https://text.pollinations.ai/', {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								messages: [
									{
										role: 'system',
										content: localStorage.getItem('registered') === 'true' ? 
											FULL_AI_INSTRUCTIONS : DEMO_AI_INSTRUCTIONS
									},
									{
										role: 'user',
										content: `Current settings are: SETTINGS:${settingsStr}\n${userMessage}`
									}
								],
								model: 'openai',
								private: true
							})
						});
						return await response.text();
					}
					return "I was unable to analyze the image.";
				} else if (line.trim() === 'SETTINGS') {
					// Get current settings
					const currentSettings = {};
					document.querySelectorAll('.option').forEach(option => {
						const type = option.dataset.type;
						const choice = option.querySelector('.choice').textContent;
						currentSettings[type] = choice;
					});
					
					const settingsStr = Object.entries(currentSettings)
						.map(([key, value]) => `${key}:${value}`)
						.join(',');
						
					const response = await fetch('https://text.pollinations.ai/', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							messages: [
								{
									role: 'system',
									content: localStorage.getItem('registered') === 'true' ? 
										FULL_AI_INSTRUCTIONS : DEMO_AI_INSTRUCTIONS
								},
								{
									role: 'user',
									content: userMessage
								},
								{
									role: 'assistant',
									content: "Let me check the current settings."
								},
								{
									role: 'user',
									content: `Current settings are: SETTINGS:${settingsStr}`
								}
							],
							model: 'openai',
							private: true
						})
					});
					return await response.text();
				} else if (line.startsWith('SETTINGS:')) {
					// Parse and apply settings
					const settingsParts = line.substring(9).split(',');
					settingsParts.forEach(setting => {
						const [feature, value] = setting.split(':');
						if (FEATURE_OPTIONS[feature] && FEATURE_OPTIONS[feature].includes(value)) {
							updateFeature(feature, value);
						}
					});
					generateCreature();
					return "Updating creature with new settings...";
				} else {
					description.push(line);
				}
			}
			return description.join('\n').trim();
		}		
		
		async function handleChat(userMessage) {
			try {
				chatOutput.innerHTML += `<p><strong>You:</strong> ${userMessage}</p>`;
				chatOutput.scrollTop = chatOutput.scrollHeight;

				// Get current settings
				const currentSettings = {};
				document.querySelectorAll('.option').forEach(option => {
					const type = option.dataset.type;
					const choice = option.querySelector('.choice').textContent;
					currentSettings[type] = choice;
				});
				const settingsStr = Object.entries(currentSettings)
					.map(([key, value]) => `${key}:${value}`)
					.join(',');

				// Include settings context in every message
				const response = await fetch('https://text.pollinations.ai/', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						messages: [
							{
								role: 'system',
								content: localStorage.getItem('registered') === 'true' ? 
									FULL_AI_INSTRUCTIONS : DEMO_AI_INSTRUCTIONS
							},
							{
								role: 'user',
								content: `Current settings are: SETTINGS:${settingsStr}\n${userMessage}`
							}
						],
						model: 'openai',
						private: true
					})
				});

				const response_text = await response.text();
				
				// If it's just ANALYZE, handle that specifically
				if (response_text.trim() === 'ANALYZE') {
					const analysis = await analyzeCreature();
					if (analysis) {
						// Get AI's interpretation of the analysis
						const aiResponse = await fetch('https://text.pollinations.ai/', {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({
								messages: [
									{
										role: 'system',
										content: localStorage.getItem('registered') === 'true' ? 
											FULL_AI_INSTRUCTIONS : DEMO_AI_INSTRUCTIONS
									},
									{
										role: 'user',
										content: `Current settings are: SETTINGS:${settingsStr}\n${userMessage}\n${analysis}`
									}
								],
								model: 'openai',
								private: true
							})
						});
						const interpretation = await aiResponse.text();
						chatOutput.innerHTML += `<p><strong>AI:</strong> ${interpretation}</p>`;
					} else {
						chatOutput.innerHTML += `<p><strong>AI:</strong> I'm sorry, I can't analyze the image right now.</p>`;
					}
				} else {
					// Handle normal responses including SETTINGS commands
					const lines = response_text.split('\n');
					let description = [];
					let settingsUpdated = false;
					
					for (const line of lines) {
						if (line.startsWith('SETTINGS:')) {
							// Update the settings
							const settingsParts = line.substring(9).split(',');
							settingsParts.forEach(setting => {
								const [feature, value] = setting.split(':');
								if (FEATURE_OPTIONS[feature] && FEATURE_OPTIONS[feature].includes(value)) {
									updateFeature(feature, value);
								}
							});
							generateCreature();
							settingsUpdated = true;
						} else {
							description.push(line);
						}
					}
					
					let displayText = description.join('\n').trim();
					if (settingsUpdated) {
						displayText += '\n\nUpdating creature with new settings...';
					}
					
					chatOutput.innerHTML += `<p><strong>AI:</strong> ${displayText}</p>`;
				}
				
				chatOutput.scrollTop = chatOutput.scrollHeight;
			} catch (error) {
				console.error('Error:', error);
				chatOutput.innerHTML += `<p><strong>Error:</strong> Failed to get AI response</p>`;
			}
		}
		
		async function generateCreature(retryCount = 0, maxRetries = 3) {
			showLoading();
			
			const selectedFeatures = {};
			document.querySelectorAll('.option').forEach(option => {
				const type = option.dataset.type;
				const choice = option.querySelector('.choice').textContent;
				selectedFeatures[type] = choice;
			});

			// Add delay between retries
			if (retryCount > 0) {
				await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));
			}

			try {
				const structuredPrompt = formatImagePrompt(selectedFeatures);
				const encodedPrompt = encodeURIComponent(structuredPrompt);
				const seed = Math.floor(Math.random() * 9999999);
				const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?seed=${seed}&nologo=true&private=true&model=flux&enhance=true`;

				// Create a promise that wraps the image loading
				const loadPromise = new Promise((resolve, reject) => {
					const img = new Image();
					let timeoutId;

					const cleanup = () => {
						clearTimeout(timeoutId);
						img.onload = null;
						img.onerror = null;
					};

					img.onload = () => {
						cleanup();
						resolve(img);
					};

					img.onerror = () => {
						cleanup();
						reject(new Error('Failed to load image'));
					};

					// Set a timeout of 20 seconds
					timeoutId = setTimeout(() => {
						cleanup();
						reject(new Error('Image load timed out'));
					}, 20000);

					img.crossOrigin = "anonymous";
					img.src = imageUrl;
				});

				const loadedImg = await loadPromise;
				const displayContainer = document.getElementById('creature-display');
				displayContainer.innerHTML = '';
				displayContainer.appendChild(loadedImg);

				// Only save to history if image loaded successfully
				if (loadedImg.complete && loadedImg.naturalWidth > 0) {
					saveToHistory(imageUrl, selectedFeatures);
				}

			} catch (error) {
				console.error('Generation error:', error);
				
				if (retryCount < maxRetries) {
					console.log(`Retrying generation (${retryCount + 1}/${maxRetries})...`);
					return generateCreature(retryCount + 1, maxRetries);
				}

				const displayContainer = document.getElementById('creature-display');
				displayContainer.innerHTML = `
					<div style="text-align: center; padding: 20px;">
						<p>Unable to generate creature. The image service may be temporarily unavailable.</p>
						<button onclick="generateCreature()" 
								style="margin-top: 10px; padding: 8px 16px; 
									   background: var(--accent); color: white; 
									   border: none; border-radius: 8px; 
									   cursor: pointer;">
							Try Again
						</button>
					</div>
				`;
			}
		}
		
		
		document.addEventListener('settingsUpdated', (event) => {
			const settings = event.detail.settings;
			console.log('Settings updated:', settings); // Keep for debugging
			
			// Store current context for AI
			localStorage.setItem('currentAIContext', JSON.stringify({
				settings: settings,
				lastUpdate: Date.now()
			}));
		});
		
		document.getElementById('send-btn').addEventListener('click', async () => {
			const userMessage = chatInput.value;
			const premiumInfo = document.querySelector('.premium-info');
			if (premiumInfo) {
				premiumInfo.remove();
			}
			chatInput.value = '';
			await handleChat(userMessage);
		});		
		
		document.querySelectorAll('.option').forEach(option => {
			const type = option.dataset.type;
			let currentIndex = 0;
			
			// Update to use restricted options list
			const getChoices = () => DEMO_RESTRICTIONS.getAvailableOptions(type);
			
			const updateChoice = (index) => {
				const choices = getChoices();
				const choiceSpan = option.querySelector('.choice');
				choiceSpan.textContent = choices[index];
				localStorage.setItem(type, choices[index]);
			};
			
			// Initialize with saved or default value
			const savedChoice = localStorage.getItem(type);
			if (savedChoice && DEMO_RESTRICTIONS.hasFeatureAccess(type, savedChoice)) {
				currentIndex = getChoices().indexOf(savedChoice);
				updateChoice(currentIndex);
			} else {
				// Reset to first available option if saved choice is no longer available
				updateChoice(0);
			}
			
			option.querySelector('.prev').addEventListener('click', () => {
				const choices = getChoices();
				currentIndex = (currentIndex - 1 + choices.length) % choices.length;
				updateChoice(currentIndex);
			});
			
			option.querySelector('.next').addEventListener('click', () => {
				const choices = getChoices();
				currentIndex = (currentIndex + 1) % choices.length;
				updateChoice(currentIndex);
			});
		});

        const chatInput = document.getElementById('chat-input');
        const chatOutput = document.getElementById('chat-output');

		chatInput.addEventListener('keypress', async (e) => {
			if (e.key === 'Enter') {
				const userMessage = chatInput.value;
				// Remove premium info if it exists
				const premiumInfo = document.querySelector('.premium-info');
				if (premiumInfo) {
					premiumInfo.remove();
				}
				chatInput.value = '';
				await handleChat(userMessage);
			}
		});
		
        document.getElementById('generate-btn').addEventListener('click', generateCreature);
        
        // Initialize history strip
        updateHistoryStrip();
		
		// Inside your existing <script> tag



		// Clean storage on page load
		window.onload = function() {
			cleanupHistory();
			updateHistoryStrip();
		};
		
    </script>
</body>
</html>