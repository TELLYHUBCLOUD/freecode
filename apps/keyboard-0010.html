<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Keyboard Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #f0f0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

		.context-menu {
			background-color: #333;
			border: 1px solid #555;
			border-radius: 4px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
			z-index: 1000;
		}

		.context-menu div {
			padding: 8px 15px;
			cursor: pointer;
		}

		.context-menu div:hover {
			background-color: #444;
		}

        /* Toolbar styles */
        .toolbar {
            background-color: #2c2c2c;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #444;
        }

        .toolbar button {
            background-color: #3c3c3c;
            color: #f0f0f0;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .toolbar button:hover {
            background-color: #4c4c4c;
        }

		.instrument-control {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.instrument-control select {
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			padding: 8px;
			border-radius: 4px;
		}

		.instrument-toolbar {
			display: flex;
			background-color: #2c2c2c;
			padding: 8px;
			gap: 8px;
			border-bottom: 1px solid #444;
		}

		.instrument-selector {
			padding: 8px 12px;
			border-radius: 4px;
			cursor: pointer;
			color: white;
			font-weight: bold;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
			transition: all 0.2s ease;
			min-width: 80px;
			text-align: center;
		}

		.instrument-selector:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
		}

		.instrument-selector.active {
			outline: 2px solid white;
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
		}

        /* Left sidebar styles */
        .sidebar {
            width: 200px;
            background-color: #252525;
            padding: 10px;
            border-right: 1px solid #444;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 10px;
            color: #b0b0b0;
        }

        .session-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .session-item:hover {
            background-color: #444;
        }

		#sessions-list {
			max-height: 300px;
			overflow-y: auto;
		}

		.session-item {
			padding: 8px;
			margin: 5px;
			background-color: #333;
			border-radius: 4px;
			cursor: pointer;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.session-item:hover {
			background-color: #444;
		}

        /* Main sequencer area */
        .sequencer-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Piano keyboard styles */
        .piano-container {
            width: 80px;
            background-color: #222;
            overflow-y: auto;
            position: relative;
        }

        .piano-key {
            height: 30px;
            margin: 1px 0;
            display: flex;
            align-items: center;
            padding-left: 10px;
            position: relative;
            cursor: pointer;
        }

        .white-key {
            background-color: #f0f0f0;
            color: #222;
            border-radius: 0 4px 4px 0;
        }

        .black-key {
            background-color: #222;
            color: #f0f0f0;
            border-radius: 0 4px 4px 0;
            border: 1px solid #444;
        }

        .piano-key:hover {
            opacity: 0.8;
        }

        /* Grid area styles */
        .grid-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background-color: #1a1a1a;
            background-image: 
                linear-gradient(to right, #333 1px, transparent 1px),
                linear-gradient(to bottom, #333 1px, transparent 1px);
            background-size: 40px 32px;
        }

		.active-grid-area {
			position: absolute;
			top: 0;
			left: 0;
			height: 100%;
			background-color: #1a1a1a;
			z-index: 1;
			pointer-events: none;
		}

		.inactive-grid-area {
			position: absolute;
			top: 0;
			height: 100%;
			background-color: #151515;
			opacity: 0.7;
			z-index: 1;
			pointer-events: none;
		}

		/* Grid control buttons */
		.grid-controls {
			position: absolute;
			right: 10px;
			top: 10px;
			display: flex;
			gap: 5px;
			z-index: 100;
		}

		.grid-control-btn {
			padding: 5px 10px;
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}

		.grid-control-btn:hover {
			background-color: #4c4c4c;
		}

		.grid-end-marker {
			position: absolute;
			top: 0;
			height: 100%;
			width: 2px;
			background-color: #ffcc00;
			z-index: 5;
		}

		.beat-indicator {
			position: absolute;
			top: 0;
			width: 1px;
			pointer-events: none;
		}

		.beat-indicator.measure {
			height: 15px;
			background-color: #fff;
		}

		.beat-indicator.beat {
			height: 5px;
			background-color: #666;
		}

		.beat-label {
			position: absolute;
			left: 5px;
			top: 0;
			font-size: 10px;
			color: #fff;
		}

        /* Note block styles */
        .note-block {
            position: absolute;
            height: 28px;
            background-color: #5b87ff;
            border-radius: 4px;
            cursor: move;
            user-select: none;
            opacity: 0.8;
        }

        .note-block:hover {
            opacity: 1;
        }

        .note-block .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: e-resize;
        }

        /* Playhead styles */
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ff5b5b;
            z-index: 10;
            pointer-events: none;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="controls">
            <button id="play-btn">Play</button>
            <button id="stop-btn">Stop</button>
            <div class="tempo-control">
                <label for="tempo">BPM:</label>
                <input type="number" id="tempo" min="60" max="200" value="120" style="width: 60px;">
            </div>
			<div class="instrument-control">
				<label for="instrument">Instrument:</label>
				<select id="instrument">
					<option value="sine">Sine</option>
					<option value="square">Square</option>
					<option value="sawtooth">Sawtooth</option>
					<option value="triangle">Triangle</option>
					<option value="piano">Piano</option>
				</select>
			</div>			
        </div>
        <button id="save-btn">Save</button>
        <button id="new-session-btn">New Session</button>
        <button id="clear-btn">Clear All</button>
    </div>

	<div class="instrument-toolbar">
		<div class="instrument-selector active" data-instrument="sine" style="background-color: #5b87ff;">
			<span>Sine</span>
		</div>
		<div class="instrument-selector" data-instrument="square" style="background-color: #ff5b87;">
			<span>Square</span>
		</div>
		<div class="instrument-selector" data-instrument="sawtooth" style="background-color: #5bff87;">
			<span>Sawtooth</span>
		</div>
		<div class="instrument-selector" data-instrument="triangle" style="background-color: #ffb75b;">
			<span>Triangle</span>
		</div>
		<div class="instrument-selector" data-instrument="piano" style="background-color: #b75bff;">
			<span>Piano</span>
		</div>
	</div>

	<div class="tooltip" style="background-color: #333; padding: 8px; margin: 5px; border-radius: 4px; font-size: 12px;">
		<p>Tips: Click grid to add notes. Right-click to delete. Drag to move. Double-click to toggle sustained/staccato mode.</p>
	</div>

    <div class="app-container">
        <div class="sidebar">
            <h3>Sessions</h3>
            <div id="sessions-list">
                <div class="session-item">New Session</div>
            </div>
        </div>

        <div class="sequencer-container">
            <div class="piano-container" id="piano-keys">
                <!-- Piano keys will be generated here -->
            </div>

            <div class="grid-container" id="grid-container">
                <div class="playhead" id="playhead"></div>
                <!-- Note blocks will be added here -->
            </div>
        </div>
    </div>

	<button id="track-toggle" class="track-toggle">Tracks</button>
	<div id="tracks-container" class="tracks-container">
		<h3 style="padding: 10px; margin: 0; color: #b0b0b0;">Tracks</h3>
		<div id="tracks-list"></div>
		<button id="add-track-btn" style="margin: 10px; padding: 8px; background-color: #3c3c3c; color: #f0f0f0; border: none; border-radius: 4px; cursor: pointer; width: calc(100% - 20px);">Add New Track</button>
	</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Constants
            const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const OCTAVES = [5, 4, 3, 2]; // Starting from higher octaves for a more intuitive layout
            const NOTE_HEIGHT = 32; // Height of each note row
            const GRID_CELL_WIDTH = 40; // Width of each grid cell
            const MAX_GRID_WIDTH = 4000; // Maximum width of the grid
			const INITIAL_GRID_CELLS = 16; // Start with 16 cells (4 bars of 4 beats)
			
            // Elements
            const pianoContainer = document.getElementById('piano-keys');
            const gridContainer = document.getElementById('grid-container');
            const playhead = document.getElementById('playhead');
            const playBtn = document.getElementById('play-btn');
            const stopBtn = document.getElementById('stop-btn');
            const tempoInput = document.getElementById('tempo');
            const clearBtn = document.getElementById('clear-btn');

            // State
            let isPlaying = false;
            let currentPosition = 0;
            let animationFrameId = null;
            let noteBlocks = [];
            let activeDragBlock = null;
            let activeResizeBlock = null;
            let dragOffset = { x: 0, y: 0 };
            let audioContext = null;
            let lastTimestamp = 0;
			let maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
			
            // Initialize audio context on user interaction
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            // Create piano keys
            function createPianoKeys() {
                let noteIndex = 0;
                
                OCTAVES.forEach(octave => {
                    NOTES.forEach(note => {
                        const keyElement = document.createElement('div');
                        const isBlackKey = note.includes('#');
                        
                        keyElement.className = `piano-key ${isBlackKey ? 'black-key' : 'white-key'}`;
                        keyElement.dataset.note = `${note}${octave}`;
                        keyElement.dataset.index = noteIndex;
                        keyElement.innerHTML = `${note}${octave}`;
                        
                        keyElement.addEventListener('click', function() {
                            playNote(note, octave, 0.5);
                        });
                        
                        pianoContainer.appendChild(keyElement);
                        noteIndex++;
                    });
                });
            }

            // Play a note
			function playNote(note, octave, duration, isSustained = false, instrumentType = 'sine') {
				initAudio();
				
				// Map note to frequency
				const noteFrequencies = {
					'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
					'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
				};
				
				// Calculate frequency based on octave
				const baseFreq = noteFrequencies[note];
				const octaveFactor = Math.pow(2, octave - 4); // Normalize to octave 4
				const frequency = baseFreq * octaveFactor;
				
				// Create oscillator
				const oscillator = audioContext.createOscillator();
				const gainNode = audioContext.createGain();
				
				// Set oscillator type based on instrument
				if (instrumentType === 'piano') {
					// Simple piano-like sound with multiple oscillators
					oscillator.type = 'triangle';
					
					// Add a second oscillator for harmonics
					const harmonicOsc = audioContext.createOscillator();
					harmonicOsc.type = 'sine';
					harmonicOsc.frequency.value = frequency * 2; // One octave higher
					
					const harmonicGain = audioContext.createGain();
					harmonicGain.gain.value = 0.2; // Lower volume for harmonic
					
					harmonicOsc.connect(harmonicGain);
					harmonicGain.connect(audioContext.destination);
					harmonicOsc.start();
					harmonicOsc.stop(audioContext.currentTime + duration);
				} else {
					oscillator.type = instrumentType; // 'sine', 'square', 'sawtooth', or 'triangle'
				}
				
				oscillator.frequency.value = frequency;
				
				// Apply envelope based on sustained or staccato
				if (isSustained) {
					// Sustained note with longer attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.05);
					gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + duration * 0.8);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
				} else {
					// Staccato note with quick attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.01);
					gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + duration * 0.3);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + Math.min(0.3, duration));
				}
				
				oscillator.connect(gainNode);
				gainNode.connect(audioContext.destination);
				
				oscillator.start();
				oscillator.stop(audioContext.currentTime + duration);
			}

            // Create a new note block
			function createNoteBlock(x, y, width = GRID_CELL_WIDTH, noteIndex, isSustained = false, instrument = 'sine') {
				const noteBlock = document.createElement('div');
				noteBlock.className = 'note-block';
				noteBlock.style.left = `${x}px`;
				noteBlock.style.top = `${y}px`;
				noteBlock.style.width = `${width}px`;
				noteBlock.dataset.noteIndex = noteIndex;
				noteBlock.dataset.sustained = isSustained;
				noteBlock.dataset.instrument = instrument;
				
				// Set color based on instrument
				noteBlock.style.backgroundColor = instrumentColors[instrument];
				
				// Style differently based on sustained/staccato
				if (isSustained) {
					noteBlock.style.opacity = '0.9';
					noteBlock.style.borderRadius = '4px';
				} else {
					noteBlock.style.opacity = '0.7';
					noteBlock.style.borderRadius = '4px 0 0 4px';
					noteBlock.style.borderRight = '1px dashed white';
				}
				
				// Get note information from the key at this index
				const pianoKey = pianoContainer.children[noteIndex];
				const noteData = pianoKey.dataset.note;
				noteBlock.dataset.note = noteData;
				
				// Create resize handle
				const resizeHandle = document.createElement('div');
				resizeHandle.className = 'resize-handle';
				noteBlock.appendChild(resizeHandle);
				
				// Set up event listeners for dragging
				noteBlock.addEventListener('mousedown', startDragBlock);
				resizeHandle.addEventListener('mousedown', startResizeBlock);
				
				// Double-click to toggle sustained/staccato
				noteBlock.addEventListener('dblclick', function(e) {
					const isSustained = noteBlock.dataset.sustained === 'true';
					noteBlock.dataset.sustained = !isSustained;
					
					if (!isSustained) {
						noteBlock.style.opacity = '0.9';
						noteBlock.style.borderRadius = '4px';
						noteBlock.style.borderRight = 'none';
					} else {
						noteBlock.style.opacity = '0.7';
						noteBlock.style.borderRadius = '4px 0 0 4px';
						noteBlock.style.borderRight = '1px dashed white';
					}
				});
				
				gridContainer.appendChild(noteBlock);
				noteBlocks.push(noteBlock);
				
				return noteBlock;
			}

			gridContainer.addEventListener('contextmenu', function(e) {
				e.preventDefault(); // Prevent the default context menu
				const block = e.target.closest('.note-block');
				if (block) {
					const blockIndex = noteBlocks.indexOf(block);
					if (blockIndex > -1) {
						noteBlocks.splice(blockIndex, 1);
					}
					block.remove();
				}
			});

            // Handle start dragging a note block
            function startDragBlock(e) {
                e.stopPropagation();
                activeDragBlock = e.target.closest('.note-block');
                
                if (activeDragBlock) {
                    const rect = activeDragBlock.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    document.addEventListener('mousemove', dragBlock);
                    document.addEventListener('mouseup', stopDragBlock);
                }
            }

            // Handle dragging a note block
            function dragBlock(e) {
                if (!activeDragBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const x = e.clientX - gridRect.left - dragOffset.x;
                const y = e.clientY - gridRect.top - dragOffset.y;
                
                // Snap to grid
                const snappedX = Math.max(0, Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                const snappedY = Math.max(0, Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2);
                
                activeDragBlock.style.left = `${snappedX}px`;
                activeDragBlock.style.top = `${snappedY}px`;
                
                // Update note index based on new position
                const noteIndex = Math.floor(snappedY / NOTE_HEIGHT);
                if (noteIndex < pianoContainer.children.length) {
                    const pianoKey = pianoContainer.children[noteIndex];
                    activeDragBlock.dataset.noteIndex = noteIndex;
                    activeDragBlock.dataset.note = pianoKey.dataset.note;
                }
            }

            // Handle stop dragging a note block
            function stopDragBlock() {
                activeDragBlock = null;
                document.removeEventListener('mousemove', dragBlock);
                document.removeEventListener('mouseup', stopDragBlock);
            }

            // Handle start resizing a note block
            function startResizeBlock(e) {
                e.stopPropagation();
                activeResizeBlock = e.target.closest('.note-block');
                
                if (activeResizeBlock) {
                    document.addEventListener('mousemove', resizeBlock);
                    document.addEventListener('mouseup', stopResizeBlock);
                }
            }

            // Handle resizing a note block
            function resizeBlock(e) {
                if (!activeResizeBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const blockRect = activeResizeBlock.getBoundingClientRect();
                
                let width = e.clientX - blockRect.left;
                width = Math.max(GRID_CELL_WIDTH, Math.floor(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                
                activeResizeBlock.style.width = `${width}px`;
            }

            // Handle stop resizing a note block
            function stopResizeBlock() {
                activeResizeBlock = null;
                document.removeEventListener('mousemove', resizeBlock);
                document.removeEventListener('mouseup', stopResizeBlock);
            }

			function saveCurrentSession() {
				const sessionName = prompt("Enter a name for your session:", "My Session");
				
				if (!sessionName) return; // User cancelled
				
				const sessionData = {
					name: sessionName,
					blocks: [],
					tempo: parseInt(tempoInput.value) || 120
				};
				
				// Save all note blocks
				const blocks = document.querySelectorAll('.note-block');
				blocks.forEach(block => {
					try {
						sessionData.blocks.push({
							x: parseInt(block.style.left) || 0,
							y: parseInt(block.style.top) || 0,
							width: parseInt(block.style.width) || GRID_CELL_WIDTH,
							noteIndex: parseInt(block.dataset.noteIndex) || 0,
							sustained: block.dataset.sustained === 'true',
							instrument: block.dataset.instrument || 'sine'
						});
					} catch (error) {
						console.error("Error saving block:", error);
					}
				});
				
				// Get existing sessions or initialize empty array
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Add new session
				sessions.push(sessionData);
				
				// Save to localStorage
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				console.log("Session saved:", sessionName, "with", sessionData.blocks.length, "blocks");
				
				// Update sessions list
				updateSessionsList();
			}

			function loadSession(sessionIndex) {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (sessionIndex >= sessions.length) return;
				
				const session = sessions[sessionIndex];
				
				// Clear current session
				clearAllNotes();
				
				// Set tempo
				tempoInput.value = session.tempo || 120;
				
				// Load all blocks
				if (session.blocks && Array.isArray(session.blocks)) {
					session.blocks.forEach(blockData => {
						try {
							// Ensure all required properties exist
							const x = typeof blockData.x === 'number' ? blockData.x : 0;
							const y = typeof blockData.y === 'number' ? blockData.y : 0;
							const width = typeof blockData.width === 'number' ? blockData.width : GRID_CELL_WIDTH;
							const noteIndex = typeof blockData.noteIndex === 'number' ? blockData.noteIndex : 0;
							const sustained = blockData.sustained === true;
							const instrument = blockData.instrument || 'sine';
							
							// Create the note block
							const block = createNoteBlock(x, y, width, noteIndex, sustained, instrument);
							
							// Ensure it has correct colors
							if (instrumentColors[instrument]) {
								block.style.backgroundColor = instrumentColors[instrument];
							}
						} catch (error) {
							console.error("Error loading block:", error, blockData);
						}
					});
				}
				
				console.log("Session loaded:", session.name, "with", session.blocks ? session.blocks.length : 0, "blocks");
			}

			function loadSavedSessions() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					sessionsList.appendChild(sessionItem);
				});
			}

			function updateSessionsList() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					// Add right-click menu for renaming and deleting
					sessionItem.addEventListener('contextmenu', function(e) {
						e.preventDefault();
						
						// Remove any existing context menus
						const existingMenus = document.querySelectorAll('.context-menu');
						existingMenus.forEach(menu => menu.remove());
						
						const options = ['Rename', 'Delete'];
						const menu = document.createElement('div');
						menu.className = 'context-menu';
						menu.style.position = 'absolute';
						menu.style.left = `${e.clientX}px`;
						menu.style.top = `${e.clientY}px`;
						menu.style.backgroundColor = '#333';
						menu.style.border = '1px solid #555';
						menu.style.borderRadius = '4px';
						menu.style.padding = '5px 0';
						menu.style.zIndex = '1000';
						
						options.forEach(option => {
							const item = document.createElement('div');
							item.innerHTML = option;
							item.style.padding = '5px 15px';
							item.style.cursor = 'pointer';
							
							item.addEventListener('mouseover', function() {
								item.style.backgroundColor = '#444';
							});
							
							item.addEventListener('mouseout', function() {
								item.style.backgroundColor = 'transparent';
							});
							
							item.addEventListener('click', function() {
								if (option === 'Rename') {
									renameSession(index);
								} else if (option === 'Delete') {
									deleteSession(index);
								}
								document.body.removeChild(menu);
							});
							
							menu.appendChild(item);
						});
						
						document.body.appendChild(menu);
						
						// Close menu when clicking outside
						document.addEventListener('click', function closeMenu(event) {
							if (document.body.contains(menu)) {
								document.body.removeChild(menu);
							}
							document.removeEventListener('click', closeMenu);
						});
					});
					
					sessionsList.appendChild(sessionItem);
				});
				
				// Add "New Session" button
				const newSessionItem = document.createElement('div');
				newSessionItem.className = 'session-item new-session';
				newSessionItem.innerHTML = '+ New Session';
				newSessionItem.addEventListener('click', createNewSession);
				sessionsList.appendChild(newSessionItem);
			}

			// Function to rename a session
			function renameSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				const session = sessions[index];
				const newName = prompt("Enter a new name for the session:", session.name);
				
				if (!newName) return; // User cancelled
				
				session.name = newName;
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				updateSessionsList();
			}

			// Function to delete a session
			function deleteSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				if (!confirm("Are you sure you want to delete this session?")) return;
				
				sessions.splice(index, 1);
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				// If we've removed all sessions, create a blank state
				if (sessions.length === 0) {
					clearAllNotes();
				} else {
					// Load the first available session
					loadSession(0);
				}
				
				updateSessionsList();
			}

			// Fixed create new session function
			function createNewSession() {
				clearAllNotes();
				
				// Prompt for a name
				const sessionName = prompt("Enter a name for your new session:", "New Session");
				if (!sessionName) return; // User cancelled
				
				// Create a blank session
				const sessionData = {
					name: sessionName,
					blocks: [],
					tempo: parseInt(tempoInput.value) || 120
				};
				
				// Get existing sessions
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Add new session
				sessions.push(sessionData);
				
				// Save to localStorage
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				// Update UI
				updateSessionsList();
			}

			// Modified clear function to ensure grid is properly cleared
			function clearAllNotes() {
				// Remove all note blocks from the grid
				const blocks = document.querySelectorAll('.note-block');
				blocks.forEach(block => {
					block.remove();
				});
				
				// Reset noteBlocks array
				noteBlocks = [];
			}

			function initInstrumentSelectors() {
				const selectors = document.querySelectorAll('.instrument-selector');
				
				selectors.forEach(selector => {
					selector.addEventListener('click', function() {
						// Remove active class from all selectors
						selectors.forEach(s => s.classList.remove('active'));
						
						// Add active class to clicked selector
						selector.classList.add('active');
						
						// Set current instrument
						currentInstrument = selector.dataset.instrument;
					});
				});
			}

			// Replace the existing grid container click event with these new mouse event handlers
			let isDrawing = false;
			let drawStartX = 0;
			let drawStartY = 0;
			let currentDrawBlock = null;
			let currentInstrument = 'sine';
			let instrumentColors = {
				'sine': '#5b87ff',
				'square': '#ff5b87',
				'sawtooth': '#5bff87',
				'triangle': '#ffb75b',
				'piano': '#b75bff'
			};

			// Handle mousedown to start drawing
			gridContainer.addEventListener('mousedown', function(e) {
				// Don't create a block if we're clicking on an existing block
				if (e.target.closest('.note-block')) return;
				if (e.button !== 0) return; // Only respond to left-click
				
				isDrawing = true;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;
				
				// Snap to grid
				drawStartX = Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				drawStartY = Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2;
				
				// Get note index based on y position
				const noteIndex = Math.floor(drawStartY / NOTE_HEIGHT);
				
				// Only create if within piano key range
				if (noteIndex < pianoContainer.children.length) {
					// Create initial block
					currentDrawBlock = createNoteBlock(drawStartX, drawStartY, GRID_CELL_WIDTH, noteIndex, true, currentInstrument);
				}
			});

			// Handle mousemove to extend the block
			gridContainer.addEventListener('mousemove', function(e) {
				if (!isDrawing || !currentDrawBlock) return;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				
				// Calculate width based on how far we've dragged
				let width = Math.max(GRID_CELL_WIDTH, x - drawStartX);
				width = Math.ceil(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				
				// Update the block width
				currentDrawBlock.style.width = `${width}px`;
			});

			// Handle mouseup to finish drawing
			gridContainer.addEventListener('mouseup', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

			// Handle mouseleave to finish drawing if we leave the grid
			gridContainer.addEventListener('mouseleave', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

            // Animation function for playhead
            function animate(timestamp) {
                if (!lastTimestamp) lastTimestamp = timestamp;
                
                const deltaTime = timestamp - lastTimestamp;
                lastTimestamp = timestamp;
                
                const tempo = parseInt(tempoInput.value);
                const pixelsPerBeat = GRID_CELL_WIDTH;
                const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
                const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
                
                currentPosition += pixelsDelta;
                
                // Loop back to start if we reach the end of the grid
                if (currentPosition > MAX_GRID_WIDTH) {
                    currentPosition = 0;
                }
                
                playhead.style.left = `${currentPosition}px`;
                
                // Play notes at current position
                playNotesAtPosition(currentPosition);
                
                if (isPlaying) {
                    animationFrameId = requestAnimationFrame(animate);
                }
            }

			function addGridControlButtons() {
				// Create container for grid control buttons
				const controlsContainer = document.createElement('div');
				controlsContainer.className = 'grid-controls';
				
				// Add extend button
				const extendButton = document.createElement('button');
				extendButton.innerHTML = '+';
				extendButton.title = 'Add 4 more beats';
				extendButton.className = 'grid-control-btn';
				
				// Add shrink button
				const shrinkButton = document.createElement('button');
				shrinkButton.innerHTML = '-';
				shrinkButton.title = 'Remove 4 beats';
				shrinkButton.className = 'grid-control-btn';
				
				// Add event listeners that stop event propagation
				extendButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					maxGridWidth += 4 * GRID_CELL_WIDTH;
					updateGridSize();
				});
				
				shrinkButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					// Don't allow less than the initial size
					if (maxGridWidth > INITIAL_GRID_CELLS * GRID_CELL_WIDTH) {
						maxGridWidth -= 4 * GRID_CELL_WIDTH;
						updateGridSize();
					}
				});
				
				// Also prevent mousedown events from propagating
				extendButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				shrinkButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				// Add buttons to container
				controlsContainer.appendChild(shrinkButton);
				controlsContainer.appendChild(extendButton);
				
				// Add container to grid
				gridContainer.appendChild(controlsContainer);
			}

			// Update grid size and draw end marker
			function updateGridSize() {
				// Remove existing markers
				const existingMarker = document.getElementById('grid-end-marker');
				if (existingMarker) {
					existingMarker.remove();
				}
				
				const existingActiveArea = document.querySelector('.active-grid-area');
				if (existingActiveArea) {
					existingActiveArea.remove();
				}
				
				const existingInactiveArea = document.querySelector('.inactive-grid-area');
				if (existingInactiveArea) {
					existingInactiveArea.remove();
				}
				
				// Create active grid area
				const activeArea = document.createElement('div');
				activeArea.className = 'active-grid-area';
				activeArea.style.width = `${maxGridWidth}px`;
				
				// Create inactive grid area (everything after maxGridWidth)
				const inactiveArea = document.createElement('div');
				inactiveArea.className = 'inactive-grid-area';
				inactiveArea.style.left = `${maxGridWidth}px`;
				inactiveArea.style.width = `${MAX_GRID_WIDTH - maxGridWidth}px`;
				
				// Create end marker
				const endMarker = document.createElement('div');
				endMarker.id = 'grid-end-marker';
				endMarker.className = 'grid-end-marker';
				endMarker.style.left = `${maxGridWidth}px`;
				
				// Add elements to grid in the correct order (bottom to top in terms of z-index)
				gridContainer.appendChild(activeArea);
				gridContainer.appendChild(inactiveArea);
				gridContainer.appendChild(endMarker);
				
				// Add beat indicators
				addBeatIndicators();
			}

			// Update the animation function
			function animate(timestamp) {
				if (!lastTimestamp) lastTimestamp = timestamp;
				
				const deltaTime = timestamp - lastTimestamp;
				lastTimestamp = timestamp;
				
				const tempo = parseInt(tempoInput.value);
				const pixelsPerBeat = GRID_CELL_WIDTH;
				const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
				const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
				
				currentPosition += pixelsDelta;
				
				// Loop back to start if we reach the max grid width
				if (currentPosition > maxGridWidth) {
					currentPosition = 0;
				}
				
				playhead.style.left = `${currentPosition}px`;
				
				// Play notes at current position
				playNotesAtPosition(currentPosition);
				
				if (isPlaying) {
					animationFrameId = requestAnimationFrame(animate);
				}
			}

			function addBeatIndicators() {
				// Remove existing indicators
				const existingIndicators = document.querySelectorAll('.beat-indicator');
				existingIndicators.forEach(indicator => indicator.remove());
				
				// Create beat numbers at the top
				for (let i = 0; i <= maxGridWidth / GRID_CELL_WIDTH; i++) {
					// Add a stronger indicator every 4 beats (one bar)
					const isMeasure = i % 4 === 0;
					
					const indicator = document.createElement('div');
					indicator.className = `beat-indicator ${isMeasure ? 'measure' : 'beat'}`;
					indicator.style.left = `${i * GRID_CELL_WIDTH}px`;
					
					if (isMeasure) {
						// Add measure number
						const label = document.createElement('div');
						label.innerHTML = Math.floor(i / 4) + 1;
						label.className = 'beat-label';
						indicator.appendChild(label);
					}
					
					gridContainer.appendChild(indicator);
				}
			}

            // Play notes that the playhead is currently crossing
			function playNotesAtPosition(position) {
				noteBlocks.forEach(block => {
					const blockLeft = parseInt(block.style.left);
					const blockWidth = parseInt(block.style.width);
					
					// Check if the playhead just crossed the start of this note block
					if (position >= blockLeft && position <= blockLeft + 5) {
						const noteData = block.dataset.note;
						if (noteData) {
							const note = noteData.slice(0, -1); // Remove the octave
							const octave = parseInt(noteData.slice(-1));
							const duration = (blockWidth / GRID_CELL_WIDTH) * (60 / parseInt(tempoInput.value));
							const isSustained = block.dataset.sustained === 'true';
							const instrument = block.dataset.instrument || 'sine';
							playNote(note, octave, duration, isSustained, instrument);
						}
					}
				});
			}

			// Track management functions
			function initTracks() {
				// Create default track if none exist
				if (!window.tracks) {
					window.tracks = [];
					const defaultTrack = {
						name: 'Track 1', 
						instrument: 'sine',
						blocks: [],
						isMuted: false,
						isSolo: false
					};
					window.tracks.push(defaultTrack);
					window.currentTrackIndex = 0;
				}
				
				updateTracksList();
			}

			function setupTracksPanel() {
				const trackToggle = document.getElementById('track-toggle');
				const tracksContainer = document.getElementById('tracks-container');
				
				if (!trackToggle || !tracksContainer) {
					console.error("Track panel elements not found");
					return;
				}
				
				trackToggle.addEventListener('click', function() {
					tracksContainer.classList.toggle('open');
					trackToggle.classList.toggle('open');
				});
			}

			function updateTracksList() {
				const tracksList = document.getElementById('tracks-list');
				if (!tracksList) return;
				
				tracksList.innerHTML = '';
				
				if (window.tracks && window.tracks.length) {
					window.tracks.forEach((track, index) => {
						const trackItem = document.createElement('div');
						trackItem.className = `track-item ${index === window.currentTrackIndex ? 'active' : ''}`;
						trackItem.textContent = track.name;
						tracksList.appendChild(trackItem);
					});
				}
			}

            // Play/Stop functionality
            playBtn.addEventListener('click', function() {
                initAudio();
                if (!isPlaying) {
                    isPlaying = true;
                    lastTimestamp = 0;
                    animationFrameId = requestAnimationFrame(animate);
                    playBtn.textContent = 'Pause';
                } else {
                    isPlaying = false;
                    cancelAnimationFrame(animationFrameId);
                    playBtn.textContent = 'Play';
                }
            });

            stopBtn.addEventListener('click', function() {
                isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                currentPosition = 0;
                playhead.style.left = '0px';
                playBtn.textContent = 'Play';
            });

            // Clear all note blocks
			clearBtn.addEventListener('click', clearAllNotes);

			// Connect the save button to the saveCurrentSession function
			document.getElementById('save-btn').addEventListener('click', saveCurrentSession);

			// Connect the new session button to the createNewSession function
			document.getElementById('new-session-btn').addEventListener('click', createNewSession);


            // Initialize the app
            createPianoKeys();
			initInstrumentSelectors();
			updateSessionsList();
			addGridControlButtons();
			updateGridSize();
			loadSavedSessions();
			initTracks();
			setupTracksPanel();
        });
    </script>
</body>
</html>