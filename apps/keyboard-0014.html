<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Keyboard Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #f0f0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

		.context-menu {
			background-color: #333;
			border: 1px solid #555;
			border-radius: 4px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
			z-index: 1000;
		}

		.context-menu div {
			padding: 8px 15px;
			cursor: pointer;
		}

		.context-menu div:hover {
			background-color: #444;
		}

        /* Toolbar styles */
        .toolbar {
            background-color: #2c2c2c;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #444;
        }

        .toolbar button {
            background-color: #3c3c3c;
            color: #f0f0f0;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .toolbar button:hover {
            background-color: #4c4c4c;
        }

		.instrument-control {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.instrument-control select {
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			padding: 8px;
			border-radius: 4px;
		}

		.instrument-toolbar {
			display: flex;
			background-color: #2c2c2c;
			padding: 8px;
			gap: 8px;
			border-bottom: 1px solid #444;
		}

		.instrument-selector {
			padding: 8px 12px;
			border-radius: 4px;
			cursor: pointer;
			color: white;
			font-weight: bold;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
			transition: all 0.2s ease;
			min-width: 80px;
			text-align: center;
		}

		.instrument-selector:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
		}

		.instrument-selector.active {
			outline: 2px solid white;
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
		}

        /* Left sidebar styles */
        .sidebar {
            width: 200px;
            background-color: #252525;
            padding: 10px;
            border-right: 1px solid #444;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 10px;
            color: #b0b0b0;
        }

        .session-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .session-item:hover {
            background-color: #444;
        }

		#sessions-list {
			max-height: 300px;
			overflow-y: auto;
		}

		.session-item {
			padding: 8px;
			margin: 5px;
			background-color: #333;
			border-radius: 4px;
			cursor: pointer;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.session-item:hover {
			background-color: #444;
		}

        /* Main sequencer area */
        .sequencer-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Piano keyboard styles */
        .piano-container {
            width: 80px;
            background-color: #222;
            overflow-y: auto;
            position: relative;
        }

        .piano-key {
            height: 30px;
            margin: 1px 0;
            display: flex;
            align-items: center;
            padding-left: 10px;
            position: relative;
            cursor: pointer;
        }

        .white-key {
            background-color: #f0f0f0;
            color: #222;
            border-radius: 0 4px 4px 0;
        }

        .black-key {
            background-color: #222;
            color: #f0f0f0;
            border-radius: 0 4px 4px 0;
            border: 1px solid #444;
        }

        .piano-key:hover {
            opacity: 0.8;
        }

		.sample-module {
			position: absolute;
			bottom: 50px;
			left: 50%;
			transform: translateX(-50%);
			width: 80%;
			max-width: 800px;
			background-color: #252525;
			border: 1px solid #444;
			border-radius: 8px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			z-index: 100;
		}
		
		.sample-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 10px 15px;
			background-color: #333;
			border-bottom: 1px solid #444;
			border-radius: 8px 8px 0 0;
		}
		
		.sample-header h3 {
			margin: 0;
			color: #f0f0f0;
		}
		
		#close-samples-btn {
			background: none;
			border: none;
			color: #f0f0f0;
			font-size: 24px;
			cursor: pointer;
		}
		
		.sample-controls {
			display: flex;
			justify-content: space-between;
			padding: 10px 15px;
			background-color: #2a2a2a;
			border-bottom: 1px solid #444;
		}
		
		.sample-category select,
		.effects-panel input[type="range"] {
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			padding: 5px;
			border-radius: 4px;
		}
		
		.effects-panel {
			display: flex;
			gap: 15px;
		}
		
		.effect-control {
			display: flex;
			align-items: center;
			gap: 5px;
		}
		
		.sample-pads {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 10px;
			padding: 15px;
			max-height: 300px;
			overflow-y: auto;
		}
		
		.sample-pad {
			aspect-ratio: 1/1;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: #3c3c3c;
			border-radius: 8px;
			color: #f0f0f0;
			font-weight: bold;
			cursor: pointer;
			user-select: none;
			transition: all 0.1s ease;
		}
		
		.sample-pad:hover {
			filter: brightness(1.2);
		}
		
		.sample-pad:active {
			transform: scale(0.95);
		}
		
		/* Different colors for different sample categories */
		.sample-pad.drums {
			background-color: #7986CB;
		}
		
		.sample-pad.fx {
			background-color: #4DB6AC;
		}
		
		.sample-pad.synth {
			background-color: #FFB74D;
		}
		
		.sample-pad.vocals {
			background-color: #F06292;
		}

        /* Grid area styles */
		.active-grid-area {
			position: absolute;
			top: 0;
			left: 0;
			height: 100%;
			background-color: transparent; /* Changed from #1a1a1a to transparent */
			z-index: 1;
			pointer-events: none;
		}

		.inactive-grid-area {
			position: absolute;
			top: 0;
			height: 100%;
			background-color: rgba(21, 21, 21, 0.7); /* Using rgba for opacity */
			z-index: 1;
			pointer-events: none;
		}

		/* Make sure these CSS styles for the grid container are applied: */
		.grid-container {
			flex: 1;
			overflow: auto;
			position: relative;
			background-color: #1a1a1a;
			background-image: 
				linear-gradient(to right, #333 1px, transparent 1px),
				linear-gradient(to bottom, #333 1px, transparent 1px);
			background-size: 40px 32px;
		}

		/* Grid control buttons */
		.grid-controls {
			position: absolute;
			right: 10px;
			top: 10px;
			display: flex;
			gap: 5px;
			z-index: 100;
		}

		.grid-control-btn {
			padding: 5px 10px;
			background-color: #3c3c3c;
			color: #f0f0f0;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}

		.grid-control-btn:hover {
			background-color: #4c4c4c;
		}

		.grid-end-marker {
			position: absolute;
			top: 0;
			height: 100%;
			width: 2px;
			background-color: #ffcc00;
			z-index: 5;
		}

		.beat-indicator {
			position: absolute;
			top: 0;
			width: 1px;
			pointer-events: none;
		}

		.beat-indicator.measure {
			height: 15px;
			background-color: #fff;
		}

		.beat-indicator.beat {
			height: 5px;
			background-color: #666;
		}

		.beat-label {
			position: absolute;
			left: 5px;
			top: 0;
			font-size: 10px;
			color: #fff;
		}

        /* Note block styles */
        .note-block {
            position: absolute;
            height: 28px;
            background-color: #5b87ff;
            border-radius: 4px;
            cursor: move;
            user-select: none;
            opacity: 0.8;
        }

        .note-block:hover {
            opacity: 1;
        }

        .note-block .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: e-resize;
        }

        /* Playhead styles */
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ff5b5b;
            z-index: 10;
            pointer-events: none;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="controls">
            <button id="play-btn">Play</button>
            <button id="stop-btn">Stop</button>
            <div class="tempo-control">
                <label for="tempo">BPM:</label>
                <input type="number" id="tempo" min="60" max="200" value="120" style="width: 60px;">
            </div>
			<div class="instrument-control">
				<label for="instrument">Instrument:</label>
				<select id="instrument">
					<option value="sine">Sine</option>
					<option value="square">Square</option>
					<option value="sawtooth">Sawtooth</option>
					<option value="triangle">Triangle</option>
					<option value="piano">Piano</option>
				</select>
			</div>
			<button id="toggle-samples-btn">Samples</button>			
        </div>
        <button id="save-btn">Save</button>
        <button id="new-session-btn">New Session</button>
        <button id="clear-btn">Clear All</button>
    </div>

	<div class="instrument-toolbar">
		<div class="instrument-selector active" data-instrument="sine" style="background-color: #5b87ff;">
			<span>Sine</span>
		</div>
		<div class="instrument-selector" data-instrument="square" style="background-color: #ff5b87;">
			<span>Square</span>
		</div>
		<div class="instrument-selector" data-instrument="sawtooth" style="background-color: #5bff87;">
			<span>Sawtooth</span>
		</div>
		<div class="instrument-selector" data-instrument="triangle" style="background-color: #ffb75b;">
			<span>Triangle</span>
		</div>
		<div class="instrument-selector" data-instrument="piano" style="background-color: #b75bff;">
			<span>Piano</span>
		</div>
	</div>

	<div class="tooltip" style="background-color: #333; padding: 8px; margin: 5px; border-radius: 4px; font-size: 12px;">
		<p>Tips: Click grid to add notes. Right-click to delete. Drag to move. Double-click to toggle sustained/staccato mode.</p>
	</div>

    <div class="app-container">
        <div class="sidebar">
            <h3>Sessions</h3>
            <div id="sessions-list">
                <div class="session-item">New Session</div>
            </div>
        </div>

        <div class="sequencer-container">
            <div class="piano-container" id="piano-keys">
                <!-- Piano keys will be generated here -->
            </div>

            <div class="grid-container" id="grid-container">
                <div class="playhead" id="playhead"></div>
                <!-- Note blocks will be added here -->
            </div>
        </div>
    </div>

	<button id="track-toggle" class="track-toggle">Tracks</button>
	<div id="tracks-container" class="tracks-container">
		<h3 style="padding: 10px; margin: 0; color: #b0b0b0;">Tracks</h3>
		<div id="tracks-list"></div>
		<button id="add-track-btn" style="margin: 10px; padding: 8px; background-color: #3c3c3c; color: #f0f0f0; border: none; border-radius: 4px; cursor: pointer; width: calc(100% - 20px);">Add New Track</button>
	</div>

	<button id="emergency-reset" style="position: fixed; bottom: 10px; right: 10px; background-color: #ff5b5b; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; z-index: 9999;">Emergency Reset</button>

	<div class="sample-module" style="display: none;">
		<div class="sample-header">
			<h3>Audio Samples</h3>
			<button id="close-samples-btn">×</button>
		</div>
		
		<div class="sample-controls">
			<div class="sample-category">
				<label>Category:</label>
				<select id="sample-category">
					<option value="drums">Drums</option>
					<option value="fx">FX</option>
					<option value="synth">Synth</option>
					<option value="vocals">Vocals</option>
				</select>
			</div>
			
			<div class="effects-panel">
				<div class="effect-control">
					<label>Reverb:</label>
					<input type="range" id="reverb-amount" min="0" max="100" value="30">
				</div>
				<div class="effect-control">
					<label>Delay:</label>
					<input type="range" id="delay-amount" min="0" max="100" value="0">
				</div>
			</div>
		</div>
		
		<div id="sample-pads" class="sample-pads">
			<!-- Sample pads will be added dynamically -->
		</div>
	</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Constants
            const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const OCTAVES = [5, 4, 3, 2]; // Starting from higher octaves for a more intuitive layout
            const NOTE_HEIGHT = 32; // Height of each note row
            const GRID_CELL_WIDTH = 40; // Width of each grid cell
            const MAX_GRID_WIDTH = 4000; // Maximum width of the grid
			const INITIAL_GRID_CELLS = 16; // Start with 16 cells (4 bars of 4 beats)
			
            // Elements
            const pianoContainer = document.getElementById('piano-keys');
            const gridContainer = document.getElementById('grid-container');
            const playhead = document.getElementById('playhead');
            const playBtn = document.getElementById('play-btn');
            const stopBtn = document.getElementById('stop-btn');
            const tempoInput = document.getElementById('tempo');
            const clearBtn = document.getElementById('clear-btn');

            // State
            let isPlaying = false;
            let currentPosition = 0;
            let animationFrameId = null;
            let noteBlocks = [];
            let activeDragBlock = null;
            let activeResizeBlock = null;
            let dragOffset = { x: 0, y: 0 };
            let audioContext = null;
            let lastTimestamp = 0;
			let maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
			
            // Initialize audio context on user interaction
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

			document.getElementById('emergency-reset').addEventListener('click', function() {
				if (confirm('This will delete ALL saved sessions and reset the app. Continue?')) {
					localStorage.removeItem('musicSequencerSessions');
					location.reload();
				}
			});

            // Create piano keys
            function createPianoKeys() {
                let noteIndex = 0;
                
                OCTAVES.forEach(octave => {
                    NOTES.forEach(note => {
                        const keyElement = document.createElement('div');
                        const isBlackKey = note.includes('#');
                        
                        keyElement.className = `piano-key ${isBlackKey ? 'black-key' : 'white-key'}`;
                        keyElement.dataset.note = `${note}${octave}`;
                        keyElement.dataset.index = noteIndex;
                        keyElement.innerHTML = `${note}${octave}`;
                        
                        keyElement.addEventListener('click', function() {
                            playNote(note, octave, 0.5);
                        });
                        
                        pianoContainer.appendChild(keyElement);
                        noteIndex++;
                    });
                });
            }

			function initSamplesModule() {
				// Sample data by category
				const sampleData = {
					drums: [
						{ name: 'Kick', url: 'https://cdn.freesound.org/previews/250/250547_4486188-lq.mp3', color: '#7986CB' },
						{ name: 'Snare', url: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3', color: '#7986CB' },
						{ name: 'Hi-Hat', url: 'https://cdn.freesound.org/previews/484/484344_10343397-lq.mp3', color: '#7986CB' },
						{ name: 'Clap', url: 'https://cdn.freesound.org/previews/240/240622_4486188-lq.mp3', color: '#7986CB' },
						{ name: 'Rim', url: 'https://cdn.freesound.org/previews/352/352651_6294958-lq.mp3', color: '#7986CB' },
						{ name: 'Tom', url: 'https://cdn.freesound.org/previews/238/238380_4486188-lq.mp3', color: '#7986CB' },
						{ name: 'Crash', url: 'https://cdn.freesound.org/previews/521/521295_11253523-lq.mp3', color: '#7986CB' },
						{ name: 'Ride', url: 'https://cdn.freesound.org/previews/446/446134_9158253-lq.mp3', color: '#7986CB' }
					],
					fx: [
						{ name: 'Whoosh', url: 'https://cdn.freesound.org/previews/197/197789_3633652-lq.mp3', color: '#4DB6AC' },
						{ name: 'Riser', url: 'https://cdn.freesound.org/previews/366/366878_6707413-lq.mp3', color: '#4DB6AC' },
						{ name: 'Drop', url: 'https://cdn.freesound.org/previews/253/253534_4201632-lq.mp3', color: '#4DB6AC' },
						{ name: 'Impact', url: 'https://cdn.freesound.org/previews/441/441538_8400812-lq.mp3', color: '#4DB6AC' }
					],
					synth: [
						{ name: 'Bass', url: 'https://cdn.freesound.org/previews/350/350895_1676145-lq.mp3', color: '#FFB74D' },
						{ name: 'Chord', url: 'https://cdn.freesound.org/previews/266/266268_5123851-lq.mp3', color: '#FFB74D' },
						{ name: 'Arp', url: 'https://cdn.freesound.org/previews/368/368748_6707413-lq.mp3', color: '#FFB74D' },
						{ name: 'Lead', url: 'https://cdn.freesound.org/previews/396/396990_7261251-lq.mp3', color: '#FFB74D' }
					],
					vocals: [
						{ name: 'Yeah', url: 'https://cdn.freesound.org/previews/384/384187_1748411-lq.mp3', color: '#F06292' },
						{ name: 'Hey', url: 'https://cdn.freesound.org/previews/244/244996_4563249-lq.mp3', color: '#F06292' },
						{ name: 'Go', url: 'https://cdn.freesound.org/previews/277/277559_5304243-lq.mp3', color: '#F06292' },
						{ name: 'Whoop', url: 'https://cdn.freesound.org/previews/412/412068_5121236-lq.mp3', color: '#F06292' }
					]
				};
				
				// Audio context and sample buffers
				let audioContext = null;
				const sampleBuffers = {};
				
				// Effect nodes
				let reverbNode = null;
				let delayNode = null;
				
				// DOM elements
				const toggleButton = document.getElementById('toggle-samples-btn');
				const sampleModule = document.querySelector('.sample-module');
				const closeButton = document.getElementById('close-samples-btn');
				const categorySelect = document.getElementById('sample-category');
				const samplePadsContainer = document.getElementById('sample-pads');
				const reverbAmount = document.getElementById('reverb-amount');
				const delayAmount = document.getElementById('delay-amount');
				
				// Initialize audio context on first user interaction
				function initAudio() {
					if (!audioContext) {
						audioContext = new (window.AudioContext || window.webkitAudioContext)();
						
						// Initialize effects
						initEffects();
					}
				}
				
				// Initialize audio effects
				function initEffects() {
					// Create reverb
					reverbNode = audioContext.createConvolver();
					createReverbImpulse(2.5).then(impulseBuffer => {
						reverbNode.buffer = impulseBuffer;
					});
					
					// Create delay
					delayNode = audioContext.createDelay(4.0);
					delayNode.delayTime.value = 0.3;
					
					const delayFeedback = audioContext.createGain();
					delayFeedback.gain.value = 0.4;
					
					delayNode.connect(delayFeedback);
					delayFeedback.connect(delayNode);
				}
				
				// Create reverb impulse response
				async function createReverbImpulse(duration = 2) {
					const sampleRate = audioContext.sampleRate;
					const length = sampleRate * duration;
					const impulse = audioContext.createBuffer(2, length, sampleRate);
					
					// Generate impulse
					for (let channel = 0; channel < 2; channel++) {
						const data = impulse.getChannelData(channel);
						for (let i = 0; i < length; i++) {
							data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, duration);
						}
					}
					
					return impulse;
				}
				
				// Load a sample
				async function loadSample(name, url) {
					try {
						const response = await fetch(url);
						const arrayBuffer = await response.arrayBuffer();
						const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
						sampleBuffers[name] = audioBuffer;
						console.log(`Loaded sample: ${name}`);
						return true;
					} catch (error) {
						console.error(`Error loading sample ${name}:`, error);
						return false;
					}
				}
				
				// Load samples for a category
				async function loadSamplesForCategory(category) {
					const samples = sampleData[category];
					if (!samples) return;
					
					for (const sample of samples) {
						if (!sampleBuffers[sample.name]) {
							await loadSample(sample.name, sample.url);
						}
					}
				}
				
				// Play a sample with effects
				function playSample(name) {
					if (!audioContext) initAudio();
					
					if (!sampleBuffers[name]) {
						console.warn(`Sample "${name}" not loaded`);
						return;
					}
					
					// Create source node
					const source = audioContext.createBufferSource();
					source.buffer = sampleBuffers[name];
					
					// Set up gain for main volume
					const gainNode = audioContext.createGain();
					gainNode.gain.value = 1.0;
					
					// Set up dry/wet for reverb
					const dryGain = audioContext.createGain();
					const wetReverbGain = audioContext.createGain();
					wetReverbGain.gain.value = parseInt(reverbAmount.value) / 100;
					dryGain.gain.value = 1 - wetReverbGain.gain.value;
					
					// Set up dry/wet for delay
					const wetDelayGain = audioContext.createGain();
					wetDelayGain.gain.value = parseInt(delayAmount.value) / 100;
					
					// Connect the nodes
					source.connect(dryGain);
					dryGain.connect(audioContext.destination);
					
					if (reverbNode && wetReverbGain.gain.value > 0) {
						source.connect(reverbNode);
						reverbNode.connect(wetReverbGain);
						wetReverbGain.connect(audioContext.destination);
					}
					
					if (delayNode && wetDelayGain.gain.value > 0) {
						source.connect(delayNode);
						delayNode.connect(wetDelayGain);
						wetDelayGain.connect(audioContext.destination);
					}
					
					// Start playback
					source.start();
				}
				
				// Create sample pads for current category
				function createSamplePads(category) {
					samplePadsContainer.innerHTML = '';
					
					const samples = sampleData[category];
					if (!samples) return;
					
					samples.forEach(sample => {
						const pad = document.createElement('div');
						pad.className = `sample-pad ${category}`;
						pad.textContent = sample.name;
						pad.style.backgroundColor = sample.color;
						
						pad.addEventListener('mousedown', () => {
							pad.style.transform = 'scale(0.95)';
							playSample(sample.name);
						});
						
						pad.addEventListener('mouseup', () => {
							pad.style.transform = 'scale(1)';
						});
						
						pad.addEventListener('mouseleave', () => {
							pad.style.transform = 'scale(1)';
						});
						
						samplePadsContainer.appendChild(pad);
					});
				}
				
				// Event listeners
				function setupEventListeners() {
					// Toggle samples module
					toggleButton.addEventListener('click', () => {
						sampleModule.style.display = sampleModule.style.display === 'none' ? 'block' : 'none';
						
						// Initialize audio if needed
						if (sampleModule.style.display === 'block') {
							initAudio();
							
							// Load and display current category
							const category = categorySelect.value;
							loadSamplesForCategory(category);
							createSamplePads(category);
						}
					});
					
					// Close button
					closeButton.addEventListener('click', () => {
						sampleModule.style.display = 'none';
					});
					
					// Category selection
					categorySelect.addEventListener('change', () => {
						const category = categorySelect.value;
						loadSamplesForCategory(category);
						createSamplePads(category);
					});
					
					// Hide the module initially
					sampleModule.style.display = 'none';
				}
				
				// Call this function to initialize everything
				function init() {
					setupEventListeners();
				}
				
				// Initialize the module
				init();
			}

			function setupSampleSystem() {
				// Initialize sample storage
				const sampleBuffers = {};
				const defaultSamples = [
					{ name: 'kick', url: 'https://cdn.freesound.org/previews/250/250547_4486188-lq.mp3' },
					{ name: 'snare', url: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3' },
					{ name: 'hihat', url: 'https://cdn.freesound.org/previews/484/484344_10343397-lq.mp3' },
					{ name: 'clap', url: 'https://cdn.freesound.org/previews/240/240622_4486188-lq.mp3' },
					{ name: 'crash', url: 'https://cdn.freesound.org/previews/521/521295_11253523-lq.mp3' }
				];
				
				// Load a sample into memory
				async function loadSample(name, url) {
					try {
						const response = await fetch(url);
						const arrayBuffer = await response.arrayBuffer();
						const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
						sampleBuffers[name] = audioBuffer;
						console.log(`Loaded sample: ${name}`);
						return true;
					} catch (error) {
						console.error(`Error loading sample ${name}:`, error);
						return false;
					}
				}
				
				// Load all default samples
				async function loadDefaultSamples() {
					for (const sample of defaultSamples) {
						await loadSample(sample.name, sample.url);
					}
				}
				
				// Play a sample with optional effects
				function playSample(name, time = 0, options = {}) {
					if (!sampleBuffers[name]) {
						console.warn(`Sample "${name}" not found`);
						return null;
					}
					
					// Create audio source from buffer
					const source = audioContext.createBufferSource();
					source.buffer = sampleBuffers[name];
					
					// Set up gain node for volume control
					const gainNode = audioContext.createGain();
					gainNode.gain.value = options.volume || 1.0;
					
					// Connect source to gain
					source.connect(gainNode);
					
					// Apply effects chain if available
					if (options.effects && Array.isArray(options.effects)) {
						let currentNode = gainNode;
						
						for (const effect of options.effects) {
							if (effect.node) {
								currentNode.connect(effect.node);
								currentNode = effect.node;
							}
						}
						
						currentNode.connect(audioContext.destination);
					} else {
						// Connect directly to output
						gainNode.connect(audioContext.destination);
					}
					
					// Start playback
					const startTime = audioContext.currentTime + (time || 0);
					source.start(startTime);
					
					return {
						source,
						gainNode
					};
				}
				
				// Create a basic reverb effect
				function createReverb(options = {}) {
					const convolver = audioContext.createConvolver();
					
					// Create impulse response for reverb
					const impulseLength = options.decay || 2;
					const sampleRate = audioContext.sampleRate;
					const impulse = audioContext.createBuffer(
						2, 
						impulseLength * sampleRate, 
						sampleRate
					);
					
					// Generate simple reverb impulse
					for (let channel = 0; channel < 2; channel++) {
						const impulseData = impulse.getChannelData(channel);
						for (let i = 0; i < impulse.length; i++) {
							impulseData[i] = (Math.random() * 2 - 1) * 
											 Math.pow(1 - i / impulse.length, impulseLength);
						}
					}
					
					convolver.buffer = impulse;
					
					// Create a gain node to control wet/dry mix
					const wetGain = audioContext.createGain();
					wetGain.gain.value = options.wet || 0.3;
					
					const dryGain = audioContext.createGain();
					dryGain.gain.value = options.dry || 0.7;
					
					// Create a merger node for the output
					const merger = audioContext.createGain();
					
					// Connect the nodes
					convolver.connect(wetGain);
					wetGain.connect(merger);
					dryGain.connect(merger);
					
					return {
						node: merger,
						input: (input) => {
							input.connect(convolver);
							input.connect(dryGain);
						}
					};
				}
				
				// Create a delay effect
				function createDelay(options = {}) {
					const delayNode = audioContext.createDelay();
					delayNode.delayTime.value = options.time || 0.3;
					
					const feedback = audioContext.createGain();
					feedback.gain.value = options.feedback || 0.4;
					
					const wetGain = audioContext.createGain();
					wetGain.gain.value = options.wet || 0.3;
					
					const dryGain = audioContext.createGain();
					dryGain.gain.value = options.dry || 0.7;
					
					const merger = audioContext.createGain();
					
					// Connect the nodes for delay with feedback
					delayNode.connect(feedback);
					feedback.connect(delayNode);
					delayNode.connect(wetGain);
					wetGain.connect(merger);
					dryGain.connect(merger);
					
					return {
						node: merger,
						input: (input) => {
							input.connect(delayNode);
							input.connect(dryGain);
						}
					};
				}
				
				// Initialize and return the API
				return {
					loadSample,
					loadDefaultSamples,
					playSample,
					createReverb,
					createDelay,
					getSampleList: () => Object.keys(sampleBuffers)
				};
			}

			// Create the UI for sample pads
			function createSamplePadsUI() {
				// Create container for sample pads
				const samplePadContainer = document.createElement('div');
				samplePadContainer.className = 'sample-pads-container';
				samplePadContainer.style.display = 'flex';
				samplePadContainer.style.flexWrap = 'wrap';
				samplePadContainer.style.gap = '10px';
				samplePadContainer.style.padding = '10px';
				samplePadContainer.style.backgroundColor = '#252525';
				samplePadContainer.style.borderTop = '1px solid #444';
				
				// Add heading
				const heading = document.createElement('h3');
				heading.textContent = 'Sample Pads';
				heading.style.width = '100%';
				heading.style.margin = '0 0 10px 0';
				heading.style.color = '#b0b0b0';
				samplePadContainer.appendChild(heading);
				
				// Get sample names from our system
				const sampleSystem = window.sampleSystem; // We'll create this later
				if (!sampleSystem) {
					console.warn('Sample system not initialized');
					return samplePadContainer;
				}
				
				const sampleNames = sampleSystem.getSampleList();
				
				// Color palette for pads
				const padColors = [
					'#7986CB', '#4DB6AC', '#FFB74D', '#F06292', 
					'#9575CD', '#4DD0E1', '#FFF176', '#BA68C8'
				];
				
				// Create a pad for each sample
				sampleNames.forEach((sampleName, index) => {
					const pad = document.createElement('div');
					pad.className = 'sample-pad';
					pad.textContent = sampleName;
					
					// Style the pad
					pad.style.width = '100px';
					pad.style.height = '100px';
					pad.style.backgroundColor = padColors[index % padColors.length];
					pad.style.borderRadius = '8px';
					pad.style.display = 'flex';
					pad.style.justifyContent = 'center';
					pad.style.alignItems = 'center';
					pad.style.fontWeight = 'bold';
					pad.style.color = 'white';
					pad.style.textTransform = 'uppercase';
					pad.style.cursor = 'pointer';
					pad.style.userSelect = 'none';
					pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					pad.style.transition = 'all 0.1s ease';
					
					// Add hover and active effects
					pad.addEventListener('mousedown', () => {
						pad.style.transform = 'scale(0.95)';
						pad.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
						
						// Play the sample
						sampleSystem.playSample(sampleName);
					});
					
					pad.addEventListener('mouseup', () => {
						pad.style.transform = 'scale(1)';
						pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					});
					
					pad.addEventListener('mouseleave', () => {
						pad.style.transform = 'scale(1)';
						pad.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
					});
					
					samplePadContainer.appendChild(pad);
				});
				
				return samplePadContainer;
			}

			// Initialize and connect the sample system
			function initSampleSystem() {
				// Make sure audio context is initialized
				if (!audioContext) {
					audioContext = new (window.AudioContext || window.webkitAudioContext)();
				}
				
				// Create sample system
				window.sampleSystem = setupSampleSystem();
				
				// Load default samples
				window.sampleSystem.loadDefaultSamples().then(() => {
					console.log('All default samples loaded');
					
					// Create and add the sample pads UI
					const samplePadsUI = createSamplePadsUI();
					document.body.appendChild(samplePadsUI);
				});
				
				// Create and add a button to toggle sample pad visibility
				const toggleButton = document.createElement('button');
				toggleButton.textContent = 'Sample Pads';
				toggleButton.className = 'toggle-samples-btn';
				toggleButton.style.position = 'fixed';
				toggleButton.style.bottom = '10px';
				toggleButton.style.left = '10px';
				toggleButton.style.backgroundColor = '#5b87ff';
				toggleButton.style.color = 'white';
				toggleButton.style.border = 'none';
				toggleButton.style.padding = '8px 12px';
				toggleButton.style.borderRadius = '4px';
				toggleButton.style.cursor = 'pointer';
				toggleButton.style.zIndex = '9999';
				
				toggleButton.addEventListener('click', () => {
					const container = document.querySelector('.sample-pads-container');
					if (container) {
						if (container.style.display === 'none') {
							container.style.display = 'flex';
						} else {
							container.style.display = 'none';
						}
					}
				});
				
				document.body.appendChild(toggleButton);
			}

            // Play a note
			function playNote(note, octave, duration, isSustained = false, instrumentType = 'sine') {
				initAudio();
				
				// Map note to frequency
				const noteFrequencies = {
					'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
					'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
				};
				
				// Calculate frequency based on octave
				const baseFreq = noteFrequencies[note];
				const octaveFactor = Math.pow(2, octave - 4); // Normalize to octave 4
				const frequency = baseFreq * octaveFactor;
				
				// Create oscillator
				const oscillator = audioContext.createOscillator();
				const gainNode = audioContext.createGain();
				
				// Set oscillator type based on instrument
				if (instrumentType === 'piano') {
					// Simple piano-like sound with multiple oscillators
					oscillator.type = 'triangle';
					
					// Add a second oscillator for harmonics
					const harmonicOsc = audioContext.createOscillator();
					harmonicOsc.type = 'sine';
					harmonicOsc.frequency.value = frequency * 2; // One octave higher
					
					const harmonicGain = audioContext.createGain();
					harmonicGain.gain.value = 0.2; // Lower volume for harmonic
					
					harmonicOsc.connect(harmonicGain);
					harmonicGain.connect(audioContext.destination);
					harmonicOsc.start();
					harmonicOsc.stop(audioContext.currentTime + duration);
				} else {
					oscillator.type = instrumentType; // 'sine', 'square', 'sawtooth', or 'triangle'
				}
				
				oscillator.frequency.value = frequency;
				
				// Apply envelope based on sustained or staccato
				if (isSustained) {
					// Sustained note with longer attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.05);
					gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + duration * 0.8);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
				} else {
					// Staccato note with quick attack and release
					gainNode.gain.setValueAtTime(0, audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.01);
					gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + duration * 0.3);
					gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + Math.min(0.3, duration));
				}
				
				oscillator.connect(gainNode);
				gainNode.connect(audioContext.destination);
				
				oscillator.start();
				oscillator.stop(audioContext.currentTime + duration);
			}

            // Create a new note block
			function createNoteBlock(x, y, width = GRID_CELL_WIDTH, noteIndex, isSustained = false, instrument = 'sine') {
				const noteBlock = document.createElement('div');
				noteBlock.className = 'note-block';
				noteBlock.style.left = `${x}px`;
				noteBlock.style.top = `${y}px`;
				noteBlock.style.width = `${width}px`;
				noteBlock.dataset.noteIndex = noteIndex;
				noteBlock.dataset.sustained = isSustained;
				noteBlock.dataset.instrument = instrument;
				
				// Set color based on instrument
				noteBlock.style.backgroundColor = instrumentColors[instrument];
				
				// Style differently based on sustained/staccato
				if (isSustained) {
					noteBlock.style.opacity = '0.9';
					noteBlock.style.borderRadius = '4px';
				} else {
					noteBlock.style.opacity = '0.7';
					noteBlock.style.borderRadius = '4px 0 0 4px';
					noteBlock.style.borderRight = '1px dashed white';
				}
				
				// Get note information from the key at this index
				const pianoKey = pianoContainer.children[noteIndex];
				const noteData = pianoKey.dataset.note;
				noteBlock.dataset.note = noteData;
				
				// Create resize handle
				const resizeHandle = document.createElement('div');
				resizeHandle.className = 'resize-handle';
				noteBlock.appendChild(resizeHandle);
				
				// Set up event listeners for dragging
				noteBlock.addEventListener('mousedown', startDragBlock);
				resizeHandle.addEventListener('mousedown', startResizeBlock);
				
				// Double-click to toggle sustained/staccato
				noteBlock.addEventListener('dblclick', function(e) {
					const isSustained = noteBlock.dataset.sustained === 'true';
					noteBlock.dataset.sustained = !isSustained;
					
					if (!isSustained) {
						noteBlock.style.opacity = '0.9';
						noteBlock.style.borderRadius = '4px';
						noteBlock.style.borderRight = 'none';
					} else {
						noteBlock.style.opacity = '0.7';
						noteBlock.style.borderRadius = '4px 0 0 4px';
						noteBlock.style.borderRight = '1px dashed white';
					}
				});
				
				gridContainer.appendChild(noteBlock);
				noteBlocks.push(noteBlock);
				
				return noteBlock;
			}

			gridContainer.addEventListener('contextmenu', function(e) {
				e.preventDefault(); // Prevent the default context menu
				const block = e.target.closest('.note-block');
				if (block) {
					const blockIndex = noteBlocks.indexOf(block);
					if (blockIndex > -1) {
						noteBlocks.splice(blockIndex, 1);
					}
					block.remove();
				}
			});

            // Handle start dragging a note block
            function startDragBlock(e) {
                e.stopPropagation();
                activeDragBlock = e.target.closest('.note-block');
                
                if (activeDragBlock) {
                    const rect = activeDragBlock.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    document.addEventListener('mousemove', dragBlock);
                    document.addEventListener('mouseup', stopDragBlock);
                }
            }

            // Handle dragging a note block
            function dragBlock(e) {
                if (!activeDragBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const x = e.clientX - gridRect.left - dragOffset.x;
                const y = e.clientY - gridRect.top - dragOffset.y;
                
                // Snap to grid
                const snappedX = Math.max(0, Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                const snappedY = Math.max(0, Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2);
                
                activeDragBlock.style.left = `${snappedX}px`;
                activeDragBlock.style.top = `${snappedY}px`;
                
                // Update note index based on new position
                const noteIndex = Math.floor(snappedY / NOTE_HEIGHT);
                if (noteIndex < pianoContainer.children.length) {
                    const pianoKey = pianoContainer.children[noteIndex];
                    activeDragBlock.dataset.noteIndex = noteIndex;
                    activeDragBlock.dataset.note = pianoKey.dataset.note;
                }
            }

            // Handle stop dragging a note block
            function stopDragBlock() {
                activeDragBlock = null;
                document.removeEventListener('mousemove', dragBlock);
                document.removeEventListener('mouseup', stopDragBlock);
            }

            // Handle start resizing a note block
            function startResizeBlock(e) {
                e.stopPropagation();
                activeResizeBlock = e.target.closest('.note-block');
                
                if (activeResizeBlock) {
                    document.addEventListener('mousemove', resizeBlock);
                    document.addEventListener('mouseup', stopResizeBlock);
                }
            }

            // Handle resizing a note block
            function resizeBlock(e) {
                if (!activeResizeBlock) return;
                
                const gridRect = gridContainer.getBoundingClientRect();
                const blockRect = activeResizeBlock.getBoundingClientRect();
                
                let width = e.clientX - blockRect.left;
                width = Math.max(GRID_CELL_WIDTH, Math.floor(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH);
                
                activeResizeBlock.style.width = `${width}px`;
            }

            // Handle stop resizing a note block
            function stopResizeBlock() {
                activeResizeBlock = null;
                document.removeEventListener('mousemove', resizeBlock);
                document.removeEventListener('mouseup', stopResizeBlock);
            }

			function saveCurrentSession() {
				const sessionName = prompt("Enter a name for your session:", "My Session");
				
				if (!sessionName) return; // User cancelled
				
				const sessionData = {
					name: sessionName,
					blocks: [],
					tempo: parseInt(tempoInput.value) || 120
				};
				
				// Save all note blocks
				const blocks = document.querySelectorAll('.note-block');
				blocks.forEach(block => {
					try {
						sessionData.blocks.push({
							x: parseInt(block.style.left) || 0,
							y: parseInt(block.style.top) || 0,
							width: parseInt(block.style.width) || GRID_CELL_WIDTH,
							noteIndex: parseInt(block.dataset.noteIndex) || 0,
							sustained: block.dataset.sustained === 'true',
							instrument: block.dataset.instrument || 'sine'
						});
					} catch (error) {
						console.error("Error saving block:", error);
					}
				});
				
				// Get existing sessions or initialize empty array
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Add new session
				sessions.push(sessionData);
				
				// Save to localStorage
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				console.log("Session saved:", sessionName, "with", sessionData.blocks.length, "blocks");
				
				// Update sessions list
				updateSessionsList();
			}

			function loadSession(sessionIndex) {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (sessionIndex >= sessions.length) return;
				
				const session = sessions[sessionIndex];
				
				// Clear current session
				clearAllNotes();
				
				// Set tempo
				tempoInput.value = session.tempo || 120;
				
				// IMPORTANT: Set maxGridWidth from saved session or use default
				maxGridWidth = session.maxGridWidth || (INITIAL_GRID_CELLS * GRID_CELL_WIDTH);
				updateGridSize();
				
				// Load all blocks
				if (session.blocks && Array.isArray(session.blocks)) {
					session.blocks.forEach(blockData => {
						try {
							const x = typeof blockData.x === 'number' ? blockData.x : 0;
							const y = typeof blockData.y === 'number' ? blockData.y : 0;
							const width = typeof blockData.width === 'number' ? blockData.width : GRID_CELL_WIDTH;
							const noteIndex = typeof blockData.noteIndex === 'number' ? blockData.noteIndex : 0;
							const sustained = blockData.sustained === true;
							const instrument = blockData.instrument || 'sine';
							
							createNoteBlock(x, y, width, noteIndex, sustained, instrument);
						} catch (error) {
							console.error("Error loading block:", error);
						}
					});
				}
			}

			function loadSavedSessions() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					sessionsList.appendChild(sessionItem);
				});
			}

			function updateSessionsList() {
				// Get sessions from localStorage
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				// Update the sessions list in the sidebar
				const sessionsList = document.getElementById('sessions-list');
				sessionsList.innerHTML = '';
				
				// Add each session to the list
				sessions.forEach((session, index) => {
					const sessionItem = document.createElement('div');
					sessionItem.className = 'session-item';
					sessionItem.innerHTML = session.name || `Session ${index + 1}`;
					
					// Add click event to load session
					sessionItem.addEventListener('click', function() {
						loadSession(index);
					});
					
					// Add right-click menu
					sessionItem.addEventListener('contextmenu', function(e) {
						e.preventDefault();
						
						// Remove any existing context menus
						const existingMenus = document.querySelectorAll('.context-menu');
						existingMenus.forEach(menu => menu.remove());
						
						// Create context menu
						const menu = document.createElement('div');
						menu.className = 'context-menu';
						menu.style.position = 'fixed'; // Use fixed instead of absolute
						menu.style.left = `${e.clientX}px`;
						menu.style.top = `${e.clientY}px`;
						menu.style.zIndex = '1000';
						
						// Add options
						const renameOption = document.createElement('div');
						renameOption.textContent = 'Rename';
						renameOption.addEventListener('click', function() {
							renameSession(index);
							menu.remove();
						});
						
						const deleteOption = document.createElement('div');
						deleteOption.textContent = 'Delete';
						deleteOption.addEventListener('click', function() {
							deleteSession(index);
							menu.remove();
						});
						
						menu.appendChild(renameOption);
						menu.appendChild(deleteOption);
						document.body.appendChild(menu);
						
						// Close menu when clicking outside
						setTimeout(() => {
							document.addEventListener('click', function closeMenu() {
								menu.remove();
								document.removeEventListener('click', closeMenu);
							}, { once: true });
						}, 0);
					});
					
					sessionsList.appendChild(sessionItem);
				});
				
				// Add "New Session" button
				const newSessionItem = document.createElement('div');
				newSessionItem.className = 'session-item new-session';
				newSessionItem.innerHTML = '+ New Session';
				newSessionItem.addEventListener('click', createNewSession);
				sessionsList.appendChild(newSessionItem);
			}

			// Add this function to your script
			function resetGrid() {
				// Clear all notes
				clearAllNotes();
				
				// Reset grid size to default
				maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
				
				// Update grid display
				updateGridSize();
				
				// Ensure grid container is visible and properly styled
				gridContainer.style.display = 'block';
				gridContainer.style.backgroundColor = '#1a1a1a';
				gridContainer.style.backgroundImage = 'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
				gridContainer.style.backgroundSize = '40px 32px';
				
				console.log("Grid reset complete");
			}

			// Function to rename a session
			function renameSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				const session = sessions[index];
				const newName = prompt("Enter a new name for the session:", session.name);
				
				if (!newName) return; // User cancelled
				
				session.name = newName;
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				updateSessionsList();
			}

			// Function to delete a session
			function deleteSession(index) {
				// Get sessions
				const sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				
				if (index >= sessions.length) return;
				
				if (!confirm("Are you sure you want to delete this session?")) return;
				
				sessions.splice(index, 1);
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				// If we've removed all sessions, create a blank state
				if (sessions.length === 0) {
					clearAllNotes();
				} else {
					// Load the first available session
					loadSession(0);
				}
				
				updateSessionsList();
			}

			function createNewSession() {
				// Clear all notes
				clearAllNotes();
				
				// IMPORTANT: Reset grid to default size
				maxGridWidth = INITIAL_GRID_CELLS * GRID_CELL_WIDTH;
				updateGridSize();
				
				// Prompt for a name
				const sessionName = prompt("Enter a name for your new session:", "New Session");
				if (!sessionName) return; // User cancelled
				
				// Create a blank session
				const sessionData = {
					name: sessionName,
					blocks: [],
					tempo: parseInt(tempoInput.value) || 120,
					maxGridWidth: maxGridWidth // Always save grid width
				};
				
				// Save session
				let sessions = JSON.parse(localStorage.getItem('musicSequencerSessions') || '[]');
				sessions.push(sessionData);
				localStorage.setItem('musicSequencerSessions', JSON.stringify(sessions));
				
				// Update UI
				updateSessionsList();
			}


			// Modified clear function to ensure grid is properly cleared
			function clearAllNotes() {
				// Remove all note blocks from the grid
				const blocks = document.querySelectorAll('.note-block');
				blocks.forEach(block => {
					block.remove();
				});
				
				// Reset noteBlocks array
				noteBlocks = [];
			}

			function initInstrumentSelectors() {
				const selectors = document.querySelectorAll('.instrument-selector');
				
				selectors.forEach(selector => {
					selector.addEventListener('click', function() {
						// Remove active class from all selectors
						selectors.forEach(s => s.classList.remove('active'));
						
						// Add active class to clicked selector
						selector.classList.add('active');
						
						// Set current instrument
						currentInstrument = selector.dataset.instrument;
					});
				});
			}

			// Replace the existing grid container click event with these new mouse event handlers
			let isDrawing = false;
			let drawStartX = 0;
			let drawStartY = 0;
			let currentDrawBlock = null;
			let currentInstrument = 'sine';
			let instrumentColors = {
				'sine': '#5b87ff',
				'square': '#ff5b87',
				'sawtooth': '#5bff87',
				'triangle': '#ffb75b',
				'piano': '#b75bff'
			};

			// Handle mousedown to start drawing
			gridContainer.addEventListener('mousedown', function(e) {
				// Don't create a block if we're clicking on an existing block
				if (e.target.closest('.note-block')) return;
				if (e.button !== 0) return; // Only respond to left-click
				
				isDrawing = true;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;
				
				// Snap to grid
				drawStartX = Math.floor(x / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				drawStartY = Math.floor(y / NOTE_HEIGHT) * NOTE_HEIGHT + 2;
				
				// Get note index based on y position
				const noteIndex = Math.floor(drawStartY / NOTE_HEIGHT);
				
				// Only create if within piano key range
				if (noteIndex < pianoContainer.children.length) {
					// Create initial block
					currentDrawBlock = createNoteBlock(drawStartX, drawStartY, GRID_CELL_WIDTH, noteIndex, true, currentInstrument);
				}
			});

			// Handle mousemove to extend the block
			gridContainer.addEventListener('mousemove', function(e) {
				if (!isDrawing || !currentDrawBlock) return;
				
				const rect = gridContainer.getBoundingClientRect();
				const x = e.clientX - rect.left;
				
				// Calculate width based on how far we've dragged
				let width = Math.max(GRID_CELL_WIDTH, x - drawStartX);
				width = Math.ceil(width / GRID_CELL_WIDTH) * GRID_CELL_WIDTH;
				
				// Update the block width
				currentDrawBlock.style.width = `${width}px`;
			});

			// Handle mouseup to finish drawing
			gridContainer.addEventListener('mouseup', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

			// Handle mouseleave to finish drawing if we leave the grid
			gridContainer.addEventListener('mouseleave', function(e) {
				isDrawing = false;
				currentDrawBlock = null;
			});

            // Animation function for playhead
            function animate(timestamp) {
                if (!lastTimestamp) lastTimestamp = timestamp;
                
                const deltaTime = timestamp - lastTimestamp;
                lastTimestamp = timestamp;
                
                const tempo = parseInt(tempoInput.value);
                const pixelsPerBeat = GRID_CELL_WIDTH;
                const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
                const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
                
                currentPosition += pixelsDelta;
                
                // Loop back to start if we reach the end of the grid
                if (currentPosition > MAX_GRID_WIDTH) {
                    currentPosition = 0;
                }
                
                playhead.style.left = `${currentPosition}px`;
                
                // Play notes at current position
                playNotesAtPosition(currentPosition);
                
                if (isPlaying) {
                    animationFrameId = requestAnimationFrame(animate);
                }
            }

			function addGridControlButtons() {
				// Create container for grid control buttons
				const controlsContainer = document.createElement('div');
				controlsContainer.className = 'grid-controls';
				
				// Add extend button
				const extendButton = document.createElement('button');
				extendButton.innerHTML = '+';
				extendButton.title = 'Add 4 more beats';
				extendButton.className = 'grid-control-btn';
				
				// Add shrink button
				const shrinkButton = document.createElement('button');
				shrinkButton.innerHTML = '-';
				shrinkButton.title = 'Remove 4 beats';
				shrinkButton.className = 'grid-control-btn';
				
				// Add event listeners that stop event propagation
				extendButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					maxGridWidth += 4 * GRID_CELL_WIDTH;
					updateGridSize();
				});
				
				shrinkButton.addEventListener('click', function(e) {
					e.stopPropagation(); // Stop event from bubbling up to the grid
					// Don't allow less than the initial size
					if (maxGridWidth > INITIAL_GRID_CELLS * GRID_CELL_WIDTH) {
						maxGridWidth -= 4 * GRID_CELL_WIDTH;
						updateGridSize();
					}
				});
				
				// Also prevent mousedown events from propagating
				extendButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				shrinkButton.addEventListener('mousedown', function(e) {
					e.stopPropagation();
				});
				
				// Add buttons to container
				controlsContainer.appendChild(shrinkButton);
				controlsContainer.appendChild(extendButton);
				
				// Add container to grid
				gridContainer.appendChild(controlsContainer);
			}

			// Update grid size and draw end marker
			function updateGridSize() {
				// Force grid container to have the correct styles
				gridContainer.style.backgroundImage = 'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
				gridContainer.style.backgroundSize = '40px 32px';
				gridContainer.style.backgroundColor = '#1a1a1a';
				
				// Clear all existing indicators and markers
				const existingElements = document.querySelectorAll('.beat-indicator, .grid-end-marker, .active-grid-area, .inactive-grid-area');
				existingElements.forEach(element => element.remove());
				
				// Important: We don't want to limit the active area on the left side
				// The active area should start at position 0 and extend to maxGridWidth
				
				// Create active grid area (always created fresh)
				const activeArea = document.createElement('div');
				activeArea.className = 'active-grid-area';
				activeArea.style.width = `${maxGridWidth}px`;
				activeArea.style.left = '0px'; // Ensure it starts at the left edge
				activeArea.style.zIndex = '1';
				
				// Create inactive grid area to the right of maxGridWidth
				const inactiveArea = document.createElement('div');
				inactiveArea.className = 'inactive-grid-area';
				inactiveArea.style.left = `${maxGridWidth}px`;
				inactiveArea.style.width = `${MAX_GRID_WIDTH - maxGridWidth}px`;
				inactiveArea.style.zIndex = '1';
				
				// Create end marker
				const endMarker = document.createElement('div');
				endMarker.id = 'grid-end-marker';
				endMarker.className = 'grid-end-marker';
				endMarker.style.left = `${maxGridWidth}px`;
				
				// Add elements to grid in the correct order
				gridContainer.appendChild(activeArea);
				gridContainer.appendChild(inactiveArea);
				gridContainer.appendChild(endMarker);
				
				// Add beat indicators
				addBeatIndicators();
			}

			// Update the animation function
			function animate(timestamp) {
				if (!lastTimestamp) lastTimestamp = timestamp;
				
				const deltaTime = timestamp - lastTimestamp;
				lastTimestamp = timestamp;
				
				const tempo = parseInt(tempoInput.value);
				const pixelsPerBeat = GRID_CELL_WIDTH;
				const pixelsPerSecond = (tempo / 60) * pixelsPerBeat;
				const pixelsDelta = (pixelsPerSecond * deltaTime) / 1000;
				
				currentPosition += pixelsDelta;
				
				// Loop back to start if we reach the max grid width
				if (currentPosition > maxGridWidth) {
					currentPosition = 0;
				}
				
				playhead.style.left = `${currentPosition}px`;
				
				// Play notes at current position
				playNotesAtPosition(currentPosition);
				
				if (isPlaying) {
					animationFrameId = requestAnimationFrame(animate);
				}
			}

			function addBeatIndicators() {
				// Remove existing indicators
				const existingIndicators = document.querySelectorAll('.beat-indicator');
				existingIndicators.forEach(indicator => indicator.remove());
				
				// Create beat numbers at the top
				for (let i = 0; i <= maxGridWidth / GRID_CELL_WIDTH; i++) {
					// Add a stronger indicator every 4 beats (one bar)
					const isMeasure = i % 4 === 0;
					
					const indicator = document.createElement('div');
					indicator.className = `beat-indicator ${isMeasure ? 'measure' : 'beat'}`;
					indicator.style.left = `${i * GRID_CELL_WIDTH}px`;
					
					if (isMeasure) {
						// Add measure number
						const label = document.createElement('div');
						label.innerHTML = Math.floor(i / 4) + 1;
						label.className = 'beat-label';
						indicator.appendChild(label);
					}
					
					gridContainer.appendChild(indicator);
				}
			}

            // Play notes that the playhead is currently crossing
			function playNotesAtPosition(position) {
				noteBlocks.forEach(block => {
					const blockLeft = parseInt(block.style.left);
					const blockWidth = parseInt(block.style.width);
					
					// Check if the playhead just crossed the start of this note block
					if (position >= blockLeft && position <= blockLeft + 5) {
						const noteData = block.dataset.note;
						if (noteData) {
							const note = noteData.slice(0, -1); // Remove the octave
							const octave = parseInt(noteData.slice(-1));
							const duration = (blockWidth / GRID_CELL_WIDTH) * (60 / parseInt(tempoInput.value));
							const isSustained = block.dataset.sustained === 'true';
							const instrument = block.dataset.instrument || 'sine';
							playNote(note, octave, duration, isSustained, instrument);
						}
					}
				});
			}

			// Track management functions
			function initTracks() {
				// Create default track if none exist
				if (!window.tracks) {
					window.tracks = [];
					const defaultTrack = {
						name: 'Track 1', 
						instrument: 'sine',
						blocks: [],
						isMuted: false,
						isSolo: false
					};
					window.tracks.push(defaultTrack);
					window.currentTrackIndex = 0;
				}
				
				updateTracksList();
			}

			function setupTracksPanel() {
				const trackToggle = document.getElementById('track-toggle');
				const tracksContainer = document.getElementById('tracks-container');
				
				if (!trackToggle || !tracksContainer) {
					console.error("Track panel elements not found");
					return;
				}
				
				trackToggle.addEventListener('click', function() {
					tracksContainer.classList.toggle('open');
					trackToggle.classList.toggle('open');
				});
			}

			function updateTracksList() {
				const tracksList = document.getElementById('tracks-list');
				if (!tracksList) return;
				
				tracksList.innerHTML = '';
				
				if (window.tracks && window.tracks.length) {
					window.tracks.forEach((track, index) => {
						const trackItem = document.createElement('div');
						trackItem.className = `track-item ${index === window.currentTrackIndex ? 'active' : ''}`;
						trackItem.textContent = track.name;
						tracksList.appendChild(trackItem);
					});
				}
			}

            // Play/Stop functionality
            playBtn.addEventListener('click', function() {
                initAudio();
                if (!isPlaying) {
                    isPlaying = true;
                    lastTimestamp = 0;
                    animationFrameId = requestAnimationFrame(animate);
                    playBtn.textContent = 'Pause';
                } else {
                    isPlaying = false;
                    cancelAnimationFrame(animationFrameId);
                    playBtn.textContent = 'Play';
                }
            });

            stopBtn.addEventListener('click', function() {
                isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                currentPosition = 0;
                playhead.style.left = '0px';
                playBtn.textContent = 'Play';
            });

            // Clear all note blocks
			clearBtn.addEventListener('click', clearAllNotes);

			// Connect the save button to the saveCurrentSession function
			document.getElementById('save-btn').addEventListener('click', saveCurrentSession);

			// Connect the new session button to the createNewSession function
			document.getElementById('new-session-btn').addEventListener('click', createNewSession);


            // Initialize the app
            createPianoKeys();
			initInstrumentSelectors();
			updateSessionsList();
			addGridControlButtons();
			updateGridSize();
			loadSavedSessions();
			initTracks();
			setupTracksPanel();
			initSampleSystem();
			initSamplesModule();
        });
    </script>
</body>
</html>