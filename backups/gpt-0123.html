<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <style>
		:root {
			--sidebar-width: 260px;
			--content-max-width: 768px;
			--header-height: 40px;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
			background: #343541;
			color: #ECECF1;
			height: 100vh;
			display: flex;
		}

		.mobile-header {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			height: 50px;
			background: #202123;
			padding: 0 1rem;
			z-index: 1001;
			display: none;
			align-items: center;
		}

		.mobile-menu-button {
			background: none;
			border: none;
			cursor: pointer;
			padding: 0.5rem;
			color: #ECECF1;
		}

		.mobile-menu-button svg {
			width: 24px;
			height: 24px;
		}

		.menu-toggle {
			background: none;
			border: none;
			color: #ECECF1;
			cursor: pointer;
			padding: 8px;
			display: flex;
		}

		.sidebar {
			width: var(--sidebar-width);
			background: #202123;
			height: 100vh;
			padding: 0.5rem;
			display: flex;
			flex-direction: column;
			overflow-y: auto;
			position: fixed;
			left: 0;
			top: 0;
			bottom: 0;
			z-index: 1000;
			transition: transform 0.3s ease; /* Add transition */
		}

		.sidebar.hide {
			transform: translateX(-100%); /* Sidebar hidden */
		}

		.instructions-button {
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			display: flex;
			align-items: center;
			gap: 0.75rem;
			cursor: pointer;
			margin-bottom: 1rem;
			color: #ECECF1;
			background: transparent;
			width: 100%;
			text-align: left;
		}

		.instructions-panel {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: #202123;
			padding: 2rem;
			border-radius: 0.5rem;
			width: 90%;
			max-width: 600px;
			max-height: 80vh;
			overflow-y: auto;
			z-index: 1002;
			display: none;
		}

		.instructions-panel.active {
			display: block;
		}

		.instructions-panel h2 {
			color: #ECECF1;
			margin-bottom: 1rem;
		}

		.instructions-panel textarea {
			width: 100%;
			min-height: 150px;
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			color: #ECECF1;
			margin-bottom: 1rem;
			font-family: inherit;
			resize: vertical;
		}

		.instructions-panel button {
			background: #565869;
			border: none;
			border-radius: 0.375rem;
			padding: 0.75rem 1rem;
			color: #ECECF1;
			cursor: pointer;
			margin-right: 0.5rem;
		}

		.instructions-panel button:hover {
			background: #666977;
		}

		.overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.5);
			display: none;
			z-index: 999;
		}

		.overlay.active {
			display: block;
		}

		.new-chat {
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem;
			display: flex;
			align-items: center;
			gap: 0.75rem;
			cursor: pointer;
			margin-bottom: 1rem;
			color: #ECECF1;
			background: transparent;
			width: 100%;
			text-align: left;
		}

		.chat-history {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.history-section {
			margin-bottom: 1rem;
			border-bottom: 1px solid rgba(86, 88, 105, 0.3);
			padding-bottom: 0.5rem;
		}

		.history-section h3 {
			color: #8e8ea0;
			font-size: 0.75rem;
			padding: 0.5rem 0.75rem;
			text-transform: uppercase;
			font-weight: 500;
		}

		.chat-item {
			padding: 0.75rem;
			border-radius: 0.375rem;
			cursor: pointer;
			color: #ececf1;
			font-size: 0.875rem;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			transition: background-color 0.2s;
		}

		.chat-item:hover, .chat-item.active {
			background: #2A2B32;
		}

		.main-content {
			margin-left: var(--sidebar-width);
			width: calc(100% - var(--sidebar-width));
			display: flex;
			flex-direction: column;
			height: 100vh;
			position: relative;
			transition: margin-left 0.3s ease, width 0.3s ease; /* Add transitions */
		}

		.main-content.full-width {
			margin-left: 0; /* No margin when sidebar is hidden */
			width: 100%;
		}

		.model-selector {
			position: absolute;
			top: 0.5rem;
			left: 1rem; /* Align with main content */
			z-index: 10;
			background: #343541;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.5rem;
			color: #ECECF1;
			width: 180px;
		}

		.model-selector option {
			width: auto;
			max-width: 300px;
		}

		.chat-container {
			flex: 1;
			width: 100%;
			margin: 3rem auto;
			padding: 0.75rem;
			max-width: calc(100% - 80px);
			overflow-y: auto;
			scrollbar-gutter: stable;
			scroll-behavior: smooth;
			padding-bottom: 20px; /* Ensures input bar does not obstruct */
		}

		.message {
			display: flex;
			padding: 1.5rem 2rem;
			gap: 1rem;
			border-bottom: 1px solid #2A2B32;
			margin: 0 auto;
			max-width: 800px;
		}

		.message.user {
			background: transparent;
			margin-left: auto;
			width: 90%;
			border-radius: 8px;
		}

		.message.assistant {
			background: #444654;
			position: relative;
			padding-left: 3.5rem;
		}

		.message.assistant::before {
			content: '';
			position: absolute;
			left: 1rem;
			top: 1.5rem;
			width: 30px;
			height: 30px;
			background-image: url('https://www.gravatar.com/avatar/00000000000000000000000000000000?d=mp&f=y');
			background-size: cover;
			border-radius: 50%;
		}

		.message.assistant:last-child {
			margin-bottom: 40px; /* Extra space for last response to stay visible */
		}

		.message + .message {
			margin-top: 1rem;
		}

		.message-content {
			flex: 1;
			overflow-x: auto;
		}

        .message-content pre {
            white-space: pre-wrap; /* Preserve whitespace in the pre element */
            overflow-x: auto; /* Allows horizontal scrolling if necessary */
            padding: 1rem; /* Optional padding */
            background: #2A2B32; /* Background color to match your theme */
            border-radius: 0.375rem; /* Round the corners */
            margin: 0.5rem 0; /* Space around the pre elements */
        }

		.message-content code {
			font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
			font-size: 0.875rem; /* Slightly smaller font for better readability */
			line-height: 1.5; /* Improve line spacing */
		}

		.message img {
			max-width: 512px;
			border-radius: 0.375rem;
			margin: 0.5rem 0;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
			display: block;
		}

		.message .loading {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 1rem;
			margin-top: 0.5rem;
		}

		.input-container {
			position: fixed;
			bottom: 0;
			left: var(--sidebar-width); /* Start after sidebar */
			right: 0;
			background: #343541;
			padding: 1rem;
			z-index: 1001;
			box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
		}

		.input-box {
			width: 100%;
			max-width: 800px;         /* Make narrower to match messages above */
			margin: 0 auto;           /* Keep centered */
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 1rem;
			padding: 8px;
			position: relative;
			display: flex;
			align-items: center;
		}

		.image-preview-container {
			position: absolute;
			bottom: 100%;
			left: 0;
			padding: 8px;
			display: flex;
			gap: 8px;
			max-width: 100%;
			overflow-x: auto;
			background: #40414F;
			border-radius: 8px 8px 0 0;
			margin-bottom: 4px;
		}

		.image-preview {
			position: relative;
			width: 60px;
			height: 60px;
			border-radius: 4px;
			overflow: hidden;
		}

		.image-preview img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.quick-actions {
			display: none;
			flex-wrap: wrap;
			gap: 0.5rem;
			padding: 0.5rem;
			justify-content: center;
		}

		.action-button {
			background: rgba(64, 65, 79, 0.7);
			border: 1px solid rgba(86, 88, 105, 0.7);
			color: #ececf1;
			padding: 8px 12px;
			border-radius: 6px;
			font-size: 0.875rem;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.action-button:hover {
			background: rgba(64, 65, 79, 0.9);
		}

		.model-selector-container {
			position: absolute;
			top: 0.5rem;
			left: 1rem;
			z-index: 10;
			display: flex;
			align-items: center;
			gap: 1rem;
		}

		.temp-chat-toggle {
			display: flex;
			align-items: center;
			color: #8e8ea0;
			font-size: 0.875rem;
			gap: 0.5rem;
			margin-top: 50px; 
			margin-left: 20px;
		}

		.toggle-switch {
			position: relative;
			display: inline-block;
			width: 36px;
			height: 20px;
		}

		.toggle-switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.toggle-slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #2a2b32;
			transition: .4s;
			border-radius: 34px;
		}

		.toggle-slider:before {
			position: absolute;
			content: "";
			height: 16px;
			width: 16px;
			left: 2px;
			bottom: 2px;
			background-color: #8e8ea0;
			transition: .4s;
			border-radius: 50%;
		}

		input:checked + .toggle-slider {
			background-color: #19c37d;
		}

		input:checked + .toggle-slider:before {
			transform: translateX(16px);
			background-color: white;
		}

		.remove-image {
			position: absolute;
			top: 2px;
			right: 2px;
			background: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 50%;
			width: 20px;
			height: 20px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			padding: 0;
		}

		.input-box textarea {
			white-space: pre-wrap;
			width: 100%;
			min-height: 48px;
			max-height: 200px;
			background: transparent;
			border: none;
			padding: 8px 40px 8px 8px;
			color: #ECECF1;
			resize: none;
			font-family: inherit;
			font-size: 1rem;
			line-height: 1.5;
			overflow: auto;
		}

		.input-box textarea:focus {
			outline: none;
		}

		.input-box button {
			position: absolute;
			bottom: 8px;  /* Match your padding */
			right: 12px;  /* Keep your existing right padding */
			background: none;
			border: none;
			color: #ECECF1;
			cursor: pointer;
			padding: 4px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.suggestions {
			display: flex;
			gap: 0.5rem;
			margin-top: 1rem;
			flex-wrap: wrap;
			justify-content: center;
		}

		.suggestion {
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 0.375rem;
			padding: 0.75rem 1rem;
			color: #ECECF1;
			cursor: pointer;
			font-size: 0.875rem;
		}

		.loading {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 2rem;
		}

		.loading::after {
			content: '';
			width: 24px;
			height: 24px;
			border: 3px solid #565869;
			border-top-color: #ECECF1;
			border-radius: 50%;
			animation: loading 0.6s linear infinite;
		}

		.initial-state {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			height: 100%;
			padding: 2rem;
		}

		.loading-image {
			padding: 1rem;
			background: #40414F;
			border-radius: 0.375rem;
			margin: 0.5rem 0;
			color: #ECECF1;
		}

		.centered-input {
			width: 100%;
			max-width: var(--content-max-width);
			text-align: center;
		}

		.centered-input textarea {
			width: 100%;
			max-width: 750px;
			min-height: 48px;
			background: #40414F;
			border: 1px solid #565869;
			border-radius: 1rem;
			padding: 12px 45px 12px 16px;
			color: #ECECF1;
			resize: none;
			font-family: inherit;
			font-size: 1rem;
			line-height: 1.5;
			margin-bottom: 1rem;
			box-shadow: 0 0 15px rgba(0,0,0,0.1);
		}

		.chat-state {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		@keyframes loading {
			to {
				transform: rotate(360deg);
			}
		}

		@media (max-width: 768px) {
			.sidebar {
				transform: translateX(-100%); /* Hide by default */
				width: 85%;
			}
			
			.sidebar.show {
				transform: translateX(0);
			}
			
			.main-content {
				margin-left: 0;
				width: 100%;
				padding-top: 50px; /* Space for mobile header */
			}
			
			.input-container {
				left: 0; /* Fix input container position */
				width: 100%;
				padding: 0.75rem;
			}
			
			.input-box {
				max-width: 100%; /* Allow full width on mobile */
			}
			
			.chat-container {
				max-width: 100%;
				padding: 0.75rem;
				margin: 0;
			}
			
			.message {
				padding: 1rem;
				max-width: 100%;
			}
			
			/* Adjust initial state for mobile */
			.initial-state {
				padding: 1rem;
			}
			
			.centered-input {
				width: 100%;
				padding: 0 1rem;
			}
			
			.centered-input textarea {
				width: 100%;
				max-width: none;
			}
		}
    </style>
</head>
<body>
	<div class="mobile-header">
		<button class="menu-button">
			<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="3" y1="12" x2="21" y2="12"></line>
				<line x1="3" y1="6" x2="21" y2="6"></line>
				<line x1="3" y1="18" x2="21" y2="18"></line>
			</svg>
		</button>
	</div>
    <div class="sidebar">
        <button class="new-chat">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
            New chat
        </button>
        <button class="instructions-button">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 20h9"></path>
                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
            </svg>
            Edit Instructions
        </button>
        <div class="chat-history">
            <div class="history-section">
                <h3>Today</h3>
                <div class="chat-item">First Chat</div>
            </div>
        </div>
    </div>
	
    <!-- Instructions Panel -->
    <div class="overlay"></div>
    <div class="instructions-panel">
        <h2>Custom Instructions</h2>
        <h3>User Profile</h3>
        <textarea id="user-profile" placeholder="Enter information about yourself that you'd like the AI to know..."></textarea>
        
        <h3>Response Preferences</h3>
        <textarea id="response-preferences" placeholder="Enter how you'd like the AI to respond..."></textarea>
        
        <div>
            <button id="save-instructions">Save</button>
            <button id="clear-instructions">Clear</button>
            <button id="close-instructions">Close</button>
        </div>
    </div>
	
	<div class="main-content">
		<div class="model-selector-container">
			<select class="model-selector" id="model-selector"></select>
			<div class="temp-chat-toggle">
				<span>Temporary chat</span>
				<label class="toggle-switch">
					<input type="checkbox" id="temp-chat-toggle">
					<span class="toggle-slider"></span>
				</label>
			</div>
		</div>

		<!-- Keep your existing initial-state div -->
		<div id="initial-state" class="initial-state">
			<div class="centered-input">
				<textarea placeholder="What can I help you with?" rows="1"></textarea>
				<div class="suggestions">
					<button class="suggestion">🎨 Create image</button>
					<button class="suggestion">🔍 Analyze code</button>
					<button class="suggestion">📚 Help me learn</button>
					<button class="suggestion">✍️ Write a story</button>
				</div>
			</div>
		</div>

		<!-- Chat state (hidden initially) -->
		<div id="chat-state" class="chat-state" style="display: none;">
			<div class="chat-container" id="chat-container"></div>
			<div class="input-container">
				<div class="input-box">					
					<textarea placeholder="Message ChatGPT..." rows="1" id="chatInput"></textarea>
					<button id="send-button">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<line x1="22" y1="2" x2="11" y2="13"></line>
							<polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
						</svg>
					</button>
				</div>
			</div>
		</div>
	</div>

    <script>
		class AIClient {
			constructor() {
				this.baseUrl = 'https://text.pollinations.ai';
				this.imageUrl = 'https://image.pollinations.ai';
				this.sessionMessages = [];
				this.modelTraits = new Map();
				this.userProfile = localStorage.getItem('userProfile') || '';
				this.responsePreferences = localStorage.getItem('responsePreferences') || '';
			}

			// Corrected method declaration
			splitLongMessage(content, maxLength = 1000) {
				if (content.length <= maxLength) return [content];
				const chunks = [];
				for (let i = 0; i < content.length; i += maxLength) {
					chunks.push(content.slice(i, i + maxLength));
				}
				return chunks;
			}

			// Rest of the AIClient class remains unchanged
			async fetchModels() {
				const response = await fetch(`${this.baseUrl}/models`);
				const models = await response.json();
				
				models.forEach(model => {
					this.modelTraits.set(model.name, {
						type: model.type,
						censored: model.censored,
						baseModel: model.baseModel,
						traits: {
							supportsStreaming: model.type === 'chat',
							needsContext: !model.baseModel,
							usesChatFormat: model.type === 'chat',
							usesCompletion: model.type === 'completion',
							requiresModeration: model.censored,
						}
					});
				});
				return models;
			}

			async sendMessage(model, content) {
				const modelTrait = this.modelTraits.get(model) || await this.getModelDefaults(model);
				const messages = this.prepareMessages(content, modelTrait);
				
				const response = await fetch(this.baseUrl, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						messages,
						model,
						stream: modelTrait.traits.supportsStreaming
					})
				});

				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

				this.sessionMessages.push({
					role: 'user',
					content,
					timestamp: Date.now()
				});

				return response;
			}
			
			async getImageFromClipboard(clipboardItems) {
				for (const item of clipboardItems) {
					// Check for image types in the clipboard
					for (const type of item.types) {
						if (type.startsWith('image/')) {
							const blob = await item.getType(type);
							return this.convertBlobToBase64(blob); // Convert blob to base64
						}
					}
				}
				return null; // No image found
			}

			async analyzeImage(imageBlob) {
				try {
					// Convert image to base64
					const base64Image = await this.convertBlobToBase64(imageBlob);
					
					const requestBody = {
						"messages": [
							{
								"role": "user",
								"content": [
									{ "type": "text", "text": "Describe the image exactly as you see it including any detected gender and fine details and visual styles used." },
									{ "type": "image_url", "image_url": { "url": `data:image/jpeg;base64,${base64Image}` } }
								]
							}
						],
						"model": "openai",
						"jsonMode": false
					};

					const response = await fetch(this.baseUrl, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(requestBody)
					});

					const result = await response.text();
					return result.trim();
				} catch (error) {
					console.error('Error analyzing image:', error);
					throw error;
				}
			}

			async convertBlobToBase64(blob) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onloadend = () => resolve(reader.result.split(',')[1]);
					reader.onerror = reject;
					reader.readAsDataURL(blob);
				});
			}

            setInstructions(profile, preferences) {
                this.userProfile = profile;
                this.responsePreferences = preferences;
                localStorage.setItem('userProfile', profile);
                localStorage.setItem('responsePreferences', preferences);
            }

            clearInstructions() {
                this.userProfile = '';
                this.responsePreferences = '';
                localStorage.removeItem('userProfile');
                localStorage.removeItem('responsePreferences');
            }

			prepareMessages(content, modelTrait) {
				let messages = [];

				// Add instructions if they exist (keeping original user bio/instructions handling)
				if (this.userProfile || this.responsePreferences) {
					messages.push({
						role: 'system',
						content: `# User Bio\n\nThe user provided the following information about themselves. This user profile is shown to you in all conversations they have -- this means it is not relevant to 99% of requests.\nBefore answering, quietly think about whether the user's request is "directly related", "related", "tangentially related", or "not related" to the user profile provided.\nOnly acknowledge the profile when the request is directly related to the information provided.\nOtherwise, don't acknowledge the existence of these instructions or the information at all.\nUser profile:\n${this.userProfile}\n\nUser's Instructions\nThe user provided the additional info about how they would like you to respond:\n${this.responsePreferences}`
					});
				}
				
				// Always add image generation ability context
				messages.push({
					role: 'system',
					content: 'Engage naturally in conversation. When visual content would enhance the conversation or when users express interest in seeing something, naturally include image descriptions in this format: IMAGE:[descriptive prompt]. For example, if someone mentions liking cats, you might say "Cats are wonderful! Let me show you one... IMAGE:[Adorable fluffy cat playing with yarn, soft lighting, detailed fur, hyperrealstic_style]"'
				});
				
				// Add message history WITHOUT adding extra User:/Assistant: prefixes
				const history = this.getFilteredHistory(modelTrait);
				messages = [...messages, ...history];

				// Add current message WITHOUT prefix
				messages.push({
					role: 'user',
					content: content
				});

				return messages;
			}

			getContextMessage() {
				return {
					role: 'context',
					content: 'Engage naturally in conversation. When visual content would enhance the conversation or when users express interest in seeing something, naturally include image descriptions in this format: IMAGE:[descriptive prompt]. For example, if someone mentions liking cats, you might say "Cats are wonderful! Let me show you one... IMAGE:[Adorable fluffy cat playing with yarn, soft lighting, detailed fur, hyperrealstic_style]"'
				};
			}

			getRecentContext() {
				const recentContext = this.sessionMessages
					.filter(msg => msg.role === 'assistant')
					.slice(-3)
					.map(msg => msg.content)
					.join('\n');
				
				return {
					role: 'context',
					content: `Recent conversation context:\n${recentContext}`
				};
			}

			getFilteredHistory(modelTrait) {
				return this.sessionMessages;
			}

			async getModelDefaults(model) {
				// Fallback traits if model fetch fails
				return {
					type: 'chat',
					censored: false,
					baseModel: true,
					traits: {
						supportsStreaming: true,
						needsContext: false,
						usesChatFormat: true,
						usesCompletion: false,
						requiresModeration: false
					}
				};
			}

			async generateImage(prompt) {
				const params = new URLSearchParams({
					nologo: 'true',
					private: 'true',
					enhance: 'false',
					seed: Math.floor(Math.random() * 1000000) // Random seed for each generation
				});
				
				const encodedPrompt = encodeURIComponent(prompt);
				const url = `${this.imageUrl}/prompt/${encodedPrompt}?${params.toString()}`;
				const response = await fetch(url);
				return response;
			}

			clearHistory() {
				this.sessionMessages = [];
			}
		}

		class ChatUI {
			constructor() {
				this.client = new AIClient();
				this.initialState = document.getElementById('initial-state');
				this.chatState = document.getElementById('chat-state');
				this.chatContainer = document.getElementById('chat-container');
				this.modelSelector = document.getElementById('model-selector');
				
				// Get both textareas
				this.initialTextarea = this.initialState.querySelector('textarea');
				this.chatTextarea = this.chatState.querySelector('textarea');
				
				this.sendButton = document.getElementById('send-button');
				
				// Add image preview support
				this.pendingImage = null;
				this.imagePreviewContainer = document.createElement('div');
				this.imagePreviewContainer.className = 'image-preview-container';
				this.imagePreviewContainer.style.display = 'none';
				
				// Add preview container to input box
				const inputBox = document.querySelector('.input-box');
				inputBox.insertBefore(this.imagePreviewContainer, inputBox.firstChild);

				// Clear initial textarea on startup
				this.initialTextarea.value = '';

				// Add temp chat toggle handling
				const tempChatToggle = document.getElementById('temp-chat-toggle');
				tempChatToggle.addEventListener('change', (e) => {
					// When temp chat is enabled, we won't save the session
					this.isTemporaryChat = e.target.checked;
				});

				// Menu button setup
				const menuButton = document.querySelector('.menu-button');
				const sidebar = document.querySelector('.sidebar');

				if (menuButton && sidebar) {
					menuButton.addEventListener('click', (e) => {
						e.preventDefault();
						e.stopPropagation();
						sidebar.classList.toggle('show');
					});

					document.addEventListener('click', (e) => {
						if (sidebar.classList.contains('show') && 
							!sidebar.contains(e.target) && 
							!menuButton.contains(e.target)) {
							sidebar.classList.remove('show');
						}
					});
				}

				// Initialize other functionality
				this.initializeEventListeners();
				this.loadModels();
				this.setupInstructionsPanel();
				
				// Initialize sessions
				this.sessions = new Map();
				const savedSessions = localStorage.getItem('chatSessions');
				if (savedSessions) {
					const sessionsData = JSON.parse(savedSessions);
					Object.entries(sessionsData).forEach(([id, session]) => {
						this.sessions.set(id, session);
						this.addSessionToHistory(id, session.title, false);
					});
				}
				
				if (savedSessions) {
					const sessionsData = JSON.parse(savedSessions);
					Object.entries(sessionsData).forEach(([id, session]) => {
						this.sessions.set(id, session);
						this.addSessionToHistory(id, session.title, false);
					});
					this.updateHistorySections(); // Add this line
				}
			}

			highlightCodeBlocks() {
				document.querySelectorAll('pre code').forEach((block) => {
					// First ensure the content is properly escaped
					const content = block.textContent;
					block.textContent = content; // This re-escapes the content
					hljs.highlightElement(block);
				});
			}

			updateHistorySections() {
				const chatHistory = document.querySelector('.chat-history');
				chatHistory.innerHTML = ''; // Clear existing sections
				
				// Recreate sections based on session dates
				this.sessions.forEach((session, sessionId) => {
					this.addSessionToHistory(sessionId, session.title, false);
				});
			}
	
            addImagePreview(blob) {
                const imageUrl = URL.createObjectURL(blob);
                this.pendingImage = blob;
                
                this.imagePreviewContainer.style.display = 'flex'; // Show container
                this.imagePreviewContainer.innerHTML = `
                    <div class="image-preview">
                        <img src="${imageUrl}" alt="Preview">
                        <button class="remove-image" title="Remove image">×</button>
                    </div>
                `;
                
                this.imagePreviewContainer.querySelector('.remove-image').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.removePendingImage();
                });
            }

            removePendingImage() {
                this.pendingImage = null;
                this.imagePreviewContainer.innerHTML = '';
                this.imagePreviewContainer.style.display = 'none'; // Hide container
            }

            setupInstructionsPanel() {
                const instructionsButton = document.querySelector('.instructions-button');
                const instructionsPanel = document.querySelector('.instructions-panel');
                const overlay = document.querySelector('.overlay');
                const saveButton = document.getElementById('save-instructions');
                const clearButton = document.getElementById('clear-instructions');
                const closeButton = document.getElementById('close-instructions');
                const userProfileText = document.getElementById('user-profile');
                const responsePrefsText = document.getElementById('response-preferences');

                // Load saved instructions
                userProfileText.value = this.client.userProfile;
                responsePrefsText.value = this.client.responsePreferences;

                instructionsButton.addEventListener('click', () => {
                    instructionsPanel.classList.add('active');
                    overlay.classList.add('active');
                });

                saveButton.addEventListener('click', () => {
                    this.client.setInstructions(userProfileText.value, responsePrefsText.value);
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });

                clearButton.addEventListener('click', () => {
                    this.client.clearInstructions();
                    userProfileText.value = '';
                    responsePrefsText.value = '';
                });

                closeButton.addEventListener('click', () => {
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });

                overlay.addEventListener('click', () => {
                    instructionsPanel.classList.remove('active');
                    overlay.classList.remove('active');
                });
            }

			async loadModels() {
				try {
					const models = await this.client.fetchModels();
					this.modelSelector.innerHTML = models
						.map(model => {
							// Create shortened display name
							const displayName = model.name.length > 15 ? 
								`${model.name.substring(0, 12)}...` : 
								model.name;
								
							// Use full description in the option title
							return `<option value="${model.name}" title="${model.description}">${displayName}</option>`;
						})
						.join('');
				} catch (error) {
					console.error('Error loading models:', error);
					this.addMessage('system', 'Error loading models. Please try again later.');
				}
			}

			initializeEventListeners() {
				// Initial state textarea
				this.initialTextarea.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
						e.preventDefault();
						this.switchToChat(this.initialTextarea.value);
					}
				});

				// Chat state textarea
				this.chatTextarea.addEventListener('input', () => {
					this.chatTextarea.style.height = 'auto';
					this.chatTextarea.style.height = Math.min(this.chatTextarea.scrollHeight, 200) + 'px';
				});

				this.chatTextarea.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
						e.preventDefault();
						this.sendMessage(this.chatTextarea.value);
					}
				});

				this.chatTextarea.addEventListener('paste', async (e) => {
					const items = (e.clipboardData || window.clipboardData).items;
					for (let index in items) {
						const item = items[index];
						if (item.kind === 'file' && item.type.startsWith('image/')) {
							e.preventDefault();
							const blob = item.getAsFile();
							if (blob) {
								this.addImagePreview(blob);
								break;
							}
						}
					}
				});
				
				// Send button
				this.sendButton.addEventListener('click', () => {
					console.log("Send button clicked!"); // Log for debugging
					this.sendMessage(this.chatTextarea.value.trim());
				});

				// Handle suggestion buttons
				document.querySelectorAll('.suggestion').forEach(btn => {
					btn.addEventListener('click', () => {
						this.switchToChat(btn.textContent);
					});
				});

				document.querySelector('.new-chat').addEventListener('click', () => {
					this.chatContainer.innerHTML = '';
					this.client.sessionMessages = [];
					this.removePendingImage();
					this.currentSessionId = null;
					this.showInitialState();
					
					// Clear active state from all sessions
					document.querySelectorAll('.chat-item').forEach(item => {
						item.classList.remove('active');
					});
				});
			}

			async sendMessage(content) {
                if (!content && !this.pendingImage) return;

                const model = this.modelSelector.value || 'openai';
                
                if (this.pendingImage) {
                    try {
                        const base64Image = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(this.pendingImage);
                        });

                        const messageContent = `
                            ${content ? `<p>${content}</p>` : ''}
                            <div>Analyzing image and preparing response...</div>
                        `;
                        this.addMessage('user', messageContent);
                        
                        // Store user message in session
						if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
							const session = this.sessions.get(this.currentSessionId);
							session.messages = [...this.client.sessionMessages]; // Save full history
							this.saveSessionsToStorage();
						}

                        const requestBody = {
                            "messages": [
                                {
                                    "role": "user",
                                    "content": [
                                        { 
                                            "type": "text", 
                                            "text": content ? 
                                                `Here is an image along with a question/comment: "${content}". First describe the image, then respond to the text.` :
                                                "Describe the image exactly as you see it including any detected gender as well as fine details and visual styles used."
                                        },
                                        { 
                                            "type": "image_url", 
                                            "image_url": { 
                                                "url": `data:image/jpeg;base64,${base64Image}` 
                                            } 
                                        }
                                    ]
                                }
                            ],
                            "model": model,
                            "jsonMode": false
                        };

                        const response = await fetch(this.client.baseUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });

                        const result = await response.text();
                        const aiResponse = result.trim();
                        
                        this.addMessage('assistant', aiResponse);
                        
                        // Store AI response in session
                        if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
                            const session = this.sessions.get(this.currentSessionId);
                            session.messages.push({
                                role: 'assistant',
                                content: aiResponse,
                                timestamp: Date.now()
                            });
                        }

                        if (content) {
                            this.client.sessionMessages.push({
                                role: 'user',
                                content: content,
                                timestamp: Date.now()
                            });
                        }
                        
                        this.client.sessionMessages.push({
                            role: 'system',
                            content: `An image was shown with the following question/comment: "${content}". Here is what I observed and my response: ${aiResponse}`,
                            timestamp: Date.now(),
                            imageContext: true
                        });
                        
                        this.client.sessionMessages.push({
                            role: 'assistant',
                            content: aiResponse,
                            timestamp: Date.now()
                        });

                        this.removePendingImage();
                        
                    } catch (error) {
                        console.error('Error processing image:', error);
                        this.addMessage('assistant', 'Sorry, I had trouble processing that image.');
                    }
				} else {
					// Text-only message
					this.addMessage('user', content);
					
					// Store user message in session
					if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
						const session = this.sessions.get(this.currentSessionId);
						session.messages.push({
							role: 'user',
							content: content,
							timestamp: Date.now()
						});
					}

					try {
						const response = await this.client.sendMessage(model, content);
						const reader = response.body.getReader();
						const decoder = new TextDecoder();
						
						let assistantMessage = document.createElement('div');
						assistantMessage.className = 'message assistant';
						assistantMessage.innerHTML = '<div class="message-content"></div>';
						this.chatContainer.appendChild(assistantMessage);
						
						let fullResponse = '';
						
						while (true) {
							const { done, value } = await reader.read();
							if (done) break;
							
							const chunk = decoder.decode(value);
							// Handle JSON response format
							const lines = chunk.split('\n');
							for (const line of lines) {
								if (line.startsWith('data: ')) {
									try {
										const jsonStr = line.slice(5); // Remove "data: " prefix
										if (jsonStr === '[DONE]') continue;
										
										const jsonData = JSON.parse(jsonStr);
										if (jsonData.choices?.[0]?.delta?.content) {
											fullResponse += jsonData.choices[0].delta.content;
										}
									} catch (e) {
										// If JSON parsing fails, treat as raw text
										const textContent = line.slice(5);
										if (textContent !== '[DONE]') {
											fullResponse += textContent;
										}
									}
								}
							}
							
							const messageContent = assistantMessage.querySelector('.message-content');
							messageContent.innerHTML = marked.parse(fullResponse);
							this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
							
							messageContent.querySelectorAll('pre code').forEach((block) => {
								hljs.highlightBlock(block);
							});
						}
						
						const imageMatch = fullResponse.match(/IMAGE:\[(.*?)\]/);
						if (imageMatch) {
							const imagePrompt = imageMatch[1];
							await this.handleImageGeneration(imagePrompt);
						}
						
						// Store AI response in session
						if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
							const session = this.sessions.get(this.currentSessionId);
							session.messages.push({
								role: 'assistant',
								content: fullResponse,
								timestamp: Date.now()
							});
							this.saveSessionsToStorage();
						}
						
						this.client.sessionMessages.push({ 
							role: 'assistant', 
							content: fullResponse
						});
					} catch (error) {
						console.error('Error:', error);
						this.addMessage('assistant', 'Sorry, there was an error processing your request.');
					}
				}
			}	
			
			async handleResponse(response, assistantMessage) {
				const reader = response.body.getReader();
				const decoder = new TextDecoder();
				let messageContent = assistantMessage.querySelector('.message-content');
				let fullResponse = '';

				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					
					const chunk = decoder.decode(value);
					
					// Check if the chunk is JSON format starting with "data: "
					const lines = chunk.split('\n');
					for (const line of lines) {
						if (line.startsWith('data: ')) {
							try {
								const jsonStr = line.slice(5); // Remove "data: " prefix
								if (jsonStr === '[DONE]') continue;
								
								const jsonData = JSON.parse(jsonStr);
								// Extract content from JSON structure if present
								if (jsonData.choices?.[0]?.delta?.content) {
									fullResponse += jsonData.choices[0].delta.content;
								} else {
									// Fallback to treating as raw text
									fullResponse += jsonStr;
								}
							} catch (e) {
								// If JSON parsing fails, treat as raw text
								const textContent = line.slice(5);
								if (textContent !== '[DONE]') {
									fullResponse += textContent;
								}
							}
						} else if (line.trim()) {
							// Handle raw text responses
							fullResponse += line;
						}
					}

					// Update UI with processed content
					messageContent.innerHTML = marked.parse(fullResponse);
					this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
					
					// Apply syntax highlighting
					messageContent.querySelectorAll('pre code').forEach((block) => {
						hljs.highlightBlock(block);
					});
				}

				return fullResponse;
			}

			switchToChat(initialMessage) {
				if (!initialMessage.trim()) return;
				
				// Switch display states
				this.initialState.style.display = 'none';
				this.chatState.style.display = 'flex';
				
				// Only create session if not temporary
				if (!this.isTemporaryChat) {
					// Create session ID and title
					const sessionId = Date.now().toString();
					const sessionTitle = this.createSessionTitle(initialMessage);
					
					// Clear the old 'First Chat' placeholder
					const firstChat = document.querySelector('.chat-item');
					if (firstChat && firstChat.textContent === 'First Chat') {
						firstChat.remove();
					}
					
					// Add to session history
					this.addSessionToHistory(sessionId, sessionTitle);
					this.switchToSession(sessionId);
				}
				
				// Add the message to UI immediately
				this.addMessage('user', initialMessage);

				// Send to AI and get response
				const model = this.modelSelector.value || 'openai';
				this.client.sendMessage(model, initialMessage).then(response => {
					const reader = response.body.getReader();
					const decoder = new TextDecoder();
					
					let assistantMessage = document.createElement('div');
					assistantMessage.className = 'message assistant';
					assistantMessage.innerHTML = '<div class="message-content"></div>';
					this.chatContainer.appendChild(assistantMessage);
					
					const readChunk = async () => {
						const { done, value } = await reader.read();
						if (done) return;
						
						const chunk = decoder.decode(value);
						const messageContent = assistantMessage.querySelector('.message-content');
						messageContent.innerHTML = marked.parse(chunk);
						this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
						
						messageContent.querySelectorAll('pre code').forEach((block) => {
							hljs.highlightBlock(block);
						});
						
						return readChunk();
					};
					
					readChunk().catch(error => {
						console.error('Error reading response:', error);
						this.addMessage('assistant', 'Sorry, there was an error processing your request.');
					});
				}).catch(error => {
					console.error('Error sending message:', error);
					this.addMessage('assistant', 'Sorry, there was an error processing your request.');
				});
			}

			showInitialState() {
				this.initialState.style.display = 'flex';
				this.chatState.style.display = 'none';
				this.initialTextarea.value = ''; // Clear main chat textarea
				this.chatTextarea.value = '';    // Clear initial textarea too
				this.currentSessionId = null;
			}

			
			async handleTextGeneration(model, content) {
				const response = await this.client.sendMessage(model, content);
				const reader = response.body.getReader();
				const decoder = new TextDecoder();
				
				let assistantMessage = document.createElement('div');
				assistantMessage.className = 'message assistant';
				assistantMessage.innerHTML = '<div class="message-content"></div>';
				this.chatContainer.appendChild(assistantMessage);
				
				let fullResponse = '';
				
				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					
					const chunk = decoder.decode(value);
					fullResponse += chunk;
					
					// Process any image tags in the response
					const messageContent = assistantMessage.querySelector('.message-content');
					let processedResponse = fullResponse;
					
					// Find all IMAGE:[...] patterns
					const imageMatches = processedResponse.match(/IMAGE:\[(.*?)\]/g);
					if (imageMatches) {
						for (const match of imageMatches) {
							const imagePrompt = match.match(/IMAGE:\[(.*?)\]/)[1];
							processedResponse = processedResponse.replace(
								match,
								'<div class="loading-image">Generating image...</div>'
							);
							
							try {
								const imageResponse = await this.client.generateImage(imagePrompt);
								const imageBlob = await imageResponse.blob();
								
								// Convert blob to base64 string
								const base64Image = await new Promise((resolve) => {
									const reader = new FileReader();
									reader.onloadend = () => resolve(reader.result);
									reader.readAsDataURL(imageBlob);
								});
								
								// Update the display and save to session
								processedResponse = processedResponse.replace(
									'<div class="loading-image">Generating image...</div>',
									`<img src="${base64Image}" alt="Generated image" style="max-width: 512px;">`
								);
								
								if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
									const session = this.sessions.get(this.currentSessionId);
									session.messages[session.messages.length - 1].content = processedResponse;
									this.saveSessionsToStorage();
								}
							} catch (error) {
								// Replace the loading indicator with an error message
								processedResponse = processedResponse.replace(
									'<div class="loading-image">Generating image...</div>',
									'<div class="error">Failed to generate image</div>'
								);
							}
						}
					}
					
					messageContent.innerHTML = marked.parse(processedResponse);
					this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
					
					messageContent.querySelectorAll('pre code').forEach((block) => {
						hljs.highlightBlock(block);
					});
				}
				
				// When storing the message, add clear separation
				this.client.sessionMessages.push({
					role: 'user',
					content: content,
					timestamp: Date.now()
				});

				let assistantResponse = '';
				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					
					const chunk = decoder.decode(value);
					assistantResponse += chunk;
					// ... update UI code ...
				}
				
				// Store the complete assistant response
				this.client.sessionMessages.push({
					role: 'assistant',
					content: assistantResponse,
					timestamp: Date.now(),
					isComplete: true  // Mark as complete message
				});
				
				if (this.currentSessionId && this.sessions.has(this.currentSessionId)) {
					const session = this.sessions.get(this.currentSessionId);
					session.messages = this.client.sessionMessages;
					this.saveSessionsToStorage();
				}
			}

			createSessionTitle(firstMessage) {
				let title = firstMessage.split('\n')[0];
				title = title.length > 30 ? title.substring(0, 30) + '...' : title;
				return title;
			}

			addSessionToHistory(sessionId, title, shouldSave = true) {
				const chatHistory = document.querySelector('.chat-history');
				const todaySection = this.getOrCreateHistorySection('Today', chatHistory);
				
				// Remove "First Chat" if it exists and there are sessions
				const firstChatItems = todaySection.querySelectorAll('.chat-item');
				firstChatItems.forEach(item => {
					if (item.textContent === 'First Chat' && this.sessions.size > 0) {
						item.remove();
					}
				});
				
				// If no sessions exist, ensure "First Chat" is shown
				if (this.sessions.size === 0) {
					const firstChat = document.createElement('div');
					firstChat.className = 'chat-item';
					firstChat.textContent = 'First Chat';
					todaySection.appendChild(firstChat);
				}
				
				const sessionElement = document.createElement('div');
				sessionElement.className = 'chat-item';
				sessionElement.dataset.sessionId = sessionId;
				sessionElement.textContent = title;
				
				// Store session data
				if (!this.sessions.has(sessionId)) {
					this.sessions.set(sessionId, {
						title: title,
						messages: [],
						created: Date.now()
					});
				}
				
				if (shouldSave) {
					this.saveSessionsToStorage();
				}
				
				sessionElement.addEventListener('click', () => {
					this.switchToSession(sessionId);
				});

				// Insert new session at the top, after the h3
				const h3Element = todaySection.querySelector('h3');
				if (h3Element && h3Element.nextSibling) {
					todaySection.insertBefore(sessionElement, h3Element.nextSibling);
				} else {
					todaySection.appendChild(sessionElement);
				}
			}

            // Add this new method
            saveSessionsToStorage() {
                const sessionsData = {};
                this.sessions.forEach((session, id) => {
                    sessionsData[id] = session;
                });
                localStorage.setItem('chatSessions', JSON.stringify(sessionsData));
            }

			getOrCreateHistorySection(title, chatHistory) {
				const now = new Date();
				const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
				const yesterday = new Date(today);
				yesterday.setDate(yesterday.getDate() - 1);
				
				const sections = {
					'Today': (date) => date >= today,
					'Yesterday': (date) => date >= yesterday && date < today,
					'Previous 7 Days': (date) => {
						const sevenDays = new Date(today);
						sevenDays.setDate(today.getDate() - 7);
						return date >= sevenDays && date < yesterday;
					},
					'Previous 30 Days': (date) => {
						const thirtyDays = new Date(today);
						thirtyDays.setDate(today.getDate() - 30);
						return date >= thirtyDays;
					}
				};
				
				// Get session date
				const sessionDate = new Date(this.sessions.get(title)?.created || Date.now());
				
				// Determine which section this session belongs in
				let sectionTitle = 'Today';
				for (const [name, checker] of Object.entries(sections)) {
					if (checker(sessionDate)) {
						sectionTitle = name;
						break;
					}
				}
				
				let section = chatHistory.querySelector(`[data-section="${sectionTitle}"]`);
				
				if (!section) {
					section = document.createElement('div');
					section.className = 'history-section';
					section.dataset.section = sectionTitle;
					
					const heading = document.createElement('h3');
					heading.textContent = sectionTitle;
					
					section.appendChild(heading);
					chatHistory.insertBefore(section, chatHistory.firstChild);
				}
				
				return section;
			}

			switchToSession(sessionId) {
				// Clear active state from all sessions
				document.querySelectorAll('.chat-item').forEach(item => {
					item.classList.remove('active');
					if (item.dataset.sessionId === sessionId) {
						item.classList.add('active');
					}
				});

				// Get session data
				const session = this.sessions.get(sessionId);
				if (session && session.messages) {
					// Switch to chat view if not already there
					this.initialState.style.display = 'none';
					this.chatState.style.display = 'flex';

					// Clear current chat container
					this.chatContainer.innerHTML = '';

					// Set this as the current session
					this.currentSessionId = sessionId;

					// Load each message into the chat
					session.messages.forEach(msg => {
						const messageDiv = document.createElement('div');
						messageDiv.className = `message ${msg.role}`;
						// Use our improved addMessage method instead of direct innerHTML
						this.addMessage(msg.role, msg.content);
					});

					// Scroll to bottom
					this.chatContainer.scrollTop = this.chatContainer.scrollHeight;

					// Reset client session messages to match current session
					this.client.sessionMessages = [...session.messages];
				}
			}

			async handleImageGeneration(prompt) {
				const loadingMessage = this.addMessage('assistant', '<div class="loading"></div>');
				try {
					const response = await this.client.generateImage(prompt);
					if (!response.ok) throw new Error('Failed to generate image');
					
					const imageBlob = await response.blob();
					const imageUrl = URL.createObjectURL(imageBlob);
					
					loadingMessage.querySelector('.message-content').innerHTML = `
						<div>
							<img src="${imageUrl}" alt="Generated image" style="max-width: 100%; height: auto;">
						</div>
					`;
					
					this.client.sessionMessages.push({
						role: 'assistant',
						content: 'Here is the generated image based on your request.'
					});
				} catch (error) {
					console.error('Error generating image:', error);
					loadingMessage.querySelector('.message-content').textContent = 
						'Sorry, there was an error generating the image. Please try again.';
					
					this.client.sessionMessages.push({
						role: 'assistant',
						content: 'Error generating image.'
					});
				}
			}

			escapeHtml(unsafe) {
				return unsafe
					.replace(/&/g, "&amp;")
					.replace(/</g, "&lt;")
					.replace(/>/g, "&gt;")
					.replace(/"/g, "&quot;")
					.replace(/'/g, "&#039;");
			}

			addMessage(role, content) {
				const message = document.createElement('div');
				message.className = `message ${role}`;
				
				const messageContent = document.createElement('div');
				messageContent.className = 'message-content';
				
				// Safely handle code blocks
				if (content.includes('```')) {
					const parts = content.split(/(```[\s\S]*?```)/g);
					parts.forEach(part => {
						if (part.startsWith('```')) {
							// Extract language if specified
							const match = part.match(/```(\w+)?\n([\s\S]*?)```/);
							if (match) {
								const [_, lang, code] = match;
								const pre = document.createElement('pre');
								const codeEl = document.createElement('code');
								if (lang) {
									codeEl.className = `language-${lang}`;
								}
								// Properly escape the code
								codeEl.textContent = code.trim();
								pre.appendChild(codeEl);
								messageContent.appendChild(pre);
							}
						} else if (part.trim()) {
							// Regular text content
							const textNode = document.createElement('div');
							textNode.innerHTML = marked.parse(part);
							messageContent.appendChild(textNode);
						}
					});
				} else {
					// Regular message without code blocks
					messageContent.innerHTML = marked.parse(content);
				}
				
				message.appendChild(messageContent);
				this.chatContainer.appendChild(message);
				
				// Apply syntax highlighting to all code blocks
				message.querySelectorAll('pre code').forEach((block) => {
					hljs.highlightElement(block);
				});
				
				this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
				return message;
			}
		}

        // Initialize the chat interface
        const chat = new ChatUI();
    </script>
</body>
</html>