<html><head><base href="https://flowa.ai/ecosystem"><title>Advanced Cellular Ecosystem Simulation</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    font-family: 'Roboto', Arial, sans-serif;
  }
  #ecosystem {
    width: min(60vh, 100%);
    height: min(60vh, 100%);
    position: relative;
    margin: 20px auto;
    overflow: hidden;
    background: rgb(0, 10, 30);
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.2);
  }
  #stats-panel {
    width: min(60vh, 100%);
    margin: 10px auto;
    padding: 10px;
    background: rgba(0, 10, 30, 0.8);
    border-radius: 8px;
    color: #fff;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 10px;
  }
  .stat-item {
    text-align: center;
  }
  h3, h4 {
    font-size: 14px; 
    margin-top: 0;
    margin-bottom: 15px;
    font-weight: 300;
    letter-spacing: 1px;
  }
  p {
    margin: 8px 0;
    line-height: 1.4;
  }
</style>
</head>
<body>
<script src="js/nav-loader.js"></script>
<div id="ecosystem"></div>
<div id="stats-panel">
    <div class="stat-item">
        <h3>Organisms</h3>
        <p id="organism-count">0</p>
    </div>
    <div class="stat-item">
        <h3>Food</h3>
        <p id="food-count">0</p>
    </div>
    <div class="stat-item">
        <h3>Waste</h3>
        <p id="waste-count">0</p>
    </div>
    <div class="stat-item">
        <h3>Dead Cells</h3>
        <p id="dead-cell-count">0</p>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
<script>
function limitNumber(num) {
  if (!isFinite(num) || isNaN(num)) return 0;
  return Math.min(Math.max(num, -1e10), 1e10);
}

const MAX_DISTANCE_FROM_BRAIN = 150;
let isPaused = false;
let isDragging = false;
let dragStartX, dragStartY;
let followedCell = null;
let camera = {x: 0, y: 0, zoom: 1};

function generatePastelColor() {
  const baseHue = random([210, 240, 270]); 
  const saturation = random(30, 60);
  const lightness = random(60, 80);
  const c = color(`hsl(${baseHue}, ${saturation}%, ${lightness}%)`);
  return {
    color: c,
    r: red(c),
    g: green(c),
    b: blue(c)
  };
}

class Waste {
  constructor(x, y) {
    this.x = limitNumber(x);
    this.y = limitNumber(y);
    this.size = 4;
    this.lifespan = 420; 
    this.alpha = 255;
  }

  update() {
    this.lifespan--;
    this.alpha = map(this.lifespan, 420, 0, 255, 0);
  }

  display() {
    noStroke();
    for (let i = 3; i > 0; i--) {
      fill(255, 255, 0, (this.alpha / i) / 3);
      ellipse(this.x, this.y, this.size + i * 4);
    }
    fill(255, 255, 0, this.alpha);
    ellipse(this.x, this.y, this.size);
  }
}

class Cell {
  constructor(x, y, type, parentOrganism) {
    this.x = limitNumber(x);
    this.y = limitNumber(y);
    this.type = type;
    this.sizeMultiplier = parentOrganism.sizeMultiplier || random(0.8, 1.2);
    this.size = this.getCellSize(type) * this.sizeMultiplier;
    this.energy = limitNumber(100);
    this.lifespan = 0;
    this.specializedAttributes = this.getSpecializedAttributes();
    this.brain = {
      moveSpeed: limitNumber(random(0.5, 1.5)),
      eatThreshold: limitNumber(random(30, 50)),
      stickiness: limitNumber(random(0.3, 0.7)),
      foodDetectionRange: limitNumber(random(50, 100)),
      energyTransferRate: limitNumber(random(0.1, 0.3)),
      adaptability: limitNumber(random(0.1, 0.5)),
      decisionSpeed: limitNumber(random(0.5, 1.5)),
      memoryCapacity: limitNumber(random(5, 15)),
      riskTolerance: limitNumber(random(0.2, 0.8)),
      learningRate: limitNumber(random(0.01, 0.1))
    };
    this.connections = [];
    this.mutationRate = random(0.005, 0.015);
    this.specializedMutationRate = random(0.01, 0.02);
    this.connectionMutationRate = random(0.008, 0.012);
    this.color = this.getColor();
    this.foodConsumed = 0; 
    this.signals = {
      foodDetected: false,
      energyLow: false,
      threatDetected: false,
      objectsDetected: false
    };
    this.role = this.getRole();
    this.maxConnectionDistance = 60;
    this.parentOrganism = parentOrganism;
  }

  getCellSize(type) {
    const sizes = {
      'brain': 30,
      'mouth': 25,
      'stomach': 28,
      'energy': 22,
      'protection': 26,
      'weapon': 24,
      'vision': 18,
      'touch': 16,
      'movement': 20,
      'repair': 18,
      'skin': 22
    };
    return sizes[type] || 20;
  }

  getSpecializedAttributes() {
    switch(this.type) {
      case 'vision':
        return { detectionRange: limitNumber(random(100, 200)) };
      case 'energy':
        return { transferRate: limitNumber(random(0.2, 0.5)) };
      case 'movement':
        return { speedBoost: limitNumber(random(1.2, 1.5)) };
      case 'mouth':
        return { eatEfficiency: limitNumber(random(1.1, 1.3)) };
      case 'protection':
        return { damageReduction: limitNumber(random(0.1, 0.3)) };
      case 'stomach':
        return { digestionEfficiency: limitNumber(random(1.1, 1.3)) };
      case 'weapon':
        return { attackPower: limitNumber(random(5, 10)) };
      case 'touch':
        return { sensitivityRadius: limitNumber(random(60, 100)) };
      case 'repair':
        return { healingRate: limitNumber(random(0.1, 0.2)) };
      default:
        return {};
    }
  }

  getColor() {
    const colors = {
      vision: [255, 255, 255],
      skin: [0, 0, 255],
      protection: [128, 0, 128],
      mouth: [255, 0, 0],
      brain: [255, 192, 203],
      energy: [255, 255, 0],
      stomach: [255, 165, 0],
      weapon: [255, 0, 255],
      touch: [0, 255, 255],
      movement: [128, 128, 0],
      repair: [0, 128, 0]
    };
    return colors[this.type] || [100, 100, 100];
  }

  getRole() {
    switch(this.type) {
      case 'skin':
      case 'protection':
      case 'touch':
      case 'weapon':
        return 'outer';
      case 'mouth':
        return 'feeder';
      case 'stomach':
      case 'energy':
      case 'repair':
        return 'processor';
      case 'brain':
        return 'controller';
      case 'movement':
        return 'locomotion';
      default:
        return 'general';
    }
  }

  isIsolated() {
    return this.connections.length === 0;
  }

  isBrainWithOnlyBrainConnections() {
    if (this.type !== 'brain') return false;
    if (this.connections.length === 0) return true;
    return this.connections.every(cell => cell.type === 'brain');
  }

  update(ecosystem) {
    this.lifespan++;
    
    if (this.isIsolated()) {
      this.energy = limitNumber(this.energy - 0.3);
    } else if (this.isBrainWithOnlyBrainConnections()) {
      this.energy = limitNumber(this.energy - 0.2);
    } else if (!this.parentOrganism.isValidOrganism) {
      this.energy = limitNumber(this.energy - 0.15);
    } else {
      this.energy = limitNumber(this.energy - 0.05);
    }

    this.updateSignals();

    if (this.energy <= 0) {
      this.parentOrganism.removeCell(this);
      return;
    }

    this.processSignals();

    if (this.type === 'mouth' && this.signals.foodDetected) {
      this.eat(ecosystem);
    }

    this.mutate();
    this.shareEnergy();

    switch(this.type) {
      case 'weapon':
        this.attackNearbyOrganisms(ecosystem);
        break;
      case 'touch':
        this.detectNearbyObjects(ecosystem);
        break;
      case 'movement':
        this.enhanceMovement();
        break;
      case 'repair':
        this.repairNearbyDamagedCells();
        break;
    }
  }

  updateSignals() {
    this.signals.energyLow = this.energy < this.brain.eatThreshold;
    if (this.type === 'vision') {
      const nearestFood = this.findAccessibleFood();
      this.signals.foodDetected = nearestFood && dist(this.x, this.y, nearestFood.x, nearestFood.y) < this.specializedAttributes.detectionRange;
    }
    if (this.type === 'protection') {
      this.signals.threatDetected = false;
    }
  }

  processSignals() {
    if (this.signals.energyLow || this.signals.foodDetected) {
      this.moveTowardsFood();
    } else {
      this.move();
    }
  }

  moveTowardsFood() {
    const nearestFood = this.findAccessibleFood();
    if (nearestFood) {
      const angle = atan2(nearestFood.y - this.y, nearestFood.x - this.x);
      const maxSpeed = 3;
      const speedBoost = this.specializedAttributes.speedBoost || 1;
      const dx = constrain(cos(angle) * this.brain.moveSpeed * speedBoost * 1.5, -maxSpeed, maxSpeed);
      const dy = constrain(sin(angle) * this.brain.moveSpeed * speedBoost * 1.5, -maxSpeed, maxSpeed);
      this.x = constrain(this.x + dx, 0, width * 2);
      this.y = constrain(this.y + dy, 0, height * 2);
    } else {
      this.move();
    }
  }

  findAccessibleFood() {
    const foodSources = ecosystem.food.slice().sort((a, b) => 
      dist(this.x, this.y, a.x, a.y) - dist(this.x, this.y, b.x, b.y)
    );

    for (let food of foodSources) {
      let isAccessible = true;
      for (let organism of ecosystem.organisms) {
        if (organism !== this.parentOrganism) {
          const d = dist(food.x, food.y, organism.getCenterX(), organism.getCenterY());
          if (d < organism.radius) {
            isAccessible = false;
            break;
          }
        }
      }
      if (isAccessible) {
        return food;
      }
    }
    return null;
  }

  move() {
    const angle = noise(this.x * 0.01, this.y * 0.01, frameCount * 0.01) * TWO_PI;
    const speedBoost = this.specializedAttributes.speedBoost || 1;
    const maxSpeed = 2 * speedBoost;
    let dx = constrain(cos(angle) * this.brain.moveSpeed * speedBoost, -maxSpeed, maxSpeed);
    let dy = constrain(sin(angle) * this.brain.moveSpeed * speedBoost, -maxSpeed, maxSpeed);

    for (let connection of this.connections) {
      const strength = this.getConnectionStrength(connection);
      const forceMagnitude = strength * 0.1;
      const forceAngle = atan2(connection.y - this.y, connection.x - this.x);
      dx += cos(forceAngle) * forceMagnitude;
      dy += sin(forceAngle) * forceMagnitude;
    }

    this.x = constrain(this.x + dx, 0, width * 2);
    this.y = constrain(this.y + dy, 0, height * 2);
  }

  eat(ecosystem) {
    const food = ecosystem.getNearestFood(this.x, this.y);
    if (food && dist(this.x, this.y, food.x, food.y) < this.size) {
      const eatEfficiency = this.specializedAttributes.eatEfficiency || 1;
      const energyGain = 20 * eatEfficiency * (food.size / 5);
      this.energy = limitNumber(this.energy + energyGain);
      ecosystem.removeFood(food);
      this.foodConsumed++;
      if (this.foodConsumed >= 5 && this.energy > 80) {
        ecosystem.waste.push(new Waste(this.x, this.y));
        this.foodConsumed = 0; 
      }
      for (let connection of this.connections) {
        connection.energy = limitNumber(connection.energy + (energyGain / 4));
      }
    }
  }

  mutate() {
    if (random(1) < this.mutationRate) {
      const keys = Object.keys(this.brain);
      const key = random(keys);
      this.brain[key] *= random(0.9, 1.1);
      this.brain[key] = limitNumber(this.brain[key]);
    }

    if (random(1) < this.specializedMutationRate) {
      const attrs = Object.keys(this.specializedAttributes);
      if (attrs.length > 0) {
        const attr = random(attrs);
        this.specializedAttributes[attr] *= random(0.95, 1.05);
        this.specializedAttributes[attr] = limitNumber(this.specializedAttributes[attr]);
      }
    }

    if (random(1) < this.connectionMutationRate) {
      this.maxConnectionDistance *= random(0.98, 1.02);
      this.maxConnectionDistance = constrain(this.maxConnectionDistance, 40, 80);
    }
  }

  shareEnergy() {
    for (let connection of this.connections) {
      if (this.energy > connection.energy) {
        const strength = this.getConnectionStrength(connection);
        const transferAmount = limitNumber((this.energy - connection.energy) * this.brain.energyTransferRate * strength);
        this.energy = limitNumber(this.energy - transferAmount);
        connection.energy = limitNumber(connection.energy + transferAmount);
      }
    }
  }

  getConnectionStrength(otherCell) {
    const distance = dist(this.x, this.y, otherCell.x, otherCell.y);
    return map(distance, 0, this.maxConnectionDistance, 1, 0);
  }

  display() {
    fill(this.color);
    ellipse(this.x, this.y, this.size);
    for (let connection of this.connections) {
      if (dist(this.x, this.y, connection.x, connection.y) <= this.maxConnectionDistance) {
        const connectionStrength = this.getConnectionStrength(connection);
        stroke(200, 50 + connectionStrength * 150);
        strokeWeight(1 + connectionStrength * 2);
        line(this.x, this.y, connection.x, connection.y);
      }
    }
  }

  controlOrganism(organism, ecosystem) {
    if (this.type !== 'brain') return;

    if (organism.isStuck) {
      this.regroupCells(organism);
      this.moveInNewDirection(organism, ecosystem);
    } else {
      this.organizeCells(organism);

      for (let cell of organism.cells) {
        switch (cell.type) {
          case 'mouth':
            if (cell.signals.foodDetected || cell.signals.energyLow) {
              cell.moveTowardsFood();
            }
            break;
          case 'skin':
          case 'protection':
            this.moveToPerimeter(cell, organism);
            break;
          case 'stomach':
          case 'energy':
            this.moveToInterior(cell, organism);
            break;
        }
      }
    }
  }

  regroupCells(organism) {
    const centerX = this.x;
    const centerY = this.y;
    const radius = 20;

    for (let cell of organism.cells) {
      if (cell !== this) {
        const angle = random(TWO_PI);
        const targetX = centerX + cos(angle) * radius;
        const targetY = centerY + sin(angle) * radius;
        cell.x = lerp(cell.x, limitNumber(targetX), 0.1);
        cell.y = lerp(cell.y, limitNumber(targetY), 0.1);
      }
    }
  }

  moveInNewDirection(organism, ecosystem) {
    this.stuckMoveCount++;
    if (this.stuckMoveCount >= 4) {
      ecosystem.removeOrganism(organism);
      ecosystem.maintainOrganismPopulation();
      return;
    }

    const angle = random(TWO_PI);
    const distance = random(50, 100); 
    const moveSteps = 10; 
    
    const dx = (cos(angle) * distance) / moveSteps;
    const dy = (sin(angle) * distance) / moveSteps;

    for (let cell of organism.cells) {
      cell.x = limitNumber(cell.x + dx);
      cell.y = limitNumber(cell.y + dy);
    }

    organism.isStuck = false;
    organism.stuckCounter = 0;
  }

  organizeCells(organism) {
    const centerX = this.x;
    const centerY = this.y;
    const radius = 30;
    let angle = 0;

    for (let cell of organism.cells) {
      if (cell.type !== 'brain') {
        const positionAngle = angle * (PI / 4);
        const targetX = centerX + cos(positionAngle) * radius;
        const targetY = centerY + sin(positionAngle) * radius;

        cell.x = lerp(cell.x, limitNumber(targetX), 0.1);
        cell.y = lerp(cell.y, limitNumber(targetY), 0.1);

        angle++;
      }
    }
  }

  moveToPerimeter(cell, organism) {
    const angle = atan2(cell.y - this.y, cell.x - this.x);
    const targetX = this.x + cos(angle) * 35;
    const targetY = this.y + sin(angle) * 35;
    cell.x = lerp(cell.x, limitNumber(targetX), 0.1);
    cell.y = lerp(cell.y, limitNumber(targetY), 0.1);
  }

  moveToInterior(cell, organism) {
    const angle = atan2(cell.y - this.y, cell.x - this.x);
    const targetX = this.x + cos(angle) * 20;
    const targetY = this.y + sin(angle) * 20;
    cell.x = lerp(cell.x, limitNumber(targetX), 0.1);
    cell.y = lerp(cell.y, limitNumber(targetY), 0.1);
  }

  decideConnection(cell1, cell2) {
    if (this.type !== 'brain') return false;

    const validConnections = {
      'skin': ['protection', 'mouth', 'vision', 'touch', 'weapon'],
      'protection': ['skin', 'brain', 'weapon'],
      'mouth': ['skin', 'stomach', 'brain'],
      'stomach': ['mouth', 'energy', 'brain'],
      'energy': ['stomach', 'brain', 'repair'],
      'brain': ['stomach', 'energy', 'protection', 'vision', 'mouth', 'weapon', 'touch', 'movement', 'repair'],
      'vision': ['skin', 'brain'],
      'weapon': ['skin', 'brain', 'protection'],
      'touch': ['skin', 'brain'],
      'movement': ['brain', 'energy'],
      'repair': ['brain', 'energy']
    };

    const isValidConnection = validConnections[cell1.type].includes(cell2.type) || 
                              validConnections[cell2.type].includes(cell1.type);

    const randomFactor = random(1) < 0.8;

    return isValidConnection && randomFactor;
  }

  attackNearbyOrganisms(ecosystem) {
    for (let organism of ecosystem.organisms) {
      if (organism !== this.parentOrganism) {
        for (let cell of organism.cells) {
          if (dist(this.x, this.y, cell.x, cell.y) < 30) {
            cell.energy = limitNumber(cell.energy - 5);
            break;
          }
        }
      }
    }
  }

  detectNearbyObjects(ecosystem) {
    let nearbyObjects = 0;
    for (let organism of ecosystem.organisms) {
      if (organism !== this.parentOrganism) {
        for (let cell of organism.cells) {
          if (dist(this.x, this.y, cell.x, cell.y) < 50) {
            nearbyObjects++;
          }
        }
      }
    }
    this.signals.objectsDetected = nearbyObjects > 0;
  }

  enhanceMovement() {
    if (this.parentOrganism && this.parentOrganism.brain) {
      this.parentOrganism.brain.brain.moveSpeed = limitNumber(this.parentOrganism.brain.brain.moveSpeed * 1.1);
    }
  }

  repairNearbyDamagedCells() {
    for (let cell of this.parentOrganism.cells) {
      if (cell !== this && dist(this.x, this.y, cell.x, cell.y) < 30 && cell.energy < 50) {
        const transferAmount = Math.min(5, limitNumber(this.energy * 0.1));
        cell.energy = limitNumber(cell.energy + transferAmount);
        this.energy = limitNumber(this.energy - transferAmount);
      }
    }
  }

  propagateSignalsToNetwork() {
    for (let connection of this.connections) {
      connection.signals = {
        ...connection.signals,
        foodDetected: connection.signals.foodDetected || this.signals.foodDetected,
        energyLow: connection.signals.energyLow || this.signals.energyLow,
        threatDetected: connection.signals.threatDetected || this.signals.threatDetected,
        objectsDetected: connection.signals.objectsDetected || this.signals.objectsDetected
      };
    }
  }
}

class Organism {
  constructor(x, y) {
    this.cells = [];
    this.brain = null;
    this.radius = 0;
    this.lastPosition = { x: limitNumber(x), y: limitNumber(y) };
    this.stuckCounter = 0;
    this.stuckThreshold = 100;
    this.isStuck = false;
    this.isValidOrganism = false;
    this.colorObj = generatePastelColor();
    this.vertices = 16; 
    this.bodyPoints = [];
    this.targetPoints = [];
    this.springStrength = 0.1; 
    this.damping = 0.8; 
    this.bodyScale = 0; 
    this.stuckMoveCount = 0; 
    this.sizeMultiplier = random(0.8, 1.2); 
    this.createInitialCells(x, y);
    this.initializeBodyPoints();
  }

  initializeBodyPoints() {
    const centerX = this.getCenterX();
    const centerY = this.getCenterY();
    
    for (let i = 0; i < this.vertices; i++) {
      const angle = (TWO_PI / this.vertices) * i;
      this.bodyPoints.push({
        x: centerX,
        y: centerY,
        vx: 0,
        vy: 0
      });
      this.targetPoints.push({
        x: centerX,
        y: centerY
      });
    }
  }

  updateSoftBody() {
    const centerX = this.getCenterX();
    const centerY = this.getCenterY();
    
    this.bodyScale = lerp(this.bodyScale, 1, 0.1);
    
    for (let i = 0; i < this.vertices; i++) {
      const angle = (TWO_PI / this.vertices) * i;
      const time = frameCount * 0.03;
      const radiusNoise = noise(cos(angle) + time, sin(angle) + time) * 10;
      this.targetPoints[i].x = centerX + (cos(angle) * (this.radius + radiusNoise) * this.bodyScale);
      this.targetPoints[i].y = centerY + (sin(angle) * (this.radius + radiusNoise) * this.bodyScale);
    }
    
    for (let i = 0; i < this.vertices; i++) {
      const point = this.bodyPoints[i];
      const target = this.targetPoints[i];
      
      const dx = target.x - point.x;
      const dy = target.y - point.y;
      point.vx += dx * this.springStrength;
      point.vy += dy * this.springStrength;
      
      const time = frameCount * 0.02;
      point.vx += sin(time + i) * 0.2;
      point.vy += cos(time + i * 0.7) * 0.2;
      
      point.vx *= this.damping;
      point.vy *= this.damping;
      
      point.x += point.vx;
      point.y += point.vy;
    }
  }

  drawSoftBody(scale) {
    beginShape();
    for (let i = 0; i < this.vertices; i++) {
      const point = this.bodyPoints[i];
      const centerX = this.getCenterX();
      const centerY = this.getCenterY();
      const dx = point.x - centerX;
      const dy = point.y - centerY;
      
      const time = frameCount * 0.02;
      const wobble = sin(time + i * 0.5) * 2;
      vertex(centerX + (dx * scale) + wobble, centerY + (dy * scale) + wobble);
    }
    endShape(CLOSE);
  }

  createInitialCells(x, y) {
    const cellTypes = ['vision', 'skin', 'protection', 'mouth', 'brain', 'energy', 'stomach', 'weapon', 'touch', 'movement', 'repair'];
    
    const brain = new Cell(x, y, 'brain', this);
    this.brain = brain;
    this.cells.push(brain);

    const additionalTypes = cellTypes.filter(type => type !== 'brain');
    shuffle(additionalTypes);
    const numCells = floor(random(4, 10));
    
    for (let i = 0; i < numCells; i++) {
      const cell = new Cell(
        x + random(-30, 30),
        y + random(-30, 30),
        additionalTypes[i],
        this
      );
      this.cells.push(cell);
    }

    this.connectCells();
  }

  connectCells() {
    if (this.brain) {
      for (let i = 0; i < this.cells.length; i++) {
        for (let j = i + 1; j < this.cells.length; j++) {
          if (this.brain.decideConnection(this.cells[i], this.cells[j]) &&
              dist(this.cells[i].x, this.cells[i].y, this.cells[j].x, this.cells[j].y) <= this.cells[i].maxConnectionDistance) {
            this.cells[i].connections.push(this.cells[j]);
            this.cells[j].connections.push(this.cells[i]);
          }
        }
      }
    }
  }

  avoidNearbyOrganisms(ecosystem) {
    const avoidanceRadius = this.radius * 2;
    let avoidanceForce = createVector(0, 0);

    for (let other of ecosystem.organisms) {
      if (other !== this) {
        let d = dist(this.getCenterX(), this.getCenterY(), other.getCenterX(), other.getCenterY());
        if (d < avoidanceRadius) {
          let diff = createVector(this.getCenterX() - other.getCenterX(), this.getCenterY() - other.getCenterY());
          diff.normalize();
          diff.div(d);  
          avoidanceForce.add(diff);
        }
      }
    }

    if (avoidanceForce.mag() > 0) {
      avoidanceForce.setMag(this.brain.moveSpeed);
      for (let cell of this.cells) {
        cell.x = limitNumber(cell.x + avoidanceForce.x);
        cell.y = limitNumber(cell.y + avoidanceForce.y);
      }
    }
  }

  checkIfStuck() {
    const currentPosition = this.getAveragePosition();
    const distance = dist(currentPosition.x, currentPosition.y, this.lastPosition.x, this.lastPosition.y);
    
    if (distance < 0.1) {
      this.stuckCounter++;
      if (this.stuckCounter > this.stuckThreshold) {
        this.isStuck = true;
      }
    } else {
      this.stuckCounter = 0;
      this.stuckMoveCount = 0;
      this.isStuck = false;
    }

    this.lastPosition = currentPosition;
  }

  chooseNewDirection() {
    const angle = random(TWO_PI);
    const moveSpeed = this.brain.moveSpeed;
    const dx = cos(angle) * moveSpeed;
    const dy = sin(angle) * moveSpeed;

    for (let cell of this.cells) {
      cell.x = limitNumber(cell.x + dx);
      cell.y = limitNumber(cell.y + dy);
    }

    this.stuckCounter = 0;
  }

  moveToNewPosition() {
    this.stuckMoveCount++;
    if (this.stuckMoveCount >= 4) {
      ecosystem.removeOrganism(this);
      ecosystem.maintainOrganismPopulation();
      return;
    }

    const angle = random(TWO_PI);
    const distance = random(50, 100); 
    const moveSteps = 10; 
    
    const dx = (cos(angle) * distance) / moveSteps;
    const dy = (sin(angle) * distance) / moveSteps;

    for (let cell of this.cells) {
      cell.x = limitNumber(cell.x + dx);
      cell.y = limitNumber(cell.y + dy);
    }
  }

  getAveragePosition() {
    const avgX = this.cells.reduce((sum, cell) => sum + cell.x, 0) / this.cells.length;
    const avgY = this.cells.reduce((sum, cell) => sum + cell.y, 0) / this.cells.length;
    return { x: avgX, y: avgY };
  }

  checkForIsolatedCells() {
    const maxDistance = 100; 
    const isolatedCells = [];

    for (let cell of this.cells) {
      let isConnected = false;
      for (let otherCell of this.cells) {
        if (cell !== otherCell && dist(cell.x, cell.y, otherCell.x, otherCell.y) <= maxDistance) {
          isConnected = true;
          break;
        }
      }
      if (!isConnected) {
        isolatedCells.push(cell);
      }
    }

    for (let cell of isolatedCells) {
      this.removeCell(cell);
      ecosystem.deadCells.push(new DeadCell(cell.x, cell.y, cell.type));
    }
  }

  calculateRadius() {
    if (this.cells.length === 0) return 0;
    let centerX = limitNumber(this.cells.reduce((sum, cell) => sum + cell.x, 0) / this.cells.length);
    let centerY = limitNumber(this.cells.reduce((sum, cell) => sum + cell.y, 0) / this.cells.length);
    this.radius = limitNumber(this.cells.reduce((maxDist, cell) => {
      let dist = Math.sqrt((cell.x - centerX)**2 + (cell.y - centerY)**2);
      return Math.max(maxDist, dist + cell.size / 2);
    }, 0));
  }

  checkIfValidOrganism() {
    if (!this.brain) return false;
    
    let hasNonBrainConnection = false;
    for (let connection of this.brain.connections) {
      if (connection.type !== 'brain') {
        hasNonBrainConnection = true;
        break;
      }
    }
    return hasNonBrainConnection;
  }

  update(ecosystem) {
    this.isValidOrganism = this.checkIfValidOrganism();

    if (!this.isValidOrganism) {
      this.splitOrganism(ecosystem);
      return;
    }

    if (this.brain.isBrainWithOnlyBrainConnections()) {
      this.brain.energy = limitNumber(this.brain.energy - 0.1);  
    }

    if (this.brain) {
      this.brain.controlOrganism(this, ecosystem);
    }

    this.checkIfStuck();
    
    if (this.isStuck) {
      this.moveToNewPosition();
      this.isStuck = false;
      this.stuckCounter = 0;
    }

    this.checkCellDistanceFromBrain(ecosystem);
    
    this.updateSoftBody(); 
    
    for (let i = this.cells.length - 1; i >= 0; i--) {
      const cell = this.cells[i];
      cell.update(ecosystem);
      
      if (cell.energy <= 0) {
        this.removeCell(cell);
        ecosystem.deadCells.push(new DeadCell(cell.x, cell.y, cell.type));
      }
    }
    
    this.checkForIsolatedCells();
    this.propagateSignals();
    this.calculateRadius();
    this.checkIfStuck();
    
    if (this.brain && this.brain.energy <= 0) {
      this.splitOrganism(ecosystem);
    }

    this.avoidNearbyOrganisms(ecosystem);
  }

  checkCellDistanceFromBrain(ecosystem) {
    if (!this.brain) return;

    for (let i = this.cells.length - 1; i >= 0; i--) {
      const cell = this.cells[i];
      if (cell !== this.brain) {
        const distance = dist(cell.x, cell.y, this.brain.x, this.brain.y);
        if (distance > MAX_DISTANCE_FROM_BRAIN) {
          this.removeCell(cell);
          ecosystem.deadCells.push(new DeadCell(cell.x, cell.y, cell.type));
        }
      }
    }
  }

  splitOrganism(ecosystem) {
    for (let cell of this.cells) {
      ecosystem.deadCells.push(new DeadCell(cell.x, cell.y, cell.type));
    }
    this.cells = [];
    ecosystem.removeOrganism(this);
  }

  propagateSignals() {
    let foodDetected = false;
    let energyLow = false;
    let threatDetected = false;

    for (let cell of this.cells) {
      foodDetected = foodDetected || cell.signals.foodDetected;
      energyLow = energyLow || cell.signals.energyLow;
      threatDetected = threatDetected || cell.signals.threatDetected;
    }

    for (let cell of this.cells) {
      cell.signals.foodDetected = foodDetected;
      cell.signals.energyLow = energyLow;
      cell.signals.threatDetected = threatDetected;
    }
  }

  display() {
    if (this.isValidOrganism) {
      this.updateSoftBody();
      
      let centerX = this.getCenterX();
      let centerY = this.getCenterY();

      for (let i = 3; i > 0; i--) {
        noStroke();
        fill(this.colorObj.r, this.colorObj.g, this.colorObj.b, 15 / i);
        this.drawSoftBody(i * 1.2);
      }

      for (let i = 1; i >= 0; i -= 0.2) {
        let alpha = map(i, 0, 1, 50, 200);
        fill(this.colorObj.r, this.colorObj.g, this.colorObj.b, alpha);
        noStroke();
        this.drawSoftBody(i);
      }

      noFill();
      stroke(this.colorObj.r, this.colorObj.g, this.colorObj.b, 255);
      strokeWeight(2);
      this.drawSoftBody(1);
    }
    
    for (let cell of this.cells) {
      cell.display();
    }

    if (this.brain) {
      noFill();
      stroke(255, 255, 0);
      ellipse(this.brain.x, this.brain.y, this.brain.size * 1.5);
    }
  }

  addCell(cell) {
    if (this.cells.length < 10) {
      this.cells.push(cell);
      cell.parentOrganism = this;
      if (this.brain) {
        this.connectCells(); 
      }
    }
  }

  removeCell(cell) {
    const index = this.cells.indexOf(cell);
    if (index > -1) {
      this.cells.splice(index, 1);
      for (let otherCell of this.cells) {
        otherCell.connections = otherCell.connections.filter(c => c !== cell);
      }
      if (this.cells.length === 0) {
        ecosystem.organisms = ecosystem.organisms.filter(o => o !== this);
      }
    }
  }

  checkCollision(otherOrganism) {
    const dx = this.getCenterX() - otherOrganism.getCenterX();
    const dy = this.getCenterY() - otherOrganism.getCenterY();
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (this.radius + otherOrganism.radius);
  }

  resolveCollision(otherOrganism) {
    const dx = this.getCenterX() - otherOrganism.getCenterX();
    const dy = this.getCenterY() - otherOrganism.getCenterY();
    const distance = Math.sqrt(dx * dx + dy * dy);
    const overlap = (this.radius + otherOrganism.radius) - distance;
    
    if (overlap > 0) {
      const moveX = (dx / distance) * overlap * 0.5;
      const moveY = (dy / distance) * overlap * 0.5;
      
      for (let cell of this.cells) {
        cell.x = limitNumber(cell.x + moveX);
        cell.y = limitNumber(cell.y + moveY);
      }
      
      for (let cell of otherOrganism.cells) {
        cell.x = limitNumber(cell.x - moveX);
        cell.y = limitNumber(cell.y - moveY);
      }
    }
  }

  getCenterX() {
    return this.cells.reduce((sum, cell) => sum + cell.x, 0) / this.cells.length;
  }

  getCenterY() {
    return this.cells.reduce((sum, cell) => sum + cell.y, 0) / this.cells.length;
  }
}

class DeadCell {
  constructor(x, y, type) {
    this.x = limitNumber(x);
    this.y = limitNumber(y);
    this.type = type;
    this.size = 15;
    this.lifespan = 600;
  }

  update() {
    this.lifespan--;
  }

  display() {
    fill(100, 100, 100, 150);
    ellipse(this.x, this.y, this.size);
  }
}

class Bubble {
  constructor() {
    this.x = random(width * 2);
    this.y = random(height * 2);
    this.size = random(1, 15);
    this.speed = map(this.size, 1, 15, 0.1, 0.8);
  }

  update() {
    this.y -= this.speed;
    if (this.y < 0) {
      this.y = height * 2;
      this.x = random(width * 2);
    }
  }

  display() {
    noStroke();
    let alpha = map(this.size, 1, 15, 30, 80);
    fill(255, 255, 255, alpha);
    ellipse(this.x, this.y, this.size);
  }
}

class Ecosystem {
  constructor() {
    this.organisms = [];
    this.food = [];
    this.deadCells = [];
    this.waste = [];  
    this.selectedCell = null;
    this.bubbles = [];
    this.lastFoodSpawnTime = 0;
    this.foodSpawnInterval = 95;
    this.maxFood = 370;
    this.minOrganisms = 5; 

    for (let i = 0; i < 150; i++) {
      this.bubbles.push(new Bubble());
    }
  }

  initialize() {
    for (let i = 0; i < 5; i++) {
      this.organisms.push(new Organism(limitNumber(random(width * 2)), limitNumber(random(height * 2))));
    }
    
    const initialClusters = 10;
    for (let i = 0; i < initialClusters; i++) {
      const centerX = random(width * 2);
      const centerY = random(height * 2);
      const clusterSize = floor(random(10, 25));
      this.generateFoodCluster(centerX, centerY, clusterSize);
    }
  }

  generateFoodCluster(centerX, centerY, clusterSize) {
    const clusterRadius = 100; 
    const margin = 20; 
    for (let i = 0; i < clusterSize && this.food.length < this.maxFood; i++) {
      const angle = random(TWO_PI);
      const distance = random(clusterRadius);
      let x = centerX + cos(angle) * distance;
      let y = centerY + sin(angle) * distance;
      
      x = constrain(x, margin, width * 2 - margin);
      y = constrain(y, margin, height * 2 - margin);
      
      const size = random(3, 8);
      this.food.push({
        x,
        y,
        size,
        scale: 0,
        delay: i * 5 
      });
    }
  }

  drawFoodShape(food) {
    push();
    translate(food.x, food.y);
    scale(food.scale);

    noStroke();
    for (let i = 3; i > 0; i--) {
      fill(0, 255, 0, 50 / i);
      ellipse(0, 0, food.size + i * 4);
    }

    fill(0, 255, 0);
    ellipse(0, 0, food.size);
    
    pop();
  }

  moveFood() {
    const attractionRange = 150; 
    const attractionSpeed = 0.8; 

    for (let food of this.food) {
      let nearestCell = null;
      let minDist = Infinity;

      for (let organism of this.organisms) {
        for (let cell of organism.cells) {
          const d = dist(food.x, food.y, cell.x, cell.y);
          if (d < attractionRange && d < minDist) {
            minDist = d;
            nearestCell = cell;
          }
        }
      }

      if (nearestCell) {
        const angle = atan2(nearestCell.y - food.y, nearestCell.x - food.x);
        const sizeModifier = map(food.size, 3, 8, 1.2, 0.8); 
        food.x += cos(angle) * attractionSpeed * sizeModifier * food.scale; 
        food.y += sin(angle) * attractionSpeed * sizeModifier * food.scale;

        food.x = constrain(food.x, 20, width * 2 - 20);
        food.y = constrain(food.y, 20, height * 2 - 20);
      }
    }
  }

  update() {
    for (let i = this.organisms.length - 1; i >= 0; i--) {
      const organism = this.organisms[i];
      organism.update(this);
      
      if (!organism.isValidOrganism) {
        this.splitInvalidOrganism(organism);
        i--; 
      }
    }

    this.moveFood(); 

    for (let i = this.waste.length - 1; i >= 0; i--) {
      this.waste[i].update();
      if (this.waste[i].lifespan <= 0) {
        this.waste.splice(i, 1);
      }
    }

    if (frameCount - this.lastFoodSpawnTime > this.foodSpawnInterval && this.food.length < this.maxFood) {
      const clusterCount = floor(random(2, 4)); 
      for (let i = 0; i < clusterCount; i++) {
        const centerX = random(20, width * 2 - 20); 
        const centerY = random(20, height * 2 - 20); 
        const clusterSize = floor(random(8, 20)); 
        this.generateFoodCluster(centerX, centerY, clusterSize);
      }
      this.lastFoodSpawnTime = frameCount;
    }

    for (let i = this.deadCells.length - 1; i >= 0; i--) {
      this.deadCells[i].update();
      if (this.deadCells[i].lifespan <= 0) {
        this.deadCells.splice(i, 1);
      }
    }

    for (let i = this.organisms.length - 1; i >= 0; i--) {
      if (this.organisms[i].cells.length === 0) {
        this.organisms.splice(i, 1);
      }
    }

    this.maintainOrganismPopulation();
  }

  updateBubbles() {
    for (let bubble of this.bubbles) {
      bubble.update();
    }
  }

  maintainOrganismPopulation() {
    while (this.organisms.length < this.minOrganisms) {
      let validPosition = this.findClearPosition();
      if (validPosition) {
        const newOrganism = new Organism(validPosition.x, validPosition.y);
        this.organisms.push(newOrganism);
      }
    }
  }

  findClearPosition() {
    const margin = 100;
    let attempts = 0;
    const maxAttempts = 50;

    while (attempts < maxAttempts) {
      const x = random(margin, width * 2 - margin);
      const y = random(margin, height * 2 - margin);
      
      let isClear = true;
      for (let organism of this.organisms) {
        const d = dist(x, y, organism.getCenterX(), organism.getCenterY());
        if (d < organism.radius + margin) {
          isClear = false;
          break;
        }
      }

      if (isClear) {
        return {x, y};
      }
      attempts++;
    }
    
    return {
      x: random(margin, width * 2 - margin),
      y: random(margin, height * 2 - margin)
    };
  }

  removeOrganism(organism) {
    const index = this.organisms.indexOf(organism);
    if (index > -1) {
      this.organisms.splice(index, 1);
    }
  }

  claimDeadCells() {
    for (let organism of this.organisms) {
      if (organism.brain) {
        for (let i = this.deadCells.length - 1; i >= 0; i--) {
          const deadCell = this.deadCells[i];
          const distance = dist(organism.brain.x, organism.brain.y, deadCell.x, deadCell.y);
          if (distance < 100 && organism.cells.length < 10) {
            const newCell = new Cell(deadCell.x, deadCell.y, deadCell.type, organism);
            organism.addCell(newCell);
            this.deadCells.splice(i, 1);
            break;
          }
        }
      }
    }
  }

  display() {
    for (let food of this.food) {
      if (frameCount > food.delay && food.scale < 1) {
        food.scale = min(food.scale + 0.1, 1);
      }
      this.drawFoodShape(food);
    }

    for (let waste of this.waste) {
      waste.display();
    }

    for (let organism of this.organisms) {
      organism.display();
    }

    for (let deadCell of this.deadCells) {
      deadCell.display();
    }

    for (let bubble of this.bubbles) {
      bubble.display();
    }
  }

  removeFood(food) {
    const index = this.food.indexOf(food);
    if (index > -1) {
      this.food.splice(index, 1);
    }
  }

  ensureCellsWithinBounds() {
    for (let organism of this.organisms) {
      for (let cell of organism.cells) {
        cell.x = constrain(cell.x, 0, width * 2);
        cell.y = constrain(cell.y, 0, height * 2);
      }
    }
  }

  selectCell(x, y) {
    let minDist = Infinity;
    let selected = null;
    for (let organism of this.organisms) {
      for (let cell of organism.cells) {
        const d = dist(x, y, cell.x, cell.y);
        if (d < cell.size / 2 && d < minDist) {
          minDist = d;
          selected = cell;
        }
      }
    }
    this.selectedCell = selected;
    return selected;
  }

  get cells() {
    return this.organisms.flatMap(organism => organism.cells);
  }

  getNearestFood(x, y) {
    let nearest = null;
    let minDist = Infinity;
    for (let food of this.food) {
      const d = dist(x, y, food.x, food.y);
      if (d < minDist) {
        minDist = d;
        nearest = food;
      }
    }
    return nearest;
  }

  checkOrganismCollisions() {
    for (let i = 0; i < this.organisms.length; i++) {
      for (let j = i + 1; j < this.organisms.length; j++) {
        if (this.organisms[i].checkCollision(this.organisms[j])) {
          this.organisms[i].resolveCollision(this.organisms[j]);
        }
      }
    }
  }

  splitInvalidOrganism(organism) {
    for (let cell of organism.cells) {
      this.deadCells.push(new DeadCell(cell.x, cell.y, cell.type));
    }
    this.removeOrganism(organism);
    this.maintainOrganismPopulation();
  }
}

function calculateInitialCameraPosition() {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  for (let organism of ecosystem.organisms) {
    for (let cell of organism.cells) {
      minX = Math.min(minX, cell.x);
      minY = Math.min(minY, cell.y);
      maxX = Math.max(maxX, cell.x);
      maxY = Math.max(maxY, cell.y);
    }
  }
  
  const ecosystemWidth = maxX - minX;
  const ecosystemHeight = maxY - minY;
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  const scaleX = width / ecosystemWidth;
  const scaleY = height / ecosystemHeight;
  const zoom = Math.min(scaleX, scaleY) * 0.9; 
  
  return { x: centerX, y: centerY, zoom: zoom };
}

function setup() {
  const containerSize = min(windowWidth * 0.6, windowHeight * 0.6);
  const canvas = createCanvas(containerSize, containerSize);
  canvas.parent('ecosystem');
  ecosystem = new Ecosystem();
  ecosystem.initialize();
  
  const initialCamera = calculateInitialCameraPosition();
  camera.x = initialCamera.x;
  camera.y = initialCamera.y;
  camera.zoom = initialCamera.zoom;
}

function autoRecenterCamera() {
    if (!isDragging && !followedCell) {
        let bounds = calculateEcosystemBounds();
        let targetX = (bounds.minX + bounds.maxX) / 2;
        let targetY = (bounds.minY + bounds.maxY) / 2;
        
        camera.x = lerp(camera.x, targetX, 0.02);
        camera.y = lerp(camera.y, targetY, 0.02);
    }
}

function calculateEcosystemBounds() {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    
    for (let organism of ecosystem.organisms) {
        for (let cell of organism.cells) {
            minX = min(minX, cell.x);
            minY = min(minY, cell.y);
            maxX = max(maxX, cell.x);
            maxY = max(maxY, cell.y);
        }
    }
    
    return {minX, minY, maxX, maxY};
}

function draw() {
  try {
    background(0, 10, 30);

    updateCameraFollow();
    autoRecenterCamera();

    translate(width/2, height/2);
    scale(camera.zoom);
    translate(-camera.x, -camera.y);

    if (!isPaused) {
      ecosystem.update();
      ecosystem.updateBubbles();
      
      document.getElementById('organism-count').textContent = ecosystem.organisms.length;
      document.getElementById('food-count').textContent = ecosystem.food.length;
      document.getElementById('waste-count').textContent = ecosystem.waste.length;
      document.getElementById('dead-cell-count').textContent = ecosystem.deadCells.length;
      
      ecosystem.organisms.forEach(organism => {
        if (organism && organism.cells) {
          organism.cells.forEach(cell => {
            if (!isFinite(cell.x) || !isFinite(cell.y)) {
              console.warn('Invalid cell position detected, removing organism');
              ecosystem.removeOrganism(organism);
            }
          });
        }
      });
    }
    
    ecosystem.display();

    resetMatrix();

  } catch (error) {
    console.error("Error in draw function:", error);
    isPaused = true;
    ecosystem.maintainOrganismPopulation();
  }
}

function keyPressed() {
  if (key === ' ') {
    isPaused = !isPaused;
  }
}

function updateCameraFollow() {
  if (followedCell && followedCell.parentOrganism) {
    const targetX = followedCell.x;
    const targetY = followedCell.y;
    camera.x = lerp(camera.x, targetX, 0.1);
    camera.y = lerp(camera.y, targetY, 0.1);
  }
}

function mousePressed() {
  const worldX = (mouseX - width/2) / camera.zoom + camera.x;
  const worldY = (mouseY - height/2) / camera.zoom + camera.y;
  
  followedCell = ecosystem.selectCell(worldX, worldY);
  
  if (!followedCell) {
    isDragging = true;
    dragStartX = mouseX;
    dragStartY = mouseY;
  }
}

function mouseDragged() {
  if (isDragging) {
    const dx = (mouseX - dragStartX) / camera.zoom;
    const dy = (mouseY - dragStartY) / camera.zoom;
    camera.x -= dx;
    camera.y -= dy;
    dragStartX = mouseX;
    dragStartY = mouseY;
  }
}

function mouseReleased() {
  isDragging = false;
}

function windowResized() {
  const containerSize = min(windowWidth * 0.6, windowHeight * 0.6);
  resizeCanvas(containerSize, containerSize);
}
</script>
</body>
</html>