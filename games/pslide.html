<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[PSLIDE]</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 0px;
        }

        #game-container {
            display: inline-block;
            position: relative;
            margin: 0 auto;
            width: 100%; /* Take full width of the parent */
            max-width: 600px; /* Cap the size at 600px for larger screens */
        }

        canvas {
            border: 3px solid #333;
            display: block;
            margin: 0 auto;
            width: 100%; /* Canvas width dynamically adjusts */
            height: auto; /* Maintain aspect ratio */
        }

        #controls {
            margin-top: 20px;
        }

        #start-button, #new-button {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        #controls input,
        #controls select {
            padding: 5px;
            font-size: 16px;
        }

        #game-status {
            margin-top: 20px;
        }
    </style>
</head>
<body>
<script src="js/nav-loader.js"></script>
<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFWR21VMoS76qPwT6t9ZIBeGjKpA3MT3Adx1JUMHQZYJ0LVDaWOxoI2et22ykEPJT6VZ7DASn6CnXwkDwr635vOWHPifCVTcYE8Xs1u5tp1Blk1mHP0Ud-B4JhgI2McvXLKMA8Y6nNZQpvb-hyG5wc05hRkaTXwNWJHZgzIgorA8tQDkac_IrtYbs62aQ/s1280/AI-PSLIDE.png" style="display: block; padding: 1em 0; text-align: center; "><img alt="" border="0" width="600" data-original-height="720" data-original-width="1280" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFWR21VMoS76qPwT6t9ZIBeGjKpA3MT3Adx1JUMHQZYJ0LVDaWOxoI2et22ykEPJT6VZ7DASn6CnXwkDwr635vOWHPifCVTcYE8Xs1u5tp1Blk1mHP0Ud-B4JhgI2McvXLKMA8Y6nNZQpvb-hyG5wc05hRkaTXwNWJHZgzIgorA8tQDkac_IrtYbs62aQ/s600/AI-PSLIDE.png"/></a></div>
    <!-- Puzzle Settings -->
    <div id="controls">
        <label for="grid-size">Grid Size:</label>
        <select id="grid-size">
            <option value="3">3x3</option>
            <option value="4">4x4</option>
            <option value="5">5x5</option>
        </select>

        <br><br>

        <label for="image-prompt">Enter Image Prompt (or leave blank for random):</label>
        <input type="text" id="image-prompt" placeholder="e.g., scenic landscape">

        <br><br>

        <button id="start-button">Get Image</button>
        <button id="new-button" style="display: none;">New Puzzle</button>
        <div id="game-status"></div>
    </div>

    <!-- Puzzle Display Area -->
    <div id="game-container">
        <canvas id="puzzle-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('puzzle-canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const newButton = document.getElementById('new-button');
        const gridSizeSelector = document.getElementById('grid-size');
        const imagePromptInput = document.getElementById('image-prompt');
        const gameStatus = document.getElementById('game-status');

        let gridSize = 3;
        let pieces = [];
        let blank = { x: 0, y: 0 };
        let puzzleStarted = false;
        let puzzleImage = null;
        let moves = 0;
        let imageLoaded = false;  // To track if the image is loaded and avoid clearing on resize

        const maxCanvasSize = 600; // Maximum size of the canvas

        function resizeCanvas() {
            const containerWidth = Math.min(maxCanvasSize, document.getElementById('game-container').offsetWidth);
            canvas.width = containerWidth;
            canvas.height = containerWidth; // Keep it square (1:1 aspect ratio)

            if (imageLoaded) {
                drawPuzzle();  // Redraw the puzzle on resize
            }
        }

        window.addEventListener('resize', resizeCanvas);

        startButton.addEventListener('click', () => {
            if (!puzzleStarted) {
                startPuzzle();
            } else {
                resetPuzzle();
            }
        });

        newButton.addEventListener('click', startPuzzle);

        function startPuzzle() {
            gridSize = parseInt(gridSizeSelector.value);
            let imagePrompt = imagePromptInput.value.trim();
            let randomSeed = Math.floor(Math.random() * 1000000); // Generate a random seed

            let apiUrl = imagePrompt
                ? `https://image.pollinations.ai/prompt/${encodeURIComponent(imagePrompt)}?seed=${randomSeed}&nologo=true&width=1024&height=1024&model=flux`
                : `https://image.pollinations.ai/prompt/random%20fun%20image?seed=${randomSeed}&nologo=true&width=1024&height=1024&model=flux`;

            startButton.disabled = true;
            startButton.textContent = "Loading...";

            fetchImage(apiUrl).then(image => {
                puzzleImage = image;
                imageLoaded = true;  // Mark the image as loaded
                resizeCanvas();  // Ensure the canvas is sized correctly before drawing
                ctx.drawImage(image, 0, 0, 1024, 1024, 0, 0, canvas.width, canvas.height);
                setTimeout(() => {
                    createPuzzle();
                    shufflePuzzle();
                    drawPuzzle();
                    startButton.textContent = "Reset Puzzle";
                    startButton.disabled = false;
                    newButton.style.display = "block";
                    newButton.textContent = "New Puzzle";
                    puzzleStarted = true;
                    gameStatus.textContent = "Puzzle started! Click to move pieces.";
                }, 1000);
            }).catch(error => {
                console.error("Error fetching the image:", error);
                alert("Could not load the image. Please try again with a different prompt.");
                startButton.textContent = "Get Image";
                startButton.disabled = false;
            });
        }

        function fetchImage(url) {
            return new Promise((resolve, reject) => {
                let img = new Image();
                img.crossOrigin = 'Anonymous';
                img.src = url;
                img.onload = () => resolve(img);
                img.onerror = (err) => reject(err);
            });
        }

        function createPuzzle() {
            pieces = [];
            moves = 0;

            let pieceSize = canvas.width / gridSize;  // Dynamic piece size

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (row === gridSize - 1 && col === gridSize - 1) {
                        blank.x = col;
                        blank.y = row;
                        continue;
                    }
                    pieces.push({
                        x: col,
                        y: row,
                        originalX: col,
                        originalY: row
                    });
                }
            }
        }

        function shufflePuzzle() {
            const shuffleMoves = gridSize * gridSize * 20;
            for (let i = 0; i < shuffleMoves; i++) {
                const neighbors = getNeighbors(blank.x, blank.y);
                const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                swapWithBlank(randomNeighbor.x, randomNeighbor.y);
            }
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            if (x > 0) neighbors.push({ x: x - 1, y });
            if (x < gridSize - 1) neighbors.push({ x: x + 1, y });
            if (y > 0) neighbors.push({ x, y: y - 1 });
            if (y < gridSize - 1) neighbors.push({ x, y: y + 1 });
            return neighbors;
        }

        function swapWithBlank(x, y) {
            const piece = pieces.find(p => p.x === x && p.y === y);
            if (piece) {
                [piece.x, blank.x] = [blank.x, piece.x];
                [piece.y, blank.y] = [blank.y, piece.y];
            }
        }

        function drawPuzzle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let pieceSize = canvas.width / gridSize;  // Dynamic piece size

            pieces.forEach(piece => {
                ctx.drawImage(
                    puzzleImage,
                    piece.originalX * (1024 / gridSize), piece.originalY * (1024 / gridSize), 1024 / gridSize, 1024 / gridSize,
                    piece.x * pieceSize, piece.y * pieceSize, pieceSize, pieceSize
                );
                drawGrid(piece.x, piece.y, pieceSize);
            });

            ctx.fillStyle = '#CCCCCC';
            ctx.fillRect(blank.x * pieceSize, blank.y * pieceSize, pieceSize, pieceSize);
            drawGrid(blank.x, blank.y, pieceSize);
        }

        function drawGrid(x, y, pieceSize) {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x * pieceSize, y * pieceSize, pieceSize, pieceSize);
        }

        function movePiece(event) {
            if (!puzzleStarted) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const pieceSize = canvas.width / gridSize;
            const clickedCol = Math.floor(x / pieceSize);
            const clickedRow = Math.floor(y / pieceSize);

            if (isAdjacent(clickedCol, clickedRow)) {
                swapWithBlank(clickedCol, clickedRow);
                moves++;
                drawPuzzle();

                if (checkWin()) {
                    puzzleStarted = false;
                    gameStatus.textContent = `Congratulations! You solved the puzzle in ${moves} moves!`;
                    startButton.textContent = "New Puzzle";  // Correct button text after solving
                }
            }
        }

        function isAdjacent(col, row) {
            const dx = Math.abs(blank.x - col);
            const dy = Math.abs(blank.y - row);
            return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
        }

        function resetPuzzle() {
            puzzleStarted = false;
            startButton.textContent = "Get Image";
            gameStatus.textContent = "";
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            imageLoaded = false;  // Mark image as not loaded to avoid drawing on resize
            canvas.removeEventListener('click', movePiece);
            puzzleImage = null;
            pieces = [];
            moves = 0;
        }

        function checkWin() {
            for (let piece of pieces) {
                if (piece.x !== piece.originalX || piece.y !== piece.originalY) {
                    return false;
                }
            }
            return true;
        }

        canvas.addEventListener('click', movePiece);

        // Initialize canvas size
        resizeCanvas();
    </script>
	    <!-- Footer with Pollinations.ai attribution -->
    <div style="text-align: right; margin-top: 20px; font-size: 8px; color: #aaa;">
        <a href="https://pollinations.ai" target="_blank" style="color: #aaa; text-decoration: none;">
            Generations by Pollinations.ai
        </a>
    </div>
</body>
</html>
