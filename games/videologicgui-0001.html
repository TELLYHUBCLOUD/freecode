<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoLogic HUD Configurator</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #333;
        }

        canvas {
            display: block;
        }
        .chat-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .chat-header button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
        }

        .chat-header h3 {
            margin-right: 10px;
        }

        .chat-messages {
            height: 250px;
            overflow-y: auto;
            padding: 5px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages p {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .chat-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 5px;
        }

        .chat-input button {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-input button:hover {
            background-color: #0056b3;
        }

        .user-message {
            background-color: #e8f7ff;
            padding: 5px;
            border-radius: 5px;
            align-self: flex-end;
            max-width: 80%;
            margin-left: auto;
            margin-bottom: 5px;
        }

        .assistant-message {
            background-color: #f0f0f0;
            padding: 5px;
            border-radius: 5px;
            max-width: 80%;
            margin-bottom: 5px;
        }
         #status-message {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
        }
    </style>
</head>

<body>
    <canvas id="configCanvas"></canvas>
      <textarea id="pasteText" style="display:none"></textarea>
      <input type="file" id="iniFileInput" style="display:none" accept=".ini">
    <div class="chat-popup" id="chat-popup">
        <div class="chat-header">
            <h3>AI Help</h3>
            <button id="close-chat-button">X</button>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <div class="chat-input">
            <input type="text" id="chat-input-text" placeholder="Type your question">
            <button id="chat-send-button">Send</button>
        </div>
    </div>
     <p id="status-message"></p>

    <script>
        const canvas = document.getElementById('configCanvas');
        const ctx = canvas.getContext('2d');
        const pasteText = document.getElementById('pasteText');
        const iniFileInput = document.getElementById('iniFileInput');
        const chatPopup = document.getElementById('chat-popup');
        const closeChatButton = document.getElementById('close-chat-button');
        const chatMessages = document.getElementById('chat-messages');
        const chatInputText = document.getElementById('chat-input-text');
        const chatSendButton = document.getElementById('chat-send-button');
        const statusMessage = document.getElementById('status-message');
		
        let chatHistory = [];
        let currentHelpSetting = '';
        let currentSettings = {}; // To store the INI data
        let uiElements = []; // Store the locations of our ui components for interacting
        let canvasWidth = 0;
        let canvasHeight = 0;
        let hudLayout = {
          sectionPadding: 30,
          settingPadding: 15,
          labelWidth: 250,
          inputWidth: 250,
          inputHeight: 30,
        }

        const systemMessage = "You are an expert in explaining and configuring VideoLogic, an application that processes video files using FFmpeg. Your goal is to help users configure the app to their needs. Answer with useful, actionable info. Be concise.";
		 
        const documentation = `
            # You may add extra text to the title bar of the VideoLogic program
            # to help dinstinguish multiple parallel running instances.
            ##app.branding = [VLC]


            # Abort conversions if VideoLogic detects major problems with the input
            # duration.
            files.abort_corrupt_duration = yes


            # VideoLogic will automatically change the console color palette when it isn't
            # running in single-file-processing mode (with command line parameters).  This
            # setting can be used to forcibly enable or disable extended color palette use.
            # Note that this feature only works in Windows.
            ##app.extended_colors = yes


            # Usually, VideoLogic will assume video files that do not have audio aren't
            # valid.  To process them anyway, enable this option.  Note: in single-file
            # processing mode (with command line parameters), this option is automatically
            # enabled.
            app.allow_no_audio = no

            # Log-to-disk lifetime video conversion stats and a record of events and
            # ffmpeg output.  Note: in single-file processing mode (with command line
            # parameters), this option is automatically disabled.
            ##app.logging = yes


            # Home path for VideoLogic.  If unset, it will use the current working
            # folder as the home path.
            ##path.home =


            # Binary path for VideoLogic.  If unset, it will calculate the path based
            # on the location of VideoLogic.  This setting only applies to Windows OS.
            ##path.bins =


            # Once conversions are complete, move converted files to this network path.
            # If unset, converted files will remain in .\Converted and not moved to a
            # final destination.
            path.move_final = C:\\DOWNLOADS


            # A list of file extensions VideoLogic should look for when processing video
            # files.  Files with extensions not in this list will be skipped entirely.
            files.extensions_to_process = avi divx flv m2ts mkv mov mp4 mpeg mpg ts wmv xvid


            # Keep original files in ./Originals
            #
            # When enabled, you will need to manually delete files in this path at your
            # discretion.  Once VideoLogic moves originals here, it never manages them
            # again.
            files.keep_originals = yes


            # Process files that are deeply nested (more than one level).  Enabling this
            # option will allow VideoLogic to process videos in a library hierarchy,
            # including Season subfolders, movie collections, etc.  Disabling this option
            # will instruct VideoLogic to confine processing to files only in the base
            # queue folders and any folders one (1) nested level deep, as if it were
            # processing new downloads.
            files.process_deep_nest = yes


            # Allows post-processing or supplementary programs, batch files, etc. to be
            # executed after conversion success, error, or skip.
            #
            # Tokens:
            #    ##of       original file name (no path)
            #    ##paf      path and file name of the converted or moved file
            #    ##f        file name of the converted or moved file (no path)
            #    ##p        path of the converted or moved file (no file name)
            ##files.execute_after.success = "C:\\path\\to\\program.exe" "example parameter ##of"
            ##files.execute_after.error   = "C:\\path\\to\\program.exe" "example parameter ##of"
            ##files.execute_after.skipped = "C:\\path\\to\\program.exe" "example parameter ##of"


            # Extra text in the output filename to denote that the file has been converted.
            files.branding = [VL]


            # Enable detection of black bars in the video and remove them by cropping the
            # video frame to a new size.  Resizing options will use the cropped size.  No
            # cropping will occur if no black bars are detected or if this setting is
            # disabled.
            video.remove_black_bars = yes


            # When black bars are being detected for removal, check if the size of the
            # left and right margins match as well as top and bottom margins.  If one
            # side of the two pairs don't match and symmetry is enabled, the smaller side
            # will be enlarged to match the larger side.  This automatically fixes some
            # cases of black bars with logos, URLs, or text stamped into the black bar
            # image margin.
            video.black_bar_symmetry = yes


            # Enable deinterlacing video filter (using FFMPEG 'yadif' filter), useful for
            # transcoding DVD or other interlaced video content.  The filter will not be
            # used if the source video isn't interlaced or if this setting is disabled.
            video.deinterlace = yes


            # Restricts the maximum framerate of the output video to 30.0 FPS.  When
            # enabled, framerates exceeding 30.0 FPS will be divided by 2 repeatedly until
            # it falls under this value.  In this way, there should be no distortion in
            # videos that were recorded with very high framerates (such as 60 FPS and up).
            video.restrict_fps = no


            # Dual-pass (2-pass) encoding can significantly increase compression
            # efficiency for creating smaller files, but will drastically increase the
            # amount of time required to transcode.
            ffmpeg.2_pass_encoding = no


            # FFMPEG can be launched at different application priority levels.
            #
            # idle or low         lowest priority level and only gets processing time when
            #                     the CPU is idle (not recommended)
            # below normal        lower priority than normal, but still receives regular
            #                     processing cycles from the CPU (default for VideoLogic)
            # normal              the default priority level for all user applications
            # above normal        higher priority than normal, but not as demanding on the
            #                     system and will still play nicely with other applications
            # high                time-critical priority level for tasks that must be
            #                     executed immediately, regardless of the load on the OS,
            #                     preempting applications running in normal or idle
            #                     priority levels (not recommended)
            # realtime            if you want your sytsem unresponsive during transcoding,
            #                     this gives VideoLogic the highest priority level the OS
            #                     can offer and can't be preempted by even OS timer
            #                     interrupts (including using the keyboard, mouse, hard
            #                     drive cache, etc.) (VERY not recommended)
            ffmpeg.core.priority = below normal


            # This setting compromises encoding speed vs. optimizations.  Favoring speed
            # will produce somewhat bigger file sizes as fewer encoder calculations are
            # used to perform motion prediction, smaller quanitizers are employed, etc.
            # The visual quality should be the same at all levels.  Allowed values are
            # specific to which encoder you are using.  For software-based x264 and
            # software-based x265/HEVC, the following presets are available:
            #
            # placebo              almost no improvements over 'veryslow' and shouldn't be
            #                      used except for possibly testing
            # veryslow, best       every optimization enabled
            # slower
            # slow
            # medium, average, normal, default
            # fast
            # faster
            # veryfast
            # superfast, worst     nearly every optimization disabled
            # ultrafast
            #
            # See:  https://trac.ffmpeg.org/wiki/Encode/H.264
            #       https://trac.ffmpeg.org/wiki/Encode/H.265
            #
            # For Intel Quicksync x264 and x265/HEVC, the following presets are available:
            #
            # veryslow
            # slower
            # slow
            # medium, default
            # fast
            # faster
            # veryfast
            #
            # See:  ffmpeg -help encoder=h264_qsv
            # See:  ffmpeg -help encoder=hevc_qsv
            #
            # For nVidia NVENC x264 and x265/HEVC, the following presets are available:
            #
            # slow                 hq 2 passes
            # medium, default      hq 1 pass
            # fast                 hp 1 pass
            # hp
            # hq                   high quality
            # bd
            # ll                   low latency
            # llhq                 low latency hq
            # llhp                 low latency hp
            # lossless             lossless
            # losslesshp           lossless hp
            #
            # See:  ffmpeg -help encoder=nvenc_h264
            # See:  ffmpeg -help encoder=nvenc_hevc
            ffmpeg.core.preset = medium


            # Want constant rate format (constant quality), average bitrate,
            # or constant bitrate.  Constant bitrate is not compatible with
            # 2-pass mode.
            #
            # config setting                bitrate mode
            # --------------                ---------------
            # quality                       maintain constant quality (CRF/QP, recommended)
            # ABR, VBR, average, variable   average bitrate
            # CBR, constant                 constant bitrate (rarely used)
            # size                          calculate bitrate for you by specifying
            #                               a target maximum file size
            #
            # Note: the using 'quality', 'CRF', 'QP', or 'CQP' will be interpretted to mean
            # 'constant quality' and will use the better version of whatever is supported
            # by the encoder.  For example, software-based x264 and x265/HEVC encoding will
            # support CRF-based quality but hardware-based x265 and x265/HEVC encoding
            # won't, so will be downgraded to QP-based encoding.
            #
            # Here is some information on the difference between CRF and QP:
            # https://slhck.info/video/2017/02/24/crf-guide.html
            ffmpeg.video.bitrate_mode = quality


            # Specify a maximum file size for your video.  This requires bitrate mode
            # to be set to 'size' and will override your bitrate setting and force
            # 2-pass encoding.  VideoLogic will make all efforts to target this maximum
            # file size, although it will only consider your video stream (audio data
            # will make the result file size larger, especially if you are encoding high
            # bitrate audio or keeping DTS audio streams, etc.).
            #
            # Note: this is set to total bytes (no shorthand like 500M or 2G).
            #
            # Note: this option is not compatible with Intel Quicksync or nVidia NVENC
            # encoders (either the encoders do not support 2-pass encoding or VideoLogic
            # is not developed to accommodate those features), so use software-based
            # encoders instead if you need to specify a target file size for your videos.
            ffmpeg.video.max_file_size = 750000000


            # This bitrate setting is used to assign an average or maximum bitrate
            # and affects the different encoding modes differently.  It's highly
            # recommended to use 2-pass mode if you are targeting a specific file
            # size and need to best control the bitrate.
            #
            # For CRF/quality, this setting defines a maximum bitrate the encoder is
            # allowed to use (no minimum).  Set it to 0 for no limit on bitrate, only
            # a limit on quality as defined by the CRF quality setting.  It's highly
            # recommended to use 2-pass mode when both ABR and bitrate settings are
            # configured.
            #
            # For ABR, this setting defines the average bitrate the encoder should
            # target with variable bitrate above and below this amount with consideration
            # to encoder optimizations.  This value must not be 0 in ABR mode.  It's
            # highly recommended to use 2-pass mode when both ABR and bitrate settings
            # are configured.
            #
            # For CBR, this setting defines the absolute bitrate the encoder will use
            # constantly throughout the entire video.  It's impossible to use CBR and
            # 2-pass modes together since there can be no variation in bitrate and thus
            # no optimizations to make in targeting an average or maximum bitrate.
            #
            # Note: this is set to bits per second (no shorthand like 3M or 500K).
            ffmpeg.video.bitrate = 1800000


            # 'Sane' Constant Rate Factor (CRF) values for x264 encoding are between 18-28.
            #
            # Typically, 23 is the baseline for x264 and a CRF change of +/- 6 levels
            # should result in about a double or half output filesize, although results
            # may vary.
            #
            # Note: this option is translated to QP for hardware-based encoders such as
            # Intel Quicksync and nVidia NVENC.  See 'ffmpeg.core.qp.x264'.
            ffmpeg.core.crf.x264 = 20


            # 'Sane' Constant Rate Factor (CRF) values for x265 encoding are between 18-28.
            #
            # Typically, 28 is the baseline for x265 and a CRF change of +/- 6 levels
            # should result in about a double or half output filesize, although results
            # may vary.
            #
            # Note: this option is translated to QP for hardware-based encoders such as
            # Intel Quicksync and nVidia NVENC.  See 'ffmpeg.core.qp.x265'.
            ffmpeg.core.crf.x265 = 25


            # Constant Quantization Parameter (QP) for hardware-based x264 encoders.
            # Note, if this value is left blank, it will be automatically calculated based
            # on your 'ffmpeg.core.crf.x264' setting.
            ffmpeg.core.qp.x264 = 26


            # Constant Quantization Parameter (QP) for hardware-based x265/HEVC encoders.
            # Note, if this value is left blank, it will be automatically calculated based
            # on your 'ffmpeg.core.crf.x265' setting.
            ffmpeg.core.qp.x265 = 29


            # Other FFMPEG settings can be tweaked here.  Note: threads of '0' instructs
            # FFMPEG to automatically use the same number of threads as you have processor
            # cores available.  Video profile and level can be set blank to instruct
            # FFMPEG to use its defaults which are automatically selected based on other
            # encoding parameters.
            #
            # Note that picture format will be overridden to 'nv12' if your encoder is set
            # to Intel Quicksync x264 or Intel Quicksync x265 as none of the 'yuv' picture
            # formats are supported by that encoder.
            ffmpeg.core.threads        = 0
            ffmpeg.core.picture_format = yuv420p
            ffmpeg.core.container      = mkv
            ffmpeg.video.profile       =
            ffmpeg.video.level         =


            # Force video aspsect ratio for the target container.  If this setting is left
            # blank, the output video will not be forcefully set to any specific ratio and
            # will use the default matching the width and height ratio of the original
            # video source.  Otherwise, this setting can be used to specify any ratio in
            # the format WIDTH:HEIGHT.  Example: 16:9, 4:3, etc.
            #
            # When VideoLogic adjusts the aspect ratio, FFMPEG will be instructed to set
            # the output video frame size to a new height (width is unadjusted) that
            # matches the width/height ratio specified and then then sets the DAR
            # appropriately with FFMPEG's -aspect switch.  In this way the SAR is unchanged
            # and additional video degradation from additional sampling is avoided.
            ##video.aspect = 16:9


            # Attempt aspect ratio correction by examining original sample aspect ratio
            # (SAR) and clamping it to common display aspect ratios (DAR).  This option can
            # product videos with higher playback compatibility, especially when black bars
            # are being removed, but the resulting quality may appear slightly reduced.
            video.clamp_aspect = no


            # Adjust which codec to use when converting video.  Allowed values are:
            #
            # config setting   FFMPEG encoding library / notes
            # ---------------  -----------------------------------------------------------
            # copy, none                copy (does not transcode, just copy the stream)
            # match                     use the same codec as input (must be one of the
            #                           below options, but will still transcode the video)
            # x264                      libx264      software-based x264-encoding
            # x265, HEVC                libx265      software-based x265/HEVC-encoding
            # Intel x264, QSV x264      h264_qsv     Intel Quicksync hardware-based x264
            # Intel x265, Intel x265    hevc_qsv     Intel Quicksync hardware-based x265
            #   QSV x265, QSV HEVC                   (alternative names)
            # nVidia x264, QSV x264     nvenc_h264   nVidia NVENC hardware-based x264
            # nVidia x265, nVidia x265  nvenc_hevc   nVidia NVENC hardware-based x265
            #   NVENC x265, NVENC HEVC               (alternative names)
            #
            # Note: when not using 'copy' mode, the video stream will not be transcoded if
            # no matching rule requires the stream to be transcoded.  See: config settings
            # for 'videos.transcode.video_*'.
            #
            # Note: when using 'match' mode, if the input video stream is not one of the
            # available codecs, the output codec will be set to x265, chosen for its high
            # efficiency and strong compatibility.
            #
            # Note: Intel Quicksync and nVidia NVENC are subject to hardware support.
            # Ensure that your hardware meets the requirements to encode with these options
            # before using VideoLogic to try ot encode your videos. Additional restrictions
            # apply (for example, CRF is not supported with either QSV or NVENC, only QP).
            ffmpeg.video.codec = NVENC_hevc


            # Rules for when VideoLogic should transcode video streams.  For codecs,
            # multiple values may be used (separate with a space).
            #
            # Note: see also 'video.max_res_movie' and 'video.max_res_tv'
            videos.transcode.video_bitrate_over = 10000000000
            videos.transcode.video_codec =
            videos.transcode.video_codec_not = x265


            # Adjust which codec to use when converting audio.  Allowed values are:
            #
            # config setting   FFMPEG encoding library / notes
            # ---------------  -----------------------------------------------------------
            # copy, none       copy (does not transcode, just copy the stream(s))
            # auto             automatically determine codec to use based on desired
            #                  container and source audio channels
            # match            use the same codec as input (must be one of the below
            #                  options, but will still transcode the audio)
            # AAC              aac
            # AC3              ac3
            # MP3              libmp3lame
            # DTS              dca
            #
            # Note: when not using 'copy' mode, the audio stream will not be transcoded if
            # no matching rule requires the stream to be transcoded.  See: config settings
            # for 'videos.transcode.audio_*'.
            #
            # Note: when using 'match' mode, if the input audio stream is not one of the
            # available codecs, the output codec will be set to AC3, chosen for its high
            # compatibility.
            ffmpeg.audio.codec = auto


            # FFMPEG audio bitrate mode
            #
            # config setting   FFMPEG encoding library / notes
            # ---------------  -----------------------------------------------------------
            # cbr, constant    constant bitrate
            # vbr, qscale,     variable bitrate targeting a quality scale level
            #   quality        this mode will use the qscale settings for AAC and MP3
            #                  codecs (AC3 and DTS do not support VBR and will override
            #                  with CBR)
            ffmpeg.audio.bitrate_mode = constant


            # FFMPEG target audio bitrate PER CHANNEL, not including LFE.  This is not a
            # per-stream setting: VideoLogic will total up the number of channels present
            # in the audio source and multiply by this per-channel bitrate setting to
            # achieve a total constant bitrate (CBR) value during encoding.
            #
            # Example #1:       stereo audio at  64000 will produce a  128kb CBR
            # Example #2: 5.1 surround audio at  51200 will produce a  256kb CBR
            #
            # Note: AAC and MP3 codecs will not use this setting if
            # 'ffmpeg.audio.bitrate_mode' is set to VBR/qscale.
            ffmpeg.audio.aac.bitrate = 128000
            ffmpeg.audio.ac3.bitrate = 128000
            ffmpeg.audio.dts.bitrate = 256000
            ffmpeg.audio.mp3.bitrate = 96000


            # The maximum allowed audio channels you want in your output video.  If the
            # audio is being converted (not copied) and the number of channels exceeds your
            # configured setting, audio will automatically be downmixed (after volume
            # normalization).
            #
            # You may choose to leave this blank (or set it to "auto" or "match") to
            # disable, use "mono" for 1.0, "stereo" for 2.0, or any numeric value to set
            # channels (such as "2.1", "5.1", etc.).
            ffmpeg.audio.channels_max = match


            # The sampling frequency to use when converting audio streams.  If this is not
            # set or set to 0, the output sampling frequency will automatically match the
            # input audio stream's sampling frequency unless the input sampling frequency
            # falls under 44100 Hz, which causes issues in multiple devices.  Specify a
            # value if you want to override this safeguard.
            #
            # Note: this should be set in bits (no shorthand like 44.1K or 48K).
            ffmpeg.audio.freq = match


            # FFMPEG Quality Scaling for VBR mode (audio encoding)
            #
            # See:
            #     https://trac.ffmpeg.org/wiki/Encode/AAC
            #     https://trac.ffmpeg.org/wiki/Encode/MP3
            #     https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
            #
            # Note: AC3 and DTS codecs do not support variable bitrates, so they cannot
            # target a VBR/quality scale level.  'ffmpeg.core.ac3.bitrate' or
            # 'ffmpeg.core.dts.bitrate' will be used for AC3 and DTS codecs.
            #
            # AAC qscale is between 1 to 5.  5 is the best quality and highest VBR.
            # MP3 qscale is between 0 to 9.  0 is the best quality and highest VBR.
            ffmpeg.audio.aac.qscale  = 4
            ffmpeg.audio.mp3.qscale  = 3


            # Languages of audio tracks to keep (in ISO 639-2 three-letter format).
            # "???" or 'und' may be used to denote undetermined or language-not-specified
            # tracks.  Any audio tracks not matching this list will be discarded.  Use
            # 'all' or '*' (or just leave blank) to specify to keep all languages.
            #
            # See: https://www.loc.gov/standards/iso639-2/php/code_list.php
            ffmpeg.audio.keep_langs = eng ???


            # Rules for when VideoLogic should transcode audio streams
            #
            # Note: audio loudness is measured by the 'loudnorm' audio filter as a LU (dB)
            # distance from measured integrated loudness (perceived loudness) per
            # LUFS/LKFS.  If the current audio is not more or less loud by the configured
            # value, it will not trigger that rule.  Set it to 0.0 dB to forcibly
            # normalize all audio.  See also: 'ffmpeg.audio.movie_loudness_normalization'
            # and 'ffmpeg.audio.tv_loudness_normalization'.
            videos.transcode.audio_bitrate_over = 10000000000
            videos.transcode.audio_codec =
            videos.transcode.audio_codec_not = AC3 AAC DTS
            videos.transcode.audio_loudness = 0.3


            # Whether or not to pass the audio through FFMPEG's 'loudnorm' filter, which
            # implements the EBU R128 standard to normalize the perceived loudness of
            # the audio.
            #
            # Note: even when this setting is enabled, loudness normalization will only
            # occur if the config 'ffmpeg.audio.codec' is not set to 'none' or 'copy'
            # and also the amount of loudness variation needs to be higher than the
            # threshold set in config 'videos.transcode.audio_loudness'.
            ffmpeg.audio.movie_loudness_normalization = no
            ffmpeg.audio.tv_loudness_normalization    = yes
            ffmpeg.audio.other_loudness_normalization = no


            # Languages of subtitle tracks to keep (in ISO 639-2 three-letter format).
            # "???" or 'und' may be used to denote undetermined or language-not-specified
            # tracks.  Any subtitle tracks not matching this list will be discarded.  Use
            # 'all' or '*' (or just leave blank) to specify to keep all languages.
            #
            # See: https://www.loc.gov/standards/iso639-2/php/code_list.php
            ffmpeg.subs.keep_langs = *


            # Whether or not to detect loose .srt files that appear to match the video
            # and merge them into the video container.
            ffmpeg.subs.merge_srt = yes


            # Any additional command-line parameters you want VideoLogic to pass to FFMPEG
            # during encoding.
            ##ffmpeg.extra=


            # Threshold for how many minutes long a video must be to be handled as a movie
            # and not a T.V. episode.  This affects conversion/quality settings.
            video.duration_for_movie = 65


            # Threshold for how many minutes long a video must be to be handled as a T.V.
            # episode and not an other/miscellaneous video.  This affects conversion/
            # quality settings.
            video.duration_for_tv = 10
			             # Whether or not to process other videos: videos less than 10 minutes long,
            # by default (configured via 'video.duration_for_tv').  These videos can
            # be skipped or processed.
            video.process_others = no


            # Assign general tune for movies and T.V.  This adjusts how both the x264 and
            # x265/HEVC encoders will treat the source video when transcoding.  Allowed
            # values are:
            #
            # config setting        notes
            # --------------------  ------------------------------------------------------
            # default               x264 tune = (unset), x265 uses settings that appeal to
            #                       all types of video content
            # film                  x264 tune = film, x265 uses settings that target
            #                       general live-action video content
            # animation             x264 tune = animation, x265 uses settings that target
            #                       animated video content like cartoons and anime
            # grain                 x264 tune = grain, x265 uses settings that target
            #                       video content source containing high film grain
            #
            # Note: this option is ignored for hardware-based encoders such as Intel
            # Quicksync and nVidia NVENC.
            video.tune_movie = film
            video.tune_tv    = default
            video.tune_other = default


            # Example: animated shows using a different tune
            ##video.tune_tv_keyword = some cartoon show: animation
            ##video.tune_tv_keyword = some anime show: animation


            # Limit the maximum resolution for videos by scaling (resizing) down any video
            # file that exceeds the maximum.  Allowed values are:
            #
            # resolution     config setting       notes
            # -------------  -------------------  ----------------------------------------
            # no limit       none, no limit       or leave blank
            # 3840x2160      UHD, 2160p, 4K
            # 2592x1080      1458p                for 1080p height with up to 2.4 aspect
            # 1920x1080      HD, HDTV, 1080p
            #  1728x720      972p                 for 720p height with up to 2.4 aspect
            #  1280x720      720p
            #   852x480      SD, SDTV, 480p
            #   720x576      PAL, 576p            this is PAL DVD
            #   720x480      DVD, NTSC            this is NTSC DVD
            video.max_res_movie = 4k
            video.max_res_tv    = 972p
            video.max_res_other = 972p
            # Note: other video max resolution will be set to unlimited by default when
            # VideoLogic is running in single-file processing mode (with command line).


            # Daily-airing shows can be reduced to SDTV quality.
            # Example: daily-airing shows can be reduced to SDTV quality.
            ##video.max_res_tv_keyword = some daily airing show: sdtv


            # Example: other shows can be kept at higher quality
            ##video.max_res_tv_keyword = some high action show: 1080p
            ##video.max_res_tv_keyword = another awesome show: none
            video.max_res_tv_keyword = Penn & Teller, Fool Us: none
            `;




        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            render();
          }
        window.addEventListener('resize', handleResize);

        function convertIni(iniText) {
            const config = {};
            const lines = iniText.split('\n');
            let currentSection = '';

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#') || trimmedLine === '') {
                    continue; //skip comments and empty lines
                }

                if (trimmedLine.startsWith('[')) {
                    currentSection = trimmedLine.slice(1, -1);
                    config[currentSection] = {};
                    continue;
                }

                const eqIndex = trimmedLine.indexOf('=');
                if (eqIndex !== -1) {
                    const key = trimmedLine.slice(0, eqIndex).trim();
                    const value = trimmedLine.slice(eqIndex + 1).trim();
                    config[currentSection][key] = value;
                }
            }
            return config;
        }

        function updateIni(settings) {
            let iniText = '';
            for (const section in settings) {
                iniText += `[${section}]\n`;
                for (const key in settings[section]) {
                    iniText += `${key} = ${settings[section][key]}\n`;
                }
                iniText += '\n';
            }
            return iniText;
        }


        function drawText(x, y, text, align='left', fontSize=16, color='white', bold=false) {
          ctx.fillStyle = color;
          ctx.font = `${bold ? 'bold ' : ''}${fontSize}px sans-serif`;
          ctx.textAlign = align;
          ctx.fillText(text, x, y);
        }


        function drawInput(x, y, width, height, value, isSelect = false, options = ['yes', 'no'] ) {
            ctx.fillStyle = '#444';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = 'white';
           ctx.strokeRect(x, y, width, height)
          if(isSelect){
            drawText(x + 5, y + 20, value, 'left', 14)
          } else {
            drawText(x + 5, y + 20, value, 'left', 14)
          }
            
        }
        function drawButton(x, y, width, height, text){
            ctx.fillStyle = '#007bff';
          ctx.fillRect(x,y,width, height)
           drawText(x + width/2, y + height/2, text, 'center', 16, 'white', true);

        }
        function drawHelpButton(x, y, size = 16){
              ctx.fillStyle = '#007bff';
            drawText(x,y, '?', 'center', size, '#007bff', true)
        }
         function addAssistantMessage(message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add('assistant-message');
            messageElement.textContent = message;
            chatMessages.appendChild(messageElement);
           chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        function addUserMessage(message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add('user-message');
            messageElement.textContent = message;
             chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function fetchAiResponse(message) {
             chatHistory.push({ role: "user", content: message });

             const requestBody = {
                 messages: [
                    { role: "system", content: systemMessage },
                   ...chatHistory,
                 ],
                 model: 'openai',
             };
            try {
                const response = await fetch("https://text.pollinations.ai/openai", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                      ...requestBody,
                    }),
                });
                if (!response.ok) {
                    addAssistantMessage(`Error contacting the AI.`);
                    return;
                }

                const data = await response.text();

                chatHistory.push({ role: "assistant", content: data });

                 addAssistantMessage(data);

            } catch (error) {
               addAssistantMessage(`Error contacting the AI: ${error}`);
            }
        }
          chatSendButton.addEventListener('click', async () => {
            const userMessage = chatInputText.value.trim();
            if (!userMessage) return;

              addUserMessage(userMessage);
              chatInputText.value = '';
              fetchAiResponse(userMessage)
          });
         closeChatButton.addEventListener('click', () => {
             chatPopup.style.display = 'none';
        });


        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let currentY = hudLayout.sectionPadding;
            uiElements = [];

           if(Object.keys(currentSettings).length > 0) {
              for(const section in currentSettings) {
                   drawText(hudLayout.sectionPadding, currentY, section, 'left', 20, 'white', true)
                  currentY += hudLayout.sectionPadding;

                    for (const key in currentSettings[section]) {
                        const inputX = hudLayout.labelWidth + hudLayout.sectionPadding;
                        const inputY = currentY;
                        const isSelect = currentSettings[section][key] === 'yes' || currentSettings[section][key] === 'no'
                         drawText(hudLayout.sectionPadding, currentY + 20, `${key}:`, 'left', 14);

                       drawInput(inputX, inputY, hudLayout.inputWidth, hudLayout.inputHeight, currentSettings[section][key], isSelect)
                        uiElements.push({
                          type:'input',
                          x: inputX,
                          y: inputY,
                          width: hudLayout.inputWidth,
                          height: hudLayout.inputHeight,
                          setting: `${section}.${key}`,
                          value: currentSettings[section][key],
                           isSelect,
                        });
                          drawHelpButton(inputX + hudLayout.inputWidth + 10, inputY+20 )
                            uiElements.push({
                              type:'helpButton',
                               x: inputX + hudLayout.inputWidth + 10,
                             y: inputY+18,
                            size:16,
                            setting: `${section}.${key}`,
                          });

                        currentY += hudLayout.settingPadding + hudLayout.inputHeight;
                    }

                 currentY += hudLayout.settingPadding;
             }
               drawButton(canvasWidth/2 - 75, currentY + 30, 150, 50, "Save INI File")
                  uiElements.push({
                  type: 'saveButton',
                     x:canvasWidth/2 - 75,
                     y: currentY + 30,
                     width: 150,
                     height: 50,
                  })
            } else {
                drawText(canvasWidth/2, canvasHeight/2, "Paste INI text or load a .ini file to start", 'center', 24, 'white')
            }



            requestAnimationFrame(render);
        }
          function getElementAtPosition(mouseX, mouseY){
             for(const uiElement of uiElements){
                if(mouseX >= uiElement.x && mouseX <= uiElement.x + uiElement.width &&
                   mouseY >= uiElement.y && mouseY <= uiElement.y + uiElement.height){
                    return uiElement;
                }
             }
             return null;
           }


         canvas.addEventListener('click', (event) => {
            const mouseX = event.clientX;
            const mouseY = event.clientY;
             const clickedElement = getElementAtPosition(mouseX, mouseY);

             if(clickedElement){
                  if(clickedElement.type === 'input'){
                       const newValue = prompt(`Enter new value for ${clickedElement.setting}:`, clickedElement.value)
                     if(newValue !== null){
                         const [section, key] = clickedElement.setting.split('.');
                       currentSettings[section][key] = newValue;
                       render()
                     }
                   }  else if (clickedElement.type === 'helpButton'){
                         currentHelpSetting = clickedElement.setting;
                          chatPopup.style.display = 'block';
                           chatHistory = [];
                          chatMessages.innerHTML = "";
                           addAssistantMessage("How can I help with " + currentHelpSetting + "?");
                     } else if(clickedElement.type === 'saveButton'){
                          if(Object.keys(currentSettings).length === 0){
                            statusMessage.textContent = 'No settings loaded.';
                              return;
                          }
                            const iniText = updateIni(currentSettings);
                            const blob = new Blob([iniText], { type: 'text/plain' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'VideoLogic.ini';
                            a.click();
                            URL.revokeObjectURL(url);
                            statusMessage.textContent = 'INI File Downloaded.';
                    }
              }
           });


           function loadSettings(iniText) {
              if(!iniText && iniFileInput.files.length === 0) return;
              try {
                   if(iniFileInput.files.length > 0){
                         const file = iniFileInput.files[0];
                           const reader = new FileReader();
                           reader.onload = (event) => {
                               const iniText = event.target.result;
                                currentSettings = convertIni(iniText);
                                 render()
                                 statusMessage.textContent = `Settings Loaded`;
                           }
                         reader.onerror = (error) => {
                                statusMessage.textContent = `Error reading file: ${error}`
                            }
                           reader.readAsText(file)
                      } else if(iniText){
                        currentSettings = convertIni(iniText);
                         render()
                        statusMessage.textContent = `Settings Loaded`;
                     }

              } catch (error) {
                   statusMessage.textContent = `Error reading settings`
              }
           }
             window.addEventListener('load', () => {
               handleResize();
              pasteText.addEventListener('change', (e) => {
                loadSettings(e.target.value)
              });
              iniFileInput.addEventListener('change', () => {
                loadSettings(null);
              });

              render();
            });
    </script>
</body>

</html>