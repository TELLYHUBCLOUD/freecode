<html><head><base href="https://pollistream.live">
    <title>POLLISTREAM.LIVE - AI Image Stream Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0f0f0f;
            color: #fff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            margin-bottom: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
        }

        .instructions {
            color: #888;
        }

        .status {
            font-weight: bold;
            color: #4aff4a;
        }

        .container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            padding: 0 20px;
        }

        #slideshow {
            width: 896px;
            height: 896px;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }

        #slideshow img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #gridContainer {
            display: grid;
            grid-template-columns: repeat(8, 112px);
            grid-template-rows: repeat(8, 112px);
            gap: 4px;
            background: #1a1a1a;
            padding: 8px;
            border-radius: 8px;
        }

        .grid-tile {
            width: 112px;
            height: 112px;
            background: #2a2a2a;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .grid-tile:hover {
            transform: scale(1.05);
        }

        .grid-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">POLLISTREAM.LIVE</div>
        <div class="instructions">Click to Pause & View Single Image</div>
        <div class="status" id="status">STREAM ACTIVE</div>
    </div>
    <div class="container">
        <div id="slideshow"></div>
        <div id="gridContainer"></div>
    </div>

    <script>
        const init = () => {
            const GRID_SIZE = 8;
            const TOTAL_TILES = GRID_SIZE * GRID_SIZE;
            const DISPLAY_DURATION = 5000;
            const PAUSE_DURATION = 5000;
            const MAX_QUEUE_SIZE = 64;
            const URL_COMPARE_LENGTH = 200;

            const gridContainer = document.getElementById('gridContainer');
            const slideshow = document.getElementById('slideshow');
            const statusEl = document.getElementById('status');

            let tiles = [];
            let currentPosition = 0;
            let displayedUrls = new Set();
            let imageQueue = [];
            let isPaused = false;
            let currentImage = null;
            let resumeTimeout = null;
            let displayTimeout = null;
            let lastDisplayTime = 0;

            // Create grid tiles
            for (let i = 0; i < TOTAL_TILES; i++) {
                const tile = document.createElement('div');
                tile.className = 'grid-tile';
                gridContainer.appendChild(tile);
                tiles.push(tile);
            }

            const inappropriateKeywords = [
                'child', 'kid', 'minor', 'underage', 'young girl', 'young boy',
                'loli', 'shota', 'teen', 'toddler', 'baby', 'infant', 'tween',
                'adolescent', 'juvenile', 'schoolgirl', 'schoolboy',
                'innocent', 'pure', 'untouched', 'virgin', 'corrupted',
                'nude', 'naked', 'explicit', 'pornographic', 'lewd', 'obscene',
                'seductive', 'provocative', 'sultry', 'sensual', 'erotic',
                'exploited', 'abused', 'groomed', 'trafficked',
                'jailbait', 'cp', 'childp*rn', 'pedo',
                'barely legal', 'jailbait', 'nymphet', 'cherub',
                'daddy', 'mommy', 'uncle', 'aunt', 'stepdaughter', 'stepson',
                'playground', 'school', 'daycare', 'orphanage'
            ];

            function containsInappropriateContent(text) {
                text = text.toLowerCase();
                return inappropriateKeywords.some(keyword => text.includes(keyword.toLowerCase()));
            }

            function isDuplicate(newUrl) {
                const compareStr = newUrl.substring(0, URL_COMPARE_LENGTH);
                return Array.from(displayedUrls).some(url => 
                    url.substring(0, URL_COMPARE_LENGTH) === compareStr
                );
            }

            async function loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            function updateSlideshow(img) {
                if (currentImage) {
                    slideshow.removeChild(currentImage);
                }
                slideshow.appendChild(img);
                currentImage = img;
            }

            async function displayImage(imageURL) {
                try {
                    const img = await loadImage(imageURL);
                    
                    // Update slideshow
                    const slideshowImg = img.cloneNode();
                    updateSlideshow(slideshowImg);

                    // Update grid
                    const tile = tiles[currentPosition];
                    const tileImg = img.cloneNode();
                    
                    tileImg.addEventListener('click', () => {
                        if (!isPaused) {
                            pauseStream(imageURL);
                        }
                    });

                    while (tile.firstChild) {
                        tile.removeChild(tile.firstChild);
                    }
                    
                    tile.appendChild(tileImg);
                    currentPosition = (currentPosition + 1) % TOTAL_TILES;

                    displayedUrls.add(imageURL);
                    if (displayedUrls.size > TOTAL_TILES) {
                        const oldestUrl = Array.from(displayedUrls)[0];
                        displayedUrls.delete(oldestUrl);
                    }

                    lastDisplayTime = Date.now();
                    return true;
                } catch (error) {
                    console.error('Error loading image:', error);
                    return false;
                }
            }

            async function processNextImage() {
                if (imageQueue.length === 0 || isPaused) return;

                const currentTime = Date.now();
                const timeSinceLastDisplay = currentTime - lastDisplayTime;
                
                if (timeSinceLastDisplay < DISPLAY_DURATION) {
                    displayTimeout = setTimeout(processNextImage, DISPLAY_DURATION - timeSinceLastDisplay);
                    return;
                }

                const imageURL = imageQueue.shift();
                const success = await displayImage(imageURL);
                
                if (success) {
                    if (displayTimeout) {
                        clearTimeout(displayTimeout);
                    }
                    displayTimeout = setTimeout(processNextImage, DISPLAY_DURATION);
                } else {
                    processNextImage();
                }
            }

            function resumeStream() {
                isPaused = false;
                statusEl.textContent = 'STREAM ACTIVE';
                statusEl.style.color = '#4aff4a';
                processNextImage();
            }

            function pauseStream(imageSrc) {
                isPaused = true;
                statusEl.textContent = 'STREAM PAUSED';
                statusEl.style.color = '#ff4a4a';
                
                if (resumeTimeout) clearTimeout(resumeTimeout);
                if (displayTimeout) clearTimeout(displayTimeout);

                displayImage(imageSrc).then(() => {
                    resumeTimeout = setTimeout(resumeStream, PAUSE_DURATION);
                });
            }

            function connectToFeed() {
                statusEl.textContent = 'Connecting...';
                const evtSource = new EventSource('https://image.pollinations.ai/feed?past_results=0');
                
                evtSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.imageURL && data.prompt) {
                            if (!containsInappropriateContent(data.prompt) && !isDuplicate(data.imageURL)) {
                                if (imageQueue.length >= MAX_QUEUE_SIZE) {
                                    imageQueue.shift();
                                }
                                imageQueue.push(data.imageURL);
                                if (!isPaused && imageQueue.length === 1) {
                                    processNextImage();
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };

                evtSource.onopen = function() {
                    statusEl.textContent = 'STREAM ACTIVE';
                    statusEl.style.color = '#4aff4a';
                };

                evtSource.onerror = function(err) {
                    console.error('EventSource failed:', err);
                    statusEl.textContent = 'CONNECTION LOST';
                    statusEl.style.color = '#ff4a4a';
                    evtSource.close();
                    setTimeout(connectToFeed, 5000);
                };
            }

            // Start the feed
            connectToFeed();
        };

        // Wait for DOM to be ready then initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body></html>