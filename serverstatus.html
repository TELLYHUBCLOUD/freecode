<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Services Status</title>
    <style>
	:root {
		--bg-primary: #1a1b1e;
		--bg-secondary: #2a2b2e;
		--text-primary: #e1e1e1;
		--text-secondary: #a0a0a0;
		--border: #404040;
		--success: #059669;
		--success-bg: #064e3b;
		--error: #dc2626;
		--error-bg: #7f1d1d;
		--warning: #d97706;
		--warning-bg: #78350f;
	}

	* {
		box-sizing: border-box;
		margin: 0;
		padding: 0;
	}

	body {
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
		line-height: 1.6;
		padding: 20px;
		background-color: var(--bg-primary);
		color: var(--text-primary);
	}

	.container {
		max-width: 1120px;  
		margin: 0 auto;
		height: calc(100vh - 72px);
		font-size: 0.9rem;  
	}

	.header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-top: 40px;
		padding-top: 40px;
		margin-bottom: 20px;
		padding-bottom: 20px;
		border-bottom: 1px solid var(--border);
	}

	.tabs {
		display: flex;
		gap: 10px;
		margin-bottom: 20px;
	}

	.tab {
		padding: 8px 16px;
		background: var(--bg-secondary);
		border: 1px solid var(--border);
		border-radius: 4px;
		cursor: pointer;
		color: var(--text-primary);
	}

	.tab.active {
		background: #3b82f6;
		color: white;
		border-color: #2563eb;
	}

	.tab-content {
		display: none;
	}

	.tab-content.active {
		display: block;
	}

	.services-grid {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 12px;
		padding: 0 4px;
	}

	.service-card {
		background: var(--bg-secondary);
		border-radius: 6px;
		padding: 12px;
		border: 1px solid var(--border);
		display: flex;
		justify-content: space-between;
		align-items: center;
		font-size: 0.9rem;
	}

	.service-info {
		flex-grow: 1;
	}

	.service-meta {
		font-size: 0.875rem;
		color: var(--text-secondary);
	}

	.status-badge {
		padding: 6px 12px;
		border-radius: 999px;
		font-size: 0.875rem;
		font-weight: 500;
	}

	.status-online {
		background: var(--success-bg);
		color: #86efac;
	}

	.status-offline {
		background: var(--error-bg);
		color: #fca5a5;
	}

	.status-error {
		background: var(--warning-bg);
		color: #fcd34d;
	}

	.status-pending {
		background: var(--bg-primary);
		color: var(--text-secondary);
	}

	.log-container {
		background: var(--bg-secondary);
		color: var(--text-primary);
		padding: 12px;
		border-radius: 6px;
		height: 480px;
		overflow-y: auto;
		font-family: 'Fira Code', monospace;
		border: 1px solid var(--border);
	}

	.log-entry {
		margin-bottom: 12px;
		border-bottom: 1px solid var(--border);
		padding-bottom: 12px;
		white-space: pre-wrap;
		font-size: 14px;
	}

	.log-time {
		color: #888;
	}

	.log-service {
		color: #4ec9b0;
	}

	.log-method {
		color: #569cd6;
	}

	.log-url {
		color: #ce9178;
	}

	.log-status {
		color: #569cd6;
	}

	.log-error {
		color: #f44747;
	}

	.log-request {
		color: #9cdcfe;
	}

	.log-response {
		color: #4ec9b0;
	}

	.last-update {
		font-size: 0.875rem;
		color: var(--text-secondary);
	}

	.expand-button {
		background: none;
		border: none;
		color: #569cd6;
		cursor: pointer;
		font-family: inherit;
		padding: 0;
		margin-left: 8px;
	}

	.details {
		margin-top: 8px;
		padding-left: 16px;
		display: none;
	}

	.details.show {
		display: block;
	}

	.test-btn {
		background-color: #3b82f6;
		color: white;
		border: none;
		padding: 4px 8px;
		border-radius: 4px;
		margin-left: 8px;
		cursor: pointer;
	}

	.test-btn:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.test-modal {
		display: none;
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: rgba(0, 0, 0, 0.8);
		z-index: 1000;
	}

	.modal-content {
		position: fixed;
		top: 20%;
		left: 20%;
		right: 20%;
		bottom: 20%;
		background: var(--bg-secondary);
		padding: 20px;
		border-radius: 8px;
		resize: both;
		overflow: hidden;
		min-width: 300px;
		min-height: 400px;
		display: flex;
		flex-direction: column;
	}

	.modal-content.fullscreen {
		top: 72px;
		left: 0;
		right: 0;
		bottom: 0;
		resize: none;
		border-radius: 0;
		padding: 20px 40px;
	}

	.modal-content.fullscreen .chat-container {
		max-width: 1120px;
		width: 100%;
		margin: 0 auto;
	}

	.modal-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 10px;
	}

	.modal-controls {
		display: flex;
		gap: 10px;
	}

	.modal-btn {
		background: none;
		border: none;
		color: white;
		font-size: 20px;
		cursor: pointer;
		padding: 4px;
		display: flex;
		align-items: center;
		justify-content: center;
		width: 30px;
		height: 30px;
		border-radius: 4px;
	}

	.modal-btn:hover {
		background: rgba(255, 255, 255, 0.1);
	}

	.modal-tabs {
		display: flex;
		gap: 10px;
		margin-bottom: 10px;
	}

	.modal-tab {
		padding: 8px 16px;
		background: var(--bg-secondary);
		border: 1px solid var(--border);
		border-radius: 4px;
		cursor: pointer;
		color: var(--text-primary);
	}

	.modal-tab.active {
		background: #3b82f6;
		color: white;
		border-color: #2563eb;
	}

	.chat-area {
		flex: 1;
		overflow-y: auto;
		margin: 0;
		padding: 16px;
		background: var(--bg-primary);
		border: 1px solid var(--border);
		border-radius: 4px;
		min-height: 0;  /* Critical for nested flex scroll */
	}

	.chat-message {
		margin: 8px 0;
		padding: 8px;
		border-radius: 4px;
		white-space: pre-wrap;
		width: fit-content;
	}

	.user-message {
		background: #1e40af;
		color: white;
		margin-left: auto;
	}

	.bot-message {
		background: #065f46;
		color: white;
	}

	.chat-container {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 16px;
		max-height: calc(100% - 40px); /* Leave room for header */
		overflow: hidden;  /* Important! Contains the flex items */
	}

	.chat-input-area {
		position: relative;
		width: 100%;
		min-height: 48px;
	}

	.chat-input {
		width: 100%;
		height: 48px;
		padding: 12px;
		padding-right: 48px;
		border-radius: 4px;
		border: 1px solid var(--border);
		background: var(--bg-primary);
		color: var(--text-primary);
		font-size: 1rem;
	}

	.send-button {
		position: absolute;
		right: 4px;
		top: 4px;
		bottom: 4px;
		width: 40px;
		background: #3b82f6;
		border: none;
		border-radius: 4px;
		color: white;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.replay-btn {
		background: none;
		border: none;
		color: rgba(255, 255, 255, 0.7);
		cursor: pointer;
		font-size: 14px;
		padding: 4px;
		margin-left: 8px;
		opacity: 0.7;
		transition: opacity 0.2s;
	}

	.replay-btn:hover {
		opacity: 1;
	}

	.bot-message {
		display: flex;
		align-items: center;
	}

	#voice-btn {
		font-size: 16px;
	}

	.persona-config {
		display: flex;
		gap: 10px;
		align-items: center;
		margin-bottom: 10px;
		padding: 8px;
		background: var(--bg-secondary);
		border-radius: 4px;
	}

	.persona-select {
		padding: 6px;
		border-radius: 4px;
		background: #374151;
		color: white;
		border: 1px solid #4b5563;
	}

	.persona-label {
		color: var(--text-secondary);
		font-size: 0.9rem;
	}

	.modal-btn[title="Clear History"] {
		font-size: 16px;
	}

	.modal-btn[title="Clear History"]:hover {
		color: var(--error);
	}

	.modal-header, 
	.modal-tabs,
	.persona-config,
	.chat-input-area {
		flex-shrink: 0 !important;  /* Prevent these from shrinking */
	}	

	.voice-switch {
		position: relative;
		display: inline-block;
		width: 40px;
		height: 20px;
		margin: 0 5px;
	}

	.voice-switch input {
		opacity: 0;
		width: 0;
		height: 0;
	}

	.slider {
		position: absolute;
		cursor: pointer;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background-color: #065f46;
		transition: .4s;
		border-radius: 20px;
	}

	.slider:before {
		position: absolute;
		content: "";
		height: 16px;
		width: 16px;
		left: 2px;
		bottom: 2px;
		background-color: white;
		transition: .4s;
		border-radius: 50%;
	}

	input:checked + .slider {
		background-color: #1e40af;
	}

	input:checked + .slider:before {
		transform: translateX(20px);
	}
		
    </style>
</head>
<body>
<script src="/js/nav-loader.js"></script>
    <div class="container">
        <div class="header">
            <h1>AI Services Status</h1>
            <div class="last-update">Last updated: <span id="lastUpdate">Never</span></div>
        </div>

        <div class="tabs">
            <button class="tab active" data-tab="status">Status</button>
            <button class="tab" data-tab="logs">Logs</button>
        </div>

        <div class="tab-content active" id="statusTab">
            <div class="services-grid" id="servicesGrid"></div>
        </div>

        <div class="tab-content" id="logsTab">
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

	<div id="test-modal" class="test-modal">
	  <div class="modal-content">
		<div class="modal-header">
		  <h3 id="modal-title" style="color: white; margin: 0;"></h3>
			<div class="modal-controls">
				<button onclick="clearHistory()" class="modal-btn" title="Clear History">üóëÔ∏è</button>
				<label class="voice-switch" title="Toggle Voice Gender">
					<input type="checkbox" ${useZiraVoice ? 'checked' : ''} onchange="toggleVoiceGender(this.checked)">
					<span class="slider"></span>
				</label>
				<button onclick="toggleVoice()" class="modal-btn" id="voice-btn">üîá</button>
				<button onclick="toggleFullscreen()" class="modal-btn">‚õ∂</button>
				<button onclick="closeTestModal()" class="modal-btn">√ó</button>
			</div>
		</div>
		<div class="chat-container">
		  <div class="modal-tabs">
			<button class="modal-tab active" id="modal-chat-tab" onclick="switchModalTab('chat')">Chat</button>
			<button class="modal-tab" id="modal-logs-tab" onclick="switchModalTab('logs')">Logs</button>
		  </div>
		  
		  <div style="display: flex; flex-direction: column; margin-bottom: 10px;">
			<textarea id="system-message" class="chat-input" style="height: 50px;" placeholder="Enter your persona message here"></textarea>
		  </div>
		  
		  <div id="chat-area" class="chat-area"></div>
		  <div id="logs-area" class="chat-area" style="display: none; font-family: monospace; white-space: pre-wrap;"></div>
		  <div class="chat-input-area">
			<input type="text" id="chat-input" class="chat-input" placeholder="Type a message...">
			<button onclick="sendMessage()" class="send-button" id="send-button">‚û§</button>
		  </div>
		</div>
	  </div>
	</div>

<script>
	let beesknees = "beesknees";
    let services = [
        {"name":"openai","type":"chat","censored":true,"description":"OpenAI GPT-4o","baseModel":true},
        {"name":"qwen","type":"chat","censored":true,"description":"Qwen 2.5 72B","baseModel":true},
        {"name":"qwen-coder","type":"chat","censored":true,"description":"Qwen 2.5 Coder 32B","baseModel":true},
        {"name":"llama","type":"chat","censored":false,"description":"Llama 3.3 70B","baseModel":true},
        {"name":"mistral","type":"chat","censored":false,"description":"Mistral Nemo","baseModel":true},
        {"name":"unity","type":"chat","censored":false,"description":"Unity with Mistral Large by Unity AI Lab","baseModel":false},
        {"name":"midijourney","type":"chat","censored":true,"description":"Midijourney musical transformer","baseModel":false},
        {"name":"rtist","type":"chat","censored":true,"description":"Rtist image generator by @bqrio","baseModel":false},
        {"name":"searchgpt","type":"chat","censored":true,"description":"SearchGPT with realtime news and web search","baseModel":false},
        {"name":"evil","type":"chat","censored":false,"description":"Evil Mode - Experimental","baseModel":false},
        {"name":"p1","type":"chat","censored":false,"description":"Pollinations 1 (OptiLLM)","baseModel":false},
        {"name":"deepseek","type":"chat","censored":true,"description":"DeepSeek-V3","baseModel":true}
    ];

		services = services.map(service => ({
			...service,
			personaConfig: {
				method: localStorage.getItem(`${service.name}-persona-method`) || 'system',
				message: localStorage.getItem(`${service.name}-persona-message`) || ''
			}
		}));

	function addTestButton(modelCard, model) {
		const testBtn = document.createElement('button');
		testBtn.className = 'test-btn';
		testBtn.textContent = 'Test';
		testBtn.onclick = () => openTestModal(model);
		modelCard.appendChild(testBtn);
	}

	let currentModel = null;
	let chatHistory = {};
	let systemMessages = {};
	let summarizedHistory = {};
	let voiceEnabled = false;
	let speechSynthesis = window.speechSynthesis;
	let voices = [];
	let currentUtterance = null;
	let useZiraVoice = localStorage.getItem('useZiraVoice') !== 'false'; // defaults to true


	function openTestModal(model) {
		currentModel = model;
		const modal = document.getElementById('test-modal');
		const title = document.getElementById('modal-title');
		const chatArea = document.getElementById('chat-area');
		const logsArea = document.getElementById('logs-area');
		const systemMessageInput = document.getElementById('system-message');
		const url = `https://text.pollinations.ai/`;
					
		// Load saved history first
		loadHistory();
		
		// Initialize if no history exists
		if (!chatHistory[model.name]) {
			chatHistory[model.name] = [];
		}
		
		// Display existing messages
		chatArea.innerHTML = '';
		chatHistory[model.name].forEach(msg => {
			const msgDiv = document.createElement('div');
			msgDiv.className = `chat-message ${msg.role === 'user' ? 'user-message' : 'bot-message'}`;
			msgDiv.textContent = msg.content || msg.response;
			if (msg.role === 'assistant' || msg.response) {
				addReplayButton(msgDiv, msg.content || msg.response);
			}
			chatArea.appendChild(msgDiv);
		});
		
		// Add persona method selector
		const personaConfig = document.createElement('div');
		personaConfig.className = 'persona-config';
		personaConfig.innerHTML = `
			<label class="persona-label">Persona Delivery Method:</label>
			<select class="persona-select" id="persona-method">
				<option value="system">System Role</option>
				<option value="context">Context Prefix</option>
				<option value="content">Content Role</option>
				<option value="prepend">Prepend to User Message</option>
			</select>
		`;
		
		// Insert before system message
		const existingConfig = document.querySelector('.persona-config');
		if (existingConfig) {
			existingConfig.remove();
		}

		const systemMessageContainer = systemMessageInput.parentElement;
		if (systemMessageContainer) {
			systemMessageContainer.insertBefore(personaConfig, systemMessageInput);
		}
		
		// Set saved method
		const methodSelect = document.getElementById('persona-method');
		if (model.personaConfig && model.personaConfig.method) {
			methodSelect.value = model.personaConfig.method;
		}
		
		// Load saved message
		if (model.personaConfig && model.personaConfig.message) {
			systemMessageInput.value = model.personaConfig.message;
		} else {
			systemMessageInput.value = '';
		}
		
		title.textContent = model.description;
		chatArea.innerHTML = '';
		logsArea.innerHTML = '';
		
		//Initialize chat history for this model
		if (!chatHistory[model.name]) {
			chatHistory[model.name] = [];
		}
		
		// Switch to chat tab
		switchModalTab('chat');
		modal.style.display = 'block';
		
		// Save method when changed
		methodSelect.addEventListener('change', () => {
			model.personaConfig.method = methodSelect.value;
			localStorage.setItem(`${model.name}-persona-method`, methodSelect.value);
		});
		
		// Save message when changed
		systemMessageInput.addEventListener('change', () => {
			model.personaConfig.message = systemMessageInput.value;
			localStorage.setItem(`${model.name}-persona-message`, systemMessageInput.value);
		});
	}

	// Add an event handler to cancel speech when modal closes
	function closeTestModal() {
		document.getElementById('test-modal').style.display = 'none';
		currentModel = null;
		speechSynthesis.cancel();  // Stop any ongoing speech
	}

	// Handle window blur/focus
	window.addEventListener('blur', () => {
		if (speechSynthesis.speaking) {
			speechSynthesis.pause();
		}
	});

	window.addEventListener('focus', () => {
		if (speechSynthesis.paused) {
			speechSynthesis.resume();
		}
	});

	function loadHistory() {
		try {
			const savedHistory = localStorage.getItem('chatHistory');
			if (savedHistory) {
				chatHistory = JSON.parse(savedHistory);
			}
			// Load voice preference
			voiceEnabled = localStorage.getItem('voiceEnabled') === 'true';
			const voiceBtn = document.getElementById('voice-btn');
			if (voiceBtn) {
				voiceBtn.textContent = voiceEnabled ? 'üîä' : 'üîá';
			}
		} catch (error) {
			console.error('Error loading chat history:', error);
			chatHistory = {};
		}
	}

	function saveHistory() {
		try {
			localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
			localStorage.setItem('voiceEnabled', voiceEnabled);
		} catch (error) {
			console.error('Error saving chat history:', error);
		}
	}

	function clearHistory() {
		if (!currentModel) return;
		
		chatHistory[currentModel.name] = [];
		saveHistory();
		
		const chatArea = document.getElementById('chat-area');
		chatArea.innerHTML = '';
	}

	function toggleFullscreen() {
		const modalContent = document.querySelector('.modal-content');
		const fullscreenButton = document.querySelector('.modal-controls .modal-btn');
		
		if (modalContent.classList.contains('fullscreen')) {
			modalContent.classList.remove('fullscreen');
			fullscreenButton.textContent = '‚õ∂';  // Maximize icon
		} else {
			modalContent.classList.add('fullscreen');
			fullscreenButton.textContent = '‚Æã';  // Minimize icon
		}
	}

	function toggleVoiceGender(useZira) {
		useZiraVoice = useZira;
		localStorage.setItem('useZiraVoice', useZira);
	}

	function switchModalTab(tab) {
		const chatArea = document.getElementById('chat-area');
		const logsArea = document.getElementById('logs-area');
		const chatTab = document.getElementById('modal-chat-tab');
		const logsTab = document.getElementById('modal-logs-tab');
		
		if (tab === 'chat') {
			chatArea.style.display = 'block';
			logsArea.style.display = 'none';
			chatTab.classList.add('active');
			logsTab.classList.remove('active');
		} else {
			chatArea.style.display = 'none';
			logsArea.style.display = 'block';
			chatTab.classList.remove('active');
			logsTab.classList.add('active');
		}
	}

	function logToModal(data) {
		const logsArea = document.getElementById('logs-area');
		let logEntry = '';
		
		switch(data.type) {
			case 'REQUEST':
				logEntry = `[${new Date(data.timestamp).toLocaleTimeString()}] REQUEST\n`;
				logEntry += `URL: ${data.url}\n`;
				logEntry += `Method: ${data.method}\n`;
				logEntry += `Body:\n${JSON.stringify(data.body, null, 2)}\n\n`;
				break;
			case 'RESPONSE':
				logEntry = `[${new Date(data.timestamp).toLocaleTimeString()}] RESPONSE\n`;
				logEntry += `Status: ${data.status}\n`;
				logEntry += `Body:\n${data.body}\n\n`;
				break;
			case 'ERROR':
				logEntry = `[${new Date(data.timestamp).toLocaleTimeString()}] ERROR\n`;
				logEntry += `Message: ${data.message}\n`;
				if (data.stack) {
					logEntry += `Stack:\n${data.stack}\n`;
				}
				logEntry += '\n';
				break;
		}
		
		logsArea.innerHTML += logEntry;
		logsArea.scrollTop = logsArea.scrollHeight;
	}

	// Helper function to manage conversation history
	async function manageHistory(modelName, messages, maxExchanges = 10) {
		const currentLength = messages.length;
		
		// If under our threshold, return as is
		if (currentLength <= maxExchanges * 2) {  // *2 because each exchange has user+assistant
			return messages;
		}

		// Split messages into recent and old
		const recentMessages = messages.slice(-maxExchanges * 2);
		const oldMessages = messages.slice(0, -maxExchanges * 2);

		// If we haven't summarized these old messages before
		if (!summarizedHistory[modelName] || 
			summarizedHistory[modelName].originalLength !== oldMessages.length) {
			
			try {
				// Create and send summary request correctly
				const response = await fetch('https://text.pollinations.ai/', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						messages: [{
							role: 'user',
							content: 'Summarize the key points from this conversation history in 1-2 sentences, focusing on established context and important decisions: ' + 
									oldMessages.map(m => `${m.role}: ${m.content}`).join('\n')
						}],
						model: modelName,  // Use modelName not currentModel.name
						code: beesknees,
						jsonMode: false
					})
				});

				const summary = await response.text();

				// Store the summary and original length
				summarizedHistory[modelName] = {
					summary: summary,
					originalLength: oldMessages.length
				};

				// Return summary + recent messages
				return [
					{
						role: 'system',
						content: `Previous conversation context: ${summary}`
					},
					...recentMessages
				];

			} catch (error) {
				console.error('Failed to generate summary:', error);
				// On error, just trim old messages without summary
				return recentMessages;
			}
		}

		// If we already have a valid summary, return it with recent messages
		return [
			{
				role: 'system',
				content: `Previous conversation context: ${summarizedHistory[modelName].summary}`
			},
			...recentMessages
		];
	}

	async function sendMessage() {
		if (!currentModel) return;
		
		const input = document.getElementById('chat-input');
		const chatArea = document.getElementById('chat-area');
		const text = input.value.trim();
		const personaMessage = document.getElementById('system-message').value.trim();
		const personaMethod = document.getElementById('persona-method').value;
		
		if (!text) return;

		// Add user message to chat
		const userMsg = document.createElement('div');
		userMsg.className = 'chat-message user-message';
		userMsg.textContent = text;
		chatArea.appendChild(userMsg);

		// Initialize messages array
		let messages = [];

		// Handle message construction differently for non-base models
		if (!currentModel.baseModel) {
			// For models like 'evil', embed context directly in user message
			if (chatHistory[currentModel.name].length === 0) {
				// First message in conversation
				messages.push({ 
					role: 'user', 
					content: personaMessage ? 
						`CONTEXT: ${personaMessage}\nUSER: ${text}` : 
						text
				});
			} else {
				// Get recent history (last 10 exchanges)
				const recentHistory = chatHistory[currentModel.name].slice(-10);
				const oldHistory = chatHistory[currentModel.name].slice(0, -10);

				// If we have old history that needs summarizing
				if (oldHistory.length > 0 && (!summarizedHistory[currentModel.name] || 
					summarizedHistory[currentModel.name].originalLength !== oldHistory.length)) {
					
					// Create summary request
					const summaryRequest = {
						messages: [{ 
							role: 'user', 
							content: 'Summarize this conversation context in 1-2 sentences: ' + 
									oldHistory.map(ex => `User: ${ex.content}\nAssistant: ${ex.response}`).join('\n')
						}],
						model: currentModel.name,
						code: beesknees,
						jsonMode: false
					};

					try {
						const summaryResponse = await fetch('https://text.pollinations.ai/', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify(summaryRequest)
						});
						
						const summary = await summaryResponse.text();
						summarizedHistory[currentModel.name] = {
							summary: summary,
							originalLength: oldHistory.length
						};
					} catch (error) {
						console.error('Failed to generate summary:', error);
					}
				}

				// First message gets context and summary if available
				let contextPart = personaMessage ? `CONTEXT: ${personaMessage}\n` : '';
				if (summarizedHistory[currentModel.name]) {
					contextPart += `PREVIOUS CONTEXT: ${summarizedHistory[currentModel.name].summary}\n`;
				}
				
				messages.push({
					role: 'user',
					content: contextPart + `USER: ${recentHistory[0].content}`
				});
				messages.push({ role: 'assistant', content: recentHistory[0].response });

				// Add remaining recent history
				for (let i = 1; i < recentHistory.length; i++) {
					messages.push({ role: 'user', content: recentHistory[i].content });
					messages.push({ role: 'assistant', content: recentHistory[i].response });
				}

				// Add current message
				messages.push({ role: 'user', content: text });
			}
		} else {
			// For base models, handle history similarly
			const recentHistory = chatHistory[currentModel.name].slice(-20); // Last 10 exchanges (20 messages)
			const oldHistory = chatHistory[currentModel.name].slice(0, -20);

			// If we have old history that needs summarizing
			if (oldHistory.length > 0 && (!summarizedHistory[currentModel.name] || 
				summarizedHistory[currentModel.name].originalLength !== oldHistory.length)) {
				
				const summaryRequest = {
					messages: [{ 
						role: 'user', 
						content: 'Summarize this conversation context in 1-2 sentences: ' + 
								oldHistory.map(m => `${m.role}: ${m.content}`).join('\n')
					}],
					model: currentModel.name,
					code: beesknees,
					jsonMode: false
				};

				try {
					const summaryResponse = await fetch('https://text.pollinations.ai/', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(summaryRequest)
					});
					
					const summary = await summaryResponse.text();
					summarizedHistory[currentModel.name] = {
						summary: summary,
						originalLength: oldHistory.length
					};
				} catch (error) {
					console.error('Failed to generate summary:', error);
				}
			}

			// Add system/persona message if needed
			switch (personaMethod) {
				case 'system':
					if (personaMessage) {
						messages.push({ role: 'system', content: personaMessage });
					}
					break;
					
				case 'content':
					if (personaMessage) {
						messages.push({ role: 'content', content: personaMessage });
					}
					break;
			}

			// Add summary if available
			if (summarizedHistory[currentModel.name]) {
				messages.push({ 
					role: 'system', 
					content: `Previous conversation context: ${summarizedHistory[currentModel.name].summary}`
				});
			}

			// Add recent history
			messages.push(...recentHistory);
			
			// Add current message with appropriate persona method
			switch (personaMethod) {
				case 'system':
				case 'content':
					messages.push({ role: 'user', content: text });
					break;
					
				case 'context':
					messages.push({ role: 'user', content: personaMessage ? 
						`CONTEXT: ${personaMessage}\n${text}` : text });
					break;
					
				case 'prepend':
					messages.push({ role: 'user', content: personaMessage ? 
						`${personaMessage}\n${text}` : text });
					break;
			}
		}

		input.value = '';
		input.disabled = true;

		const requestData = {
			messages: messages,
			model: currentModel.name,
			code: beesknees,
			jsonMode: false,
			seed: Math.floor(Math.random() * 2147483647)  // Max 32-bit integer
		};
			
		logToModal({
			type: 'REQUEST',
			timestamp: new Date().toISOString(),
			url: 'https://text.pollinations.ai/',
			method: 'POST',
			body: requestData
		});
			
		try {
			const response = await fetch('https://text.pollinations.ai/', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					messages: messages,
					model: currentModel.name,
					code: beesknees,  // Here in the body where it belongs
					jsonMode: false
				})
			
			const result = await response.text();
			
			logToModal({
				type: 'RESPONSE',
				timestamp: new Date().toISOString(),
				status: response.status,
				body: result
			});
			
			// Add bot message
			const botMsg = document.createElement('div');
			botMsg.className = 'chat-message bot-message';
			botMsg.textContent = result;
			addReplayButton(botMsg, result);
			chatArea.appendChild(botMsg);

			if (voiceEnabled) {
				speak(result);
			}
	
			// Update chat history based on model type
			if (!currentModel.baseModel) {
				chatHistory[currentModel.name].push({
					content: text,
					response: result
				});
			} else {
				chatHistory[currentModel.name].push({ role: 'user', content: text });
				chatHistory[currentModel.name].push({ role: 'assistant', content: result });
			}
			saveHistory();
			
			chatArea.scrollTop = chatArea.scrollHeight;
		} catch (error) {
			console.error('Error:', error);
			const errorMsg = document.createElement('div');
			errorMsg.className = 'chat-message';
			errorMsg.textContent = 'Error sending message. Please try again.';
			errorMsg.style.color = '#ef4444';
			chatArea.appendChild(errorMsg);
			
			logToModal({
				type: 'ERROR',
				timestamp: new Date().toISOString(),
				message: error.message,
				stack: error.stack
			});
		}
			
		input.disabled = false;
		input.focus();
	}

	function toggleVoice() {
		voiceEnabled = !voiceEnabled;
		const voiceBtn = document.getElementById('voice-btn');
		voiceBtn.textContent = voiceEnabled ? 'üîä' : 'üîá';
	}

	function speak(text) {
		if (!voiceEnabled || !text) return;
		
		speechSynthesis.cancel();
		text = text.replace(/\*[^*]*\*/g, '');
		
		const utterance = new SpeechSynthesisUtterance(text);
		const voices = speechSynthesis.getVoices();
		
		if (useZiraVoice) {
			const zira = voices.find(v => v.name.includes('Zira'));
			if (zira) utterance.voice = zira;
		} else {
			const david = voices.find(v => v.name.includes('David'));
			if (david) utterance.voice = david;
		}
		
		speechSynthesis.speak(utterance);
	}

	function addReplayButton(botMsg, text) {
		const replayBtn = document.createElement('button');
		replayBtn.innerHTML = 'üîÅ';
		replayBtn.className = 'replay-btn';
		replayBtn.onclick = () => speak(text);
		botMsg.appendChild(replayBtn);
	}



	function createServiceCard(service) {
		const card = document.createElement('div');
		card.className = 'service-card';
		card.innerHTML = `
			<div class="service-info">
				<div class="service-name">${service.description}</div>
				<div class="service-meta">
					${service.baseModel ? 'Base Model' : 'Custom Model'} ‚Ä¢ 
					${service.censored ? 'Censored' : 'Uncensored'}
				</div>
			</div>
			<div class="status-badge status-pending" id="status-${service.name}">
				Pending
			</div>
		`;
		addTestButton(card, service); 
		return card;
	}

    function addLogEntry(service, method, url, requestData, responseData, status, error = null) {
        const logContainer = document.getElementById('logContainer');
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        const time = new Date().toLocaleTimeString();
        const logId = `log-${Date.now()}`;
        
        let logContent = `<span class="log-time">[${time}]</span> `;
        logContent += `<span class="log-service">${service}</span> `;
        logContent += `<span class="log-method">${method}</span> `;
        logContent += `<span class="log-url">${url}</span>`;
        
        if (error) {
            logContent += `\n<span class="log-error">Error: ${error}</span>`;
        } else {
            logContent += `\n<span class="log-status">Status: ${status}</span>`;
        }

        if (requestData || responseData) {
            logContent += `<button class="expand-button" data-target="${logId}">‚ñ∂ Details</button>`;
            logContent += `<div class="details" id="${logId}">`;
            if (requestData) {
                logContent += `\n<span class="log-request">Request:</span>\n${JSON.stringify(requestData, null, 2)}`;
            }
            if (responseData) {
                logContent += `\n<span class="log-response">Response:</span>\n${JSON.stringify(responseData, null, 2)}`;
            }
            logContent += '</div>';
        }
        
        logEntry.innerHTML = logContent;
        logContainer.insertBefore(logEntry, logContainer.firstChild);
        
        // Set up expand button
        const expandButton = logEntry.querySelector('.expand-button');
        if (expandButton) {
            expandButton.addEventListener('click', (e) => {
                const targetId = e.target.dataset.target;
                const details = document.getElementById(targetId);
                details.classList.toggle('show');
                e.target.textContent = details.classList.contains('show') ? '‚ñº Details' : '‚ñ∂ Details';
            });
        }

        // Keep only last 100 log entries
        const entries = logContainer.getElementsByClassName('log-entry');
        if (entries.length > 100) {
            logContainer.removeChild(entries[entries.length - 1]);
        }
    }

	async function checkService(service) {
		const requestData = {
			messages: [{role: "user", content: "."}],
			model: service.name,
			code: beesknees,
			jsonMode: false
		};

		try {

			const startTime = performance.now();
			
			const response = await fetch('https://text.pollinations.ai/', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					messages: messages,
					model: currentModel.name,
					code: beesknees,  // Here in the body where it belongs
					jsonMode: false
				})
			});
			
			const responseData = await response.text();
			const endTime = performance.now();
			const duration = (endTime - startTime).toFixed(0);

			updateServiceStatus(service.name, response.ok ? 'online' : 'offline');
			addLogEntry(
				service.name,
				'POST',
				url,
				requestData,
				responseData,
				`${response.status} (${duration}ms)`
			);

			return response.ok ? 'online' : 'offline';
		} catch (error) {
			updateServiceStatus(service.name, 'error');
			addLogEntry(
				service.name,
				'POST',
				`https://text.pollinations.ai/?code=beesknees`,
				requestData,  // Now we pass the requestData even on error
				null,
				'ERROR',
				error.message
			);
			return 'error';
		}
	}

    function updateServiceStatus(serviceName, status) {
        const statusBadge = document.getElementById(`status-${serviceName}`);
        if (statusBadge) {
            statusBadge.className = `status-badge status-${status}`;
            statusBadge.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }
    }

	async function updateAllStatuses() {
		document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
		
		// Create a queue of services to check
		const queue = [...services];
		const maxConcurrent = 3;
		const activeChecks = new Set();
		
		async function processNext() {
			if (queue.length === 0) return;
			
			const service = queue.shift();
			activeChecks.add(service.name);
			
			try {
				await checkService(service);
			} catch (error) {
				console.error(`Error checking ${service.name}:`, error);
			} finally {
				activeChecks.delete(service.name);
				// If we have capacity and more services to check, process the next one
				if (activeChecks.size < maxConcurrent && queue.length > 0) {
					processNext();
				}
			}
		}
		
		// Start initial batch of checks (up to maxConcurrent)
		const initialChecks = Math.min(maxConcurrent, queue.length);
		for (let i = 0; i < initialChecks; i++) {
			processNext();
		}
	}

	function initVoices() {
		voices = speechSynthesis.getVoices();
		if (voices.length === 0) {
			speechSynthesis.addEventListener('voiceschanged', () => {
				voices = speechSynthesis.getVoices();
			});
		}
	}
	
    function initializeUI() {
        const servicesGrid = document.getElementById('servicesGrid');
        services.forEach(service => {
            const serviceCard = createServiceCard(service);
            servicesGrid.appendChild(serviceCard);
        });

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
            });
        });
    }
	
	// Add Enter key support
	document.getElementById('chat-input').addEventListener('keypress', (e) => {
		if (e.key === 'Enter') {
			sendMessage();
		}
	});
    initializeUI();
    updateAllStatuses();
    setInterval(updateAllStatuses, 60000);
	
	// Call this when page loads
	initVoices();
	
</script>
</body>
</html>