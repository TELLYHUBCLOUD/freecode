<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoLogic Config GUI</title>
    <style>

		#nav-loader {
			width: 100%;
			height: 72px;
		   display: flex;
		   justify-content: center;
		}
		
		 body {
			font-family: sans-serif;
			margin: 0;
			overflow-y: scroll;
			background-color: #333;
			color: white;
			padding: 20px;
			box-sizing: border-box;
		}
		h1 {
			text-align: center;
			margin-bottom: 10px;
		}

		#credit-line {
			text-align: center;
			font-size: 12px;
			color: #999;
			margin-bottom: 20px; /* Reduced margin-bottom for the credit line */
			margin-top: 5px; /* Reduced margin-top for the credit line */
		}

		#credit-line a {
			color: #999;
			text-decoration: none;
		}

		 #credit-line a:hover {
			color: #bbb;
			 text-decoration: underline;
		 }
 
		.container {
			display: flex;
			align-items: flex-start;
			max-width: 1900px; /* Adjust as needed /
			margin: 0 auto;
			box-sizing: border-box;
			position: relative;
		}

		.left-panel {
			flex: 0 0 200px; / Don't grow, don't shrink, start with 200px width /
			background-color: #444; / Darker background for panels /
			padding: 20px;
			box-sizing: border-box; / Include padding and border in the element's total width and height */
			border-radius: 8px;
			margin-right: 20px;
			display: flex;
			flex-direction: column;
		overflow-y: auto;    
		}

		#left-panel-content {
			padding: 0;
			margin: 0;
		}
			#left-panel-content div {
			cursor: pointer;
			padding: 10px;
			margin-bottom: 5px;
		}
			#left-panel-content div:hover{
			background-color: #007bff;
		}

		.panel {
			width: 45%;
			padding: 20px;
			margin-bottom: 20px;
			 background-color: #444; /* Darker background for panels */
			box-sizing: border-box; /* Include padding and border in the element's total width and height */
		}
				  
		.page-container {
			display: flex;
			flex-direction: column;
			max-width: 90%;
			margin: 0 auto;
			background-color: #444; /* Darker background for panels /
			padding: 10px;
			box-sizing: border-box; / Include padding and border in the element's total width and height */
			border-radius: 8px;
		}
		
		#panel-header {
			padding: 10px;
			margin-bottom: 10px;
			text-align: center;
		}
		
		#panel-header h2 {
			margin-bottom: 5px;
			color: white;
		}
		
		#panel-content {
	
		}
		
		.main-content-container {
		flex: 1; /* Allow the page container to grow and take available width /
		background-color: #444; / Darker background for panels /
		padding: 10px;
		box-sizing: border-box; / Include padding and border in the element's total width and height /
		border-radius: 8px;
		}
		.current-page-content {
		padding: 10px;
		}
		#nav-buttons {
		display: flex;
		justify-content: center; / Centered buttons /
		align-items: center; / Vertically align items /
		margin-top: 20px;
		padding: 10px;
		}
		#nav-buttons button {
		background-color: #007bff;
		color: white;
		padding: 10px 15px;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		margin: 0 10px; / Spacing on left and right /
		}
		#nav-buttons button:hover {
		background-color: #0056b3;
		}
		
		#page-count {
		font-size: 16px;
		color: #bbb;
		}
		.setting {
		display: flex;
		align-items: center;
		margin-bottom: 10px;
		}
		.setting label {
		width: 250px;
		display: inline-block;
		text-align: right;
		margin-right: 10px;
		color: #bbb;
		font-size: 14px;
		}
		.setting input[type="text"],
		.setting select {
		padding: 8px;
		border: 1px solid #ddd;
		border-radius: 4px;
		flex: 1;
		background-color: #555;
		color: white;
		max-width: 300px;
		}
		.setting input[type="checkbox"] {
		margin-right: 5px;
		}
		.help-button {
		margin-left: 5px;
		background: none;
		border: none;
		cursor: pointer;
		font-size: 16px;
		color: #007bff;
		padding: 0;
		}
		.help-button:hover {
		color: #0056b3;
		}
		button#saveButton {
		background-color: #007bff;
		color: white;
		padding: 10px 15px;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		display: block;
		margin: 20px auto;
		}
		button#saveButton:hover {
		background-color: #0056b3;
		}

		.chat-popup {
		top: 80px; / Added top 80px to be under the menu */
		position: fixed;
		bottom: auto;
		right: 20px;
		background-color: white;
		border: 1px solid #ddd;
		border-radius: 8px;
		padding: 10px;
		box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		display: none;
		z-index: 1000;
		width: 300px;
		max-height: 400px;
		overflow-y: auto;
		}

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .chat-header button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
        }

        .chat-header h3 {
            margin-right: 10px;
        }

        .chat-messages {
            height: 250px;
            overflow-y: auto;
            padding: 5px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages p {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .chat-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 5px;
        }

        .chat-input button {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-input button:hover {
            background-color: #0056b3;
        }

		.user-message {
			background-color: #b3d7ff;  
			color: black; 
			padding: 5px;
			border-radius: 5px;
			align-self: flex-end;
			max-width: 80%;
			margin-left: auto;
			margin-bottom: 5px;
		}

		.assistant-message {
			background-color: #ddd; 
			color: black;  
			padding: 5px;
			border-radius: 5px;
			max-width: 80%;
			margin-bottom: 5px;
		}
		#status-message {
		position: absolute;
		bottom: 20px;
		left: 20px;
		color: white;
		}
		textarea#pasteText {
		display: none;
		}
		input#iniFileInput {
		display: none;
		}
		
		@media (max-width: 768px) {
			.left-panel {
				position: absolute;
				top: 0;
				left: 0;
				height: 100%;
				z-index: 1000;
				transform: translateX(-100%);
				transition: transform 0.3s ease-in-out;
				background-color: #444; /* Darker background for panels */
				padding: 20px;
				box-sizing: border-box; /* Include padding and border in the element's total width and height */
				border-radius: 8px;
			}
			.left-panel.open {
				transform: translateX(0);
			}
		}
    </style>
</head>
    <script src="https://www.ai-ministries.com/js/nav-loader.js"></script>
<body>
    <h1>VideoLogic Config GUI</h1>
	      
	<div id="nav-loader"></div>
	  <p id="credit-line">A special thanks to <a href="https://www.mediacentermaster.com/" target="_blank">Peter Souza, creator of Media Center Master (MCM)</a> for VideoLogic</p>

      
      
	<div class="container">
		   <div id="left-panel" class="left-panel">
				<div id="left-panel-content" ></div>
			</div>
		<div id="main-content-container" class="main-content-container">
			<div id="current-page-content" class="current-page-content">

			</div>
			<div id="nav-buttons">
				 <button id="first-button"><<</button>
				  <button id="prev-button" ><</button>
				 <span id="page-count"></span>
				  <button id="next-button" >></button>
				 <button id="last-button">>></button>
			 </div>
		</div>
	   </div>

    

		
       <button id="saveButton">Save INI File</button>
       <p id="status-message"></p>

      <textarea id="pasteText"></textarea>
      <input type="file" id="iniFileInput" accept=".ini">
    <div class="chat-popup" id="chat-popup">
        <div class="chat-header">
            <h3>AI Help</h3>
            <button id="close-chat-button">X</button>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <div class="chat-input">
            <input type="text" id="chat-input-text" placeholder="Type your question">
            <button id="chat-send-button">Send</button>
        </div>
    </div>
    <script>
        const pasteText = document.getElementById('pasteText');
        const iniFileInput = document.getElementById('iniFileInput');
        const chatPopup = document.getElementById('chat-popup');
        const closeChatButton = document.getElementById('close-chat-button');
        const chatMessages = document.getElementById('chat-messages');
        const chatInputText = document.getElementById('chat-input-text');
        const chatSendButton = document.getElementById('chat-send-button');
        const statusMessage = document.getElementById('status-message');
        const panel1 = document.getElementById('panel1');
        const panel2 = document.getElementById('panel2');
		const pageContainer = document.getElementById('page-container');
		const currentPanelTitle = document.getElementById('current-panel-title');
		const panelSummary = document.getElementById('panel-summary');
		const panelContent = document.getElementById('panel-content');
		const prevButton = document.getElementById('prev-button');
		const nextButton = document.getElementById('next-button');
		const pageCountDisplay = document.getElementById('page-count');
		const leftPanelContent = document.getElementById('left-panel-content');
		const firstButton = document.getElementById('first-button');
		const lastButton = document.getElementById('last-button');
		
		let currentPage = 0;
        let chatHistory = [];
        let currentHelpSetting = '';
        let currentSettings = {
            app: {
                branding: '[VL]',
                extended_colors: 'no',
                allow_no_audio: 'no',
                logging: 'no'
            },
            files: {
                abort_corrupt_duration: 'yes',
                extensions_to_process: 'avi divx flv m2ts mkv mov mp4 mpeg mpg ts wmv xvid',
                keep_originals: 'yes',
                process_deep_nest: 'yes',
                branding: '[VL]'
            },
            path: {
                move_final: 'C:\\DOWNLOADS'
            },
            video: {
                remove_black_bars: 'yes',
                black_bar_symmetry: 'yes',
                deinterlace: 'yes',
                restrict_fps: 'no',
                clamp_aspect: 'no'
            },
            ffmpeg: {
                '2_pass_encoding': 'no',
                'core.priority': 'below normal',
                'core.preset': 'medium',
                'video.bitrate_mode': 'quality',
                'video.max_file_size': '750000000',
                'video.bitrate': '1800000',
                'core.crf.x264': '20',
                'core.crf.x265': '25',
                'core.qp.x264': '26',
                'core.qp.x265': '29',
                'core.threads': '0',
                'core.picture_format': 'yuv420p',
                'core.container': 'mkv',
                'video.profile': '',
                'video.level': '',
                'video.codec': 'NVENC_hevc',
                 'audio.codec': 'auto',
                 'audio.bitrate_mode': 'constant',
                  'audio.aac.bitrate': '128000',
                  'audio.ac3.bitrate': '128000',
                    'audio.dts.bitrate': '256000',
                   'audio.mp3.bitrate': '96000',
                  'audio.channels_max': 'match',
                   'audio.freq': 'match',
                    'audio.aac.qscale': '4',
                   'audio.mp3.qscale': '3',
                   'audio.keep_langs': 'eng ???',
                   'subs.keep_langs': '*',
                   'subs.merge_srt': 'yes',
                   'audio.movie_loudness_normalization':'no',
                    'audio.tv_loudness_normalization':'yes',
                     'audio.other_loudness_normalization':'no',


            },
             videos: {
                'transcode.video_bitrate_over': '10000000000',
                 'transcode.video_codec': '',
                  'transcode.video_codec_not': 'x265',
                   'transcode.audio_bitrate_over':'10000000000',
                    'transcode.audio_codec': '',
                    'transcode.audio_codec_not': 'AC3 AAC DTS',
                    'transcode.audio_loudness': '0.3',
              },
             video: {
                duration_for_movie: '65',
                duration_for_tv: '10',
               process_others: 'no',
                  tune_movie: 'film',
                 tune_tv: 'default',
                 tune_other: 'default',
                 max_res_movie: '4k',
                  max_res_tv: '972p',
                  max_res_other: '972p',
                    'max_res_tv_keyword': 'Penn & Teller, Fool Us: none',

              }
        };

         const systemMessage = "You are an expert in explaining and configuring VideoLogic, an application that processes video files using FFmpeg. Your goal is to help users configure the app to their needs. Answer with useful, actionable info. Be concise.";

      
function getDocumentation(setting) {
   const docs = {
         'app.branding': `
            # You may add extra text to the title bar of the VideoLogic program
            # to help dinstinguish multiple parallel running instances.
            ##app.branding = [VLC]
            `,
         'app.extended_colors': `
            # VideoLogic will automatically change the console color palette when it isn't
            # running in single-file-processing mode (with command line parameters).  This
            # setting can be used to forcibly enable or disable extended color palette use.
            # Note that this feature only works in Windows.
            ##app.extended_colors = yes
           `,
          'app.allow_no_audio': `
            # Usually, VideoLogic will assume video files that do not have audio aren't
            # valid.  To process them anyway, enable this option.  Note: in single-file
            # processing mode (with command line parameters), this option is automatically
            # enabled.
            app.allow_no_audio = no
          `,
         'app.logging': `
            # Log-to-disk lifetime video conversion stats and a record of events and
            # ffmpeg output.  Note: in single-file processing mode (with command line
            # parameters), this option is automatically disabled.
            ##app.logging = yes
            `,
           'files.abort_corrupt_duration': `
               # Abort conversions if VideoLogic detects major problems with the input
              # duration.
            files.abort_corrupt_duration = yes
           `,
            'files.extensions_to_process': `
                 # A list of file extensions VideoLogic should look for when processing video
                # files.  Files with extensions not in this list will be skipped entirely.
                files.extensions_to_process = avi divx flv m2ts mkv mov mp4 mpeg mpg ts wmv xvid
            `,
           'files.keep_originals': `
                # Keep original files in ./Originals
                #
                # When enabled, you will need to manually delete files in this path at your
                # discretion.  Once VideoLogic moves originals here, it never manages them
                # again.
                files.keep_originals = yes
            `,
         'files.process_deep_nest': `
                # Process files that are deeply nested (more than one level).  Enabling this
                # option will allow VideoLogic to process videos in a library hierarchy,
                # including Season subfolders, movie collections, etc.  Disabling this option
                # will instruct VideoLogic to confine processing to files only in the base
                # queue folders and any folders one (1) nested level deep, as if it were
                # processing new downloads.
               files.process_deep_nest = yes
         `,
         'files.branding': `
                 # Extra text in the output filename to denote that the file has been converted.
                files.branding = [VL]
           `,
            'path.move_final': `
                 # Once conversions are complete, move converted files to this network path.
                # If unset, converted files will remain in .\Converted and not moved to a
                # final destination.
                path.move_final = C:\\DOWNLOADS
            `,
            'video.remove_black_bars': `
                 # Enable detection of black bars in the video and remove them by cropping the
                 # video frame to a new size.  Resizing options will use the cropped size.  No
                 # cropping will occur if no black bars are detected or if this setting is
                 # disabled.
               video.remove_black_bars = yes
            `,
         'video.black_bar_symmetry': `
                # When black bars are being detected for removal, check if the size of the
                # left and right margins match as well as top and bottom margins.  If one
                # side of the two pairs don't match and symmetry is enabled, the smaller side
                # will be enlarged to match the larger side.  This automatically fixes some
                # cases of black bars with logos, URLs, or text stamped into the black bar
                # image margin.
                video.black_bar_symmetry = yes
            `,
         'video.deinterlace': `
                # Enable deinterlacing video filter (using FFMPEG 'yadif' filter), useful for
                # transcoding DVD or other interlaced video content.  The filter will not be
                # used if the source video isn't interlaced or if this setting is disabled.
                video.deinterlace = yes
            `,
          'video.restrict_fps': `
                 # Restricts the maximum framerate of the output video to 30.0 FPS.  When
                 # enabled, framerates exceeding 30.0 FPS will be divided by 2 repeatedly until
                 # it falls under this value.  In this way, there should be no distortion in
                 # videos that were recorded with very high framerates (such as 60 FPS and up).
                video.restrict_fps = no
            `,
           'ffmpeg.2_pass_encoding': `
                 # Dual-pass (2-pass) encoding can significantly increase compression
                # efficiency for creating smaller files, but will drastically increase the
                # amount of time required to transcode.
                ffmpeg.2_pass_encoding = no
            `,
          'ffmpeg.core.priority': `
                # FFMPEG can be launched at different application priority levels.
                #
                # idle or low         lowest priority level and only gets processing time when
                #                     the CPU is idle (not recommended)
                # below normal        lower priority than normal, but still receives regular
                #                     processing cycles from the CPU (default for VideoLogic)
                # normal              the default priority level for all user applications
                # above normal        higher priority than normal, but not as demanding on the
                #                     system and will still play nicely with other applications
                # high                time-critical priority level for tasks that must be
                #                     executed immediately, regardless of the load on the OS,
                #                     preempting applications running in normal or idle
                #                     priority levels (not recommended)
                # realtime            if you want your sytsem unresponsive during transcoding,
                #                     this gives VideoLogic the highest priority level the OS
                #                     can offer and can't be preempted by even OS timer
                #                     interrupts (including using the keyboard, mouse, hard
                #                     drive cache, etc.) (VERY not recommended)
                ffmpeg.core.priority = below normal
            `,
           'ffmpeg.core.preset': `
              # This setting compromises encoding speed vs. optimizations.  Favoring speed
                # will produce somewhat bigger file sizes as fewer encoder calculations are
                # used to perform motion prediction, smaller quanitizers are employed, etc.
                # The visual quality should be the same at all levels.  Allowed values are
                # specific to which encoder you are using.  For software-based x264 and
                # software-based x265/HEVC, the following presets are available:
                #
                # placebo              almost no improvements over 'veryslow' and shouldn't be
                #                      used except for possibly testing
                # veryslow, best       every optimization enabled
                # slower
                # slow
                # medium, average, normal, default
                # fast
                # faster
                # veryfast
                # superfast, worst     nearly every optimization disabled
                # ultrafast
                #
                # See:  https://trac.ffmpeg.org/wiki/Encode/H.264
                #       https://trac.ffmpeg.org/wiki/Encode/H.265
                #
                # For Intel Quicksync x264 and x265/HEVC, the following presets are available:
                #
                # veryslow
                # slower
                # slow
                # medium, default
                # fast
                # faster
                # veryfast
                #
                # See:  ffmpeg -help encoder=h264_qsv
                # See:  ffmpeg -help encoder=hevc_qsv
                #
                # For nVidia NVENC x264 and x265/HEVC, the following presets are available:
                #
                # slow                 hq 2 passes
                # medium, default      hq 1 pass
                # fast                 hp 1 pass
                # hp
                # hq                   high quality
                # bd
                # ll                   low latency
                # llhq                 low latency hq
                # llhp                 low latency hp
                # lossless             lossless
                # losslesshp           lossless hp
                #
                # See:  ffmpeg -help encoder=nvenc_h264
                # See:  ffmpeg -help encoder=nvenc_hevc
                ffmpeg.core.preset = medium
            `,
           'ffmpeg.video.bitrate_mode': `
               # Want constant rate format (constant quality), average bitrate,
                # or constant bitrate.  Constant bitrate is not compatible with
                # 2-pass mode.
                #
                # config setting                bitrate mode
                # --------------                ---------------
                # quality                       maintain constant quality (CRF/QP, recommended)
                # ABR, VBR, average, variable   average bitrate
                # CBR, constant                 constant bitrate (rarely used)
                # size                          calculate bitrate for you by specifying
                #                               a target maximum file size
                #
                # Note: the using 'quality', 'CRF', 'QP', or 'CQP' will be interpretted to mean
                # 'constant quality' and will use the better version of whatever is supported
                # by the encoder.  For example, software-based x264 and x265/HEVC encoding will
                # support CRF-based quality but hardware-based x265 and x265/HEVC encoding
                # won't, so will be downgraded to QP-based encoding.
                #
                # Here is some information on the difference between CRF and QP:
                # https://slhck.info/video/2017/02/24/crf-guide.html
                ffmpeg.video.bitrate_mode = quality
            `,
            'ffmpeg.video.max_file_size': `
                 # Specify a maximum file size for your video.  This requires bitrate mode
                 # to be set to 'size' and will override your bitrate setting and force
                 # 2-pass encoding.  VideoLogic will make all efforts to target this maximum
                 # file size, although it will only consider your video stream (audio data
                 # will make the result file size larger, especially if you are encoding high
                 # bitrate audio or keeping DTS audio streams, etc.).
                 #
                 # Note: this is set to total bytes (no shorthand like 500M or 2G).
                 #
                 # Note: this option is not compatible with Intel Quicksync or nVidia NVENC
                 # encoders (either the encoders do not support 2-pass encoding or VideoLogic
                 # is not developed to accommodate those features), so use software-based
                 # encoders instead if you need to specify a target file size for your videos.
                ffmpeg.video.max_file_size = 750000000
            `,
          'ffmpeg.video.bitrate': `
              # This bitrate setting is used to assign an average or maximum bitrate
                 # and affects the different encoding modes differently.  It's highly
                 # recommended to use 2-pass mode if you are targeting a specific file
                 # size and need to best control the bitrate.
                 #
                 # For CRF/quality, this setting defines a maximum bitrate the encoder is
                 # allowed to use (no minimum).  Set it to 0 for no limit on bitrate, only
                 # a limit on quality as defined by the CRF quality setting.  It's highly
                 # recommended to use 2-pass mode when both ABR and bitrate settings are
                 # configured.
                 #
                 # For ABR, this setting defines the average bitrate the encoder should
                 # target with variable bitrate above and below this amount with consideration
                 # to encoder optimizations.  This value must not be 0 in ABR mode.  It's
                 # highly recommended to use 2-pass mode when both ABR and bitrate settings
                 # are configured.
                 #
                 # For CBR, this setting defines the absolute bitrate the encoder will use
                 # constantly throughout the entire video.  It's impossible to use CBR and
                 # 2-pass modes together since there can be no variation in bitrate and thus
                 # no optimizations to make in targeting an average or maximum bitrate.
                 #
                 # Note: this is set to bits per second (no shorthand like 3M or 500K).
                ffmpeg.video.bitrate = 1800000
            `,
           'ffmpeg.core.crf.x264': `
                 # 'Sane' Constant Rate Factor (CRF) values for x264 encoding are between 18-28.
                #
                # Typically, 23 is the baseline for x264 and a CRF change of +/- 6 levels
                # should result in about a double or half output filesize, although results
                # may vary.
                #
                # Note: this option is translated to QP for hardware-based encoders such as
                # Intel Quicksync and nVidia NVENC.  See 'ffmpeg.core.qp.x264'.
               ffmpeg.core.crf.x264 = 20
            `,
          'ffmpeg.core.crf.x265': `
                # 'Sane' Constant Rate Factor (CRF) values for x265 encoding are between 18-28.
                #
                # Typically, 28 is the baseline for x265 and a CRF change of +/- 6 levels
                # should result in about a double or half output filesize, although results
                # may vary.
                #
                # Note: this option is translated to QP for hardware-based encoders such as
                # Intel Quicksync and nVidia NVENC.  See 'ffmpeg.core.qp.x265'.
                ffmpeg.core.crf.x265 = 25
           `,
            'ffmpeg.core.qp.x264': `
               # Constant Quantization Parameter (QP) for hardware-based x264 encoders.
                # Note, if this value is left blank, it will be automatically calculated based
                # on your 'ffmpeg.core.crf.x264' setting.
                ffmpeg.core.qp.x264 = 26
            `,
          'ffmpeg.core.qp.x265': `
               # Constant Quantization Parameter (QP) for hardware-based x265/HEVC encoders.
                # Note, if this value is left blank, it will be automatically calculated based
                # on your 'ffmpeg.core.crf.x265' setting.
                ffmpeg.core.qp.x265 = 29
          `,
          'ffmpeg.core.threads': `
                 # Other FFMPEG settings can be tweaked here.  Note: threads of '0' instructs
                # FFMPEG to automatically use the same number of threads as you have processor
                # cores available.  Video profile and level can be set blank to instruct
                # FFMPEG to use its defaults which are automatically selected based on other
                # encoding parameters.
                #
                # Note that picture format will be overridden to 'nv12' if your encoder is set
                # to Intel Quicksync x264 or Intel Quicksync x265 as none of the 'yuv' picture
                # formats are supported by that encoder.
                ffmpeg.core.threads        = 0
            `,
           'ffmpeg.core.picture_format': `
                ffmpeg.core.picture_format = yuv420p
            `,
           'ffmpeg.core.container': `
                ffmpeg.core.container      = mkv
            `,
            'ffmpeg.video.profile': `
                ffmpeg.video.profile       =
            `,
           'ffmpeg.video.level': `
                ffmpeg.video.level         =
           `,
            'ffmpeg.video.codec': `
               # Adjust which codec to use when converting video.  Allowed values are:
                #
                # config setting   FFMPEG encoding library / notes
                # ---------------  -----------------------------------------------------------
                # copy, none                copy (does not transcode, just copy the stream)
                # match                     use the same codec as input (must be one of the
                #                           below options, but will still transcode the video)
                # x264                      libx264      software-based x264-encoding
                # x265, HEVC                libx265      software-based x265/HEVC-encoding
                # Intel x264, QSV x264      h264_qsv     Intel Quicksync hardware-based x264
                # Intel x265, Intel x265    hevc_qsv     Intel Quicksync hardware-based x265
                #   QSV x265, QSV HEVC                   (alternative names)
                # nVidia x264, QSV x264     nvenc_h264   nVidia NVENC hardware-based x264
                # nVidia x265, nVidia x265  nvenc_hevc   nVidia NVENC hardware-based x265
                #   NVENC x265, NVENC HEVC               (alternative names)
                #
                # Note: when not using 'copy' mode, the video stream will not be transcoded if
                # no matching rule requires the stream to be transcoded.  See: config settings
                # for 'videos.transcode.video_*'.
                #
                # Note: when using 'match' mode, if the input video stream is not one of the
                # available codecs, the output codec will be set to x265, chosen for its high
                # efficiency and strong compatibility.
                #
                # Note: Intel Quicksync and nVidia NVENC are subject to hardware support.
                # Ensure that your hardware meets the requirements to encode with these options
                # before using VideoLogic to try ot encode your videos. Additional restrictions
                # apply (for example, CRF is not supported with either QSV or NVENC, only QP).
                ffmpeg.video.codec = NVENC_hevc
           `,
          'ffmpeg.audio.codec': `
                # Adjust which codec to use when converting audio.  Allowed values are:
                #
                # config setting   FFMPEG encoding library / notes
                # ---------------  -----------------------------------------------------------
                # copy, none       copy (does not transcode, just copy the stream(s))
                # auto             automatically determine codec to use based on desired
                #                  container and source audio channels
                # match            use the same codec as input (must be one of the below
                #                  options, but will still transcode the audio)
                # AAC              aac
                # AC3              ac3
                # MP3              libmp3lame
                # DTS              dca
                #
                # Note: when not using 'copy' mode, the audio stream will not be transcoded if
                # no matching rule requires the stream to be transcoded.  See: config settings
                # for 'videos.transcode.audio_*'.
                #
                # Note: when using 'match' mode, if the input audio stream is not one of the
                # available codecs, the output codec will be set to AC3, chosen for its high
                # compatibility.
                ffmpeg.audio.codec = auto
             `,
           'ffmpeg.audio.bitrate_mode': `
                # FFMPEG audio bitrate mode
                #
                # config setting   FFMPEG encoding library / notes
                # ---------------  -----------------------------------------------------------
                # cbr, constant    constant bitrate
                # vbr, qscale,     variable bitrate targeting a quality scale level
                #   quality        this mode will use the qscale settings for AAC and MP3
                #                  codecs (AC3 and DTS do not support VBR and will override
                #                  with CBR)
                ffmpeg.audio.bitrate_mode = constant
            `,
          'ffmpeg.audio.aac.bitrate': `
                # FFMPEG target audio bitrate PER CHANNEL, not including LFE.  This is not a
                # per-stream setting: VideoLogic will total up the number of channels present
                # in the audio source and multiply by this per-channel bitrate setting to
                # achieve a total constant bitrate (CBR) value during encoding.
                #
                # Example #1:       stereo audio at  64000 will produce a  128kb CBR
                # Example #2: 5.1 surround audio at  51200 will produce a  256kb CBR
                #
                # Note: AAC and MP3 codecs will not use this setting if
                # 'ffmpeg.audio.bitrate_mode' is set to VBR/qscale.
                ffmpeg.audio.aac.bitrate = 128000
            `,
            'ffmpeg.audio.ac3.bitrate': `
                # FFMPEG target audio bitrate PER CHANNEL, not including LFE.  This is not a
                # per-stream setting: VideoLogic will total up the number of channels present
                # in the audio source and multiply by this per-channel bitrate setting to
                # achieve a total constant bitrate (CBR) value during encoding.
                #
                # Example #1:       stereo audio at  64000 will produce a  128kb CBR
                # Example #2: 5.1 surround audio at  51200 will produce a  256kb CBR
                #
                # Note: AAC and MP3 codecs will not use this setting if
                # 'ffmpeg.audio.bitrate_mode' is set to VBR/qscale.
                 ffmpeg.audio.ac3.bitrate = 128000
           `,
           'ffmpeg.audio.dts.bitrate': `
                 # FFMPEG target audio bitrate PER CHANNEL, not including LFE.  This is not a
                 # per-stream setting: VideoLogic will total up the number of channels present
                 # in the audio source and multiply by this per-channel bitrate setting to
                 # achieve a total constant bitrate (CBR) value during encoding.
                 #
                 # Example #1:       stereo audio at  64000 will produce a  128kb CBR
                 # Example #2: 5.1 surround audio at  51200 will produce a  256kb CBR
                 #
                 # Note: AAC and MP3 codecs will not use this setting if
                 # 'ffmpeg.audio.bitrate_mode' is set to VBR/qscale.
                 ffmpeg.audio.dts.bitrate = 256000
           `,
            'ffmpeg.audio.mp3.bitrate': `
                # FFMPEG target audio bitrate PER CHANNEL, not including LFE.  This is not a
                 # per-stream setting: VideoLogic will total up the number of channels present
                 # in the audio source and multiply by this per-channel bitrate setting to
                 # achieve a total constant bitrate (CBR) value during encoding.
                 #
                 # Example #1:       stereo audio at  64000 will produce a  128kb CBR
                 # Example #2: 5.1 surround audio at  51200 will produce a  256kb CBR
                 #
                 # Note: AAC and MP3 codecs will not use this setting if
                 # 'ffmpeg.audio.bitrate_mode' is set to VBR/qscale.
                ffmpeg.audio.mp3.bitrate = 96000
            `,
          'ffmpeg.audio.channels_max': `
                # The maximum allowed audio channels you want in your output video.  If the
                # audio is being converted (not copied) and the number of channels exceeds your
                # configured setting, audio will automatically be downmixed (after volume
                # normalization).
                #
                # You may choose to leave this blank (or set it to "auto" or "match") to
                # disable, use "mono" for 1.0, "stereo" for 2.0, or any numeric value to set
                # channels (such as "2.1", "5.1", etc.).
                ffmpeg.audio.channels_max = match
            `,
            'ffmpeg.audio.freq': `
                # The sampling frequency to use when converting audio streams.  If this is not
                # set or set to 0, the output sampling frequency will automatically match the
                # input audio stream's sampling frequency unless the input sampling frequency
                # falls under 44100 Hz, which causes issues in multiple devices.  Specify a
                # value if you want to override this safeguard.
                #
                # Note: this should be set in bits (no shorthand like 44.1K or 48K).
                ffmpeg.audio.freq = match
            `,
            'ffmpeg.audio.aac.qscale': `
                # FFMPEG Quality Scaling for VBR mode (audio encoding)
                #
                # See:
                #     https://trac.ffmpeg.org/wiki/Encode/AAC
                #     https://trac.ffmpeg.org/wiki/Encode/MP3
                #     https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
                #
                # Note: AC3 and DTS codecs do not support variable bitrates, so they cannot
                # target a VBR/quality scale level.  'ffmpeg.core.ac3.bitrate' or
                # 'ffmpeg.core.dts.bitrate' will be used for AC3 and DTS codecs.
                #
                # AAC qscale is between 1 to 5.  5 is the best quality and highest VBR.
                # MP3 qscale is between 0 to 9.  0 is the best quality and highest VBR.
                ffmpeg.audio.aac.qscale  = 4
            `,
            'ffmpeg.audio.mp3.qscale': `
                # FFMPEG Quality Scaling for VBR mode (audio encoding)
                #
                # See:
                #     https://trac.ffmpeg.org/wiki/Encode/AAC
                #     https://trac.ffmpeg.org/wiki/Encode/MP3
                #     https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
                #
                # Note: AC3 and DTS codecs do not support variable bitrates, so they cannot
                # target a VBR/quality scale level.  'ffmpeg.core.ac3.bitrate' or
                # 'ffmpeg.core.dts.bitrate' will be used for AC3 and DTS codecs.
                #
                # AAC qscale is between 1 to 5.  5 is the best quality and highest VBR.
                # MP3 qscale is between 0 to 9.  0 is the best quality and highest VBR.
                ffmpeg.audio.mp3.qscale  = 3
            `,
            'ffmpeg.audio.keep_langs': `
                # Languages of audio tracks to keep (in ISO 639-2 three-letter format).
                # "???" or 'und' may be used to denote undetermined or language-not-specified
                # tracks.  Any audio tracks not matching this list will be discarded.  Use
                # 'all' or '*' (or just leave blank) to specify to keep all languages.
                #
                # See: https://www.loc.gov/standards/iso639-2/php/code_list.php
                ffmpeg.audio.keep_langs = eng ???
            `,
          'videos.transcode.audio_bitrate_over':`
            # Rules for when VideoLogic should transcode audio streams
                #
                # Note: audio loudness is measured by the 'loudnorm' audio filter as a LU (dB)
                # distance from measured integrated loudness (perceived loudness) per
                # LUFS/LKFS.  If the current audio is not more or less loud by the configured
                # value, it will not trigger that rule.  Set it to 0.0 dB to forcibly
                # normalize all audio.  See also: 'ffmpeg.audio.movie_loudness_normalization'
                # and 'ffmpeg.audio.tv_loudness_normalization'.
            videos.transcode.audio_bitrate_over = 10000000000
           `,
            'videos.transcode.audio_codec': `
            # Rules for when VideoLogic should transcode audio streams
                #
                # Note: audio loudness is measured by the 'loudnorm' audio filter as a LU (dB)
                # distance from measured integrated loudness (perceived loudness) per
                # LUFS/LKFS.  If the current audio is not more or less loud by the configured
                # value, it will not trigger that rule.  Set it to 0.0 dB to forcibly
                # normalize all audio.  See also: 'ffmpeg.audio.movie_loudness_normalization'
                # and 'ffmpeg.audio.tv_loudness_normalization'.
           videos.transcode.audio_codec =
            `,
             'videos.transcode.audio_codec_not': `
                 # Rules for when VideoLogic should transcode audio streams
                 #
                 # Note: audio loudness is measured by the 'loudnorm' audio filter as a LU (dB)
                 # distance from measured integrated loudness (perceived loudness) per
                 # LUFS/LKFS.  If the current audio is not more or less loud by the configured
                 # value, it will not trigger that rule.  Set it to 0.0 dB to forcibly
                 # normalize all audio.  See also: 'ffmpeg.audio.movie_loudness_normalization'
                 # and 'ffmpeg.audio.tv_loudness_normalization'.
            videos.transcode.audio_codec_not = AC3 AAC DTS
             `,
           'videos.transcode.audio_loudness': `
                 # Rules for when VideoLogic should transcode audio streams
                 #
                 # Note: audio loudness is measured by the 'loudnorm' audio filter as a LU (dB)
                 # distance from measured integrated loudness (perceived loudness) per
                 # LUFS/LKFS.  If the current audio is not more or less loud by the configured
                 # value, it will not trigger that rule.  Set it to 0.0 dB to forcibly
                 # normalize all audio.  See also: 'ffmpeg.audio.movie_loudness_normalization'
                 # and 'ffmpeg.audio.tv_loudness_normalization'.
              videos.transcode.audio_loudness = 0.3
           `,
            'ffmpeg.audio.movie_loudness_normalization': `
               # Whether or not to pass the audio through FFMPEG's 'loudnorm' filter, which
                # implements the EBU R128 standard to normalize the perceived loudness of
                # the audio.
                #
                # Note: even when this setting is enabled, loudness normalization will only
                # occur if the config 'ffmpeg.audio.codec' is not set to 'none' or 'copy'
                # and also the amount of loudness variation needs to be higher than the
                # threshold set in config 'videos.transcode.audio_loudness'.
                ffmpeg.audio.movie_loudness_normalization = no
            `,
            'ffmpeg.audio.tv_loudness_normalization': `
                 # Whether or not to pass the audio through FFMPEG's 'loudnorm' filter, which
                # implements the EBU R128 standard to normalize the perceived loudness of
                # the audio.
                #
                # Note: even when this setting is enabled, loudness normalization will only
                # occur if the config 'ffmpeg.audio.codec' is not set to 'none' or 'copy'
                # and also the amount of loudness variation needs to be higher than the
                # threshold set in config 'videos.transcode.audio_loudness'.
                ffmpeg.audio.tv_loudness_normalization    = yes
            `,
             'ffmpeg.audio.other_loudness_normalization': `
                 # Whether or not to pass the audio through FFMPEG's 'loudnorm' filter, which
                # implements the EBU R128 standard to normalize the perceived loudness of
                # the audio.
                #
                # Note: even when this setting is enabled, loudness normalization will only
                # occur if the config 'ffmpeg.audio.codec' is not set to 'none' or 'copy'
                # and also the amount of loudness variation needs to be higher than the
                # threshold set in config 'videos.transcode.audio_loudness'.
                ffmpeg.audio.other_loudness_normalization = no
            `,
            'ffmpeg.subs.keep_langs': `
                 # Languages of subtitle tracks to keep (in ISO 639-2 three-letter format).
                # "???" or 'und' may be used to denote undetermined or language-not-specified
                # tracks.  Any subtitle tracks not matching this list will be discarded.  Use
                # 'all' or '*' (or just leave blank) to specify to keep all languages.
                #
                # See: https://www.loc.gov/standards/iso639-2/php/code_list.php
               ffmpeg.subs.keep_langs = *
            `,
            'ffmpeg.subs.merge_srt': `
                 # Whether or not to detect loose .srt files that appear to match the video
                # and merge them into the video container.
                ffmpeg.subs.merge_srt = yes
            `,
             'video.duration_for_movie': `
                  # Threshold for how many minutes long a video must be to be handled as a movie
                  # and not a T.V. episode.  This affects conversion/quality settings.
                 video.duration_for_movie = 65
            `,
				  'video.duration_for_tv': `
                   # Threshold for how many minutes long a video must be to be handled as a T.V.
                   # episode and not an other/miscellaneous video.  This affects conversion/
                   # quality settings.
                  video.duration_for_tv = 10
             `,
                  'video.process_others': `
                        # Whether or not to process other videos: videos less than 10 minutes long,
                         # by default (configured via 'video.duration_for_tv').  These videos can
                         # be skipped or processed.
                        video.process_others = no
                    `,
                    'video.tune_movie': `
                        # Assign general tune for movies and T.V.  This adjusts how both the x264 and
                        # x265/HEVC encoders will treat the source video when transcoding.  Allowed
                        # values are:
                        #
                        # config setting        notes
                        # --------------------  ------------------------------------------------------
                        # default               x264 tune = (unset), x265 uses settings that appeal to
                        #                       all types of video content
                        # film                  x264 tune = film, x265 uses settings that target
                        #                       general live-action video content
                        # animation             x264 tune = animation, x265 uses settings that target
                        #                       animated video content like cartoons and anime
                        # grain                 x264 tune = grain, x265 uses settings that target
                        #                       video content source containing high film grain
                        #
                        # Note: this option is ignored for hardware-based encoders such as Intel
                        # Quicksync and nVidia NVENC.
                         video.tune_movie = film
                    `,
                   'video.tune_tv': `
                        # Assign general tune for movies and T.V.  This adjusts how both the x264 and
                        # x265/HEVC encoders will treat the source video when transcoding.  Allowed
                        # values are:
                        #
                        # config setting        notes
                        # --------------------  ------------------------------------------------------
                        # default               x264 tune = (unset), x265 uses settings that appeal to
                        #                       all types of video content
                        # film                  x264 tune = film, x265 uses settings that target
                        #                       general live-action video content
                        # animation             x264 tune = animation, x265 uses settings that target
                        #                       animated video content like cartoons and anime
                        # grain                 x264 tune = grain, x265 uses settings that target
                        #                       video content source containing high film grain
                        #
                        # Note: this option is ignored for hardware-based encoders such as Intel
                        # Quicksync and nVidia NVENC.
                      video.tune_tv    = default
                    `,
                 'video.tune_other': `
                        # Assign general tune for movies and T.V.  This adjusts how both the x264 and
                        # x265/HEVC encoders will treat the source video when transcoding.  Allowed
                        # values are:
                        #
                        # config setting        notes
                        # --------------------  ------------------------------------------------------
                        # default               x264 tune = (unset), x265 uses settings that appeal to
                        #                       all types of video content
                        # film                  x264 tune = film, x265 uses settings that target
                        #                       general live-action video content
                        # animation             x264 tune = animation, x265 uses settings that target
                        #                       animated video content like cartoons and anime
                        # grain                 x264 tune = grain, x265 uses settings that target
                        #                       video content source containing high film grain
                        #
                        # Note: this option is ignored for hardware-based encoders such as Intel
                        # Quicksync and nVidia NVENC.
                       video.tune_other = default
                     `,
                  'video.max_res_movie': `
                         # Limit the maximum resolution for videos by scaling (resizing) down any video
                         # file that exceeds the maximum.  Allowed values are:
                         #
                         # resolution     config setting       notes
                         # -------------  -------------------  ----------------------------------------
                         # no limit       none, no limit       or leave blank
                         # 3840x2160      UHD, 2160p, 4K
                         # 2592x1080      1458p                for 1080p height with up to 2.4 aspect
                         # 1920x1080      HD, HDTV, 1080p
                         #  1728x720      972p                 for 720p height with up to 2.4 aspect
                         #  1280x720      720p
                         #   852x480      SD, SDTV, 480p
                         #   720x576      PAL, 576p            this is PAL DVD
                         #   720x480      DVD, NTSC            this is NTSC DVD
                      video.max_res_movie = 4k
                   `,
                   'video.max_res_tv': `
                        # Limit the maximum resolution for videos by scaling (resizing) down any video
                        # file that exceeds the maximum.  Allowed values are:
                        #
                        # resolution     config setting       notes
                        # -------------  -------------------  ----------------------------------------
                        # no limit       none, no limit       or leave blank
                        # 3840x2160      UHD, 2160p, 4K
                        # 2592x1080      1458p                for 1080p height with up to 2.4 aspect
                        # 1920x1080      HD, HDTV, 1080p
                        #  1728x720      972p                 for 720p height with up to 2.4 aspect
                        #  1280x720      720p
                        #   852x480      SD, SDTV, 480p
                        #   720x576      PAL, 576p            this is PAL DVD
                        #   720x480      DVD, NTSC            this is NTSC DVD
                        video.max_res_tv    = 972p
                    `,
                 'video.max_res_other': `
                        # Limit the maximum resolution for videos by scaling (resizing) down any video
                        # file that exceeds the maximum.  Allowed values are:
                        #
                        # resolution     config setting       notes
                        # -------------  -------------------  ----------------------------------------
                        # no limit       none, no limit       or leave blank
                        # 3840x2160      UHD, 2160p, 4K
                        # 2592x1080      1458p                for 1080p height with up to 2.4 aspect
                        # 1920x1080      HD, HDTV, 1080p
                        #  1728x720      972p                 for 720p height with up to 2.4 aspect
                        #  1280x720      720p
                        #   852x480      SD, SDTV, 480p
                        #   720x576      PAL, 576p            this is PAL DVD
                        #   720x480      DVD, NTSC            this is NTSC DVD
                         video.max_res_other = 972p
                       # Note: other video max resolution will be set to unlimited by default when
                        # VideoLogic is running in single-file processing mode (with command line).
                    `,
                   'video.max_res_tv_keyword': `
                       # Daily-airing shows can be reduced to SDTV quality.
                        # Example: daily-airing shows can be reduced to SDTV quality.
                       # Example: other shows can be kept at higher quality
                        ##video.max_res_tv_keyword = some high action show: 1080p
                         ##video.max_res_tv_keyword = another awesome show: none
                      video.max_res_tv_keyword = Penn & Teller, Fool Us: none
                 `,
                  'videos.transcode.video_bitrate_over': `
                       # Rules for when VideoLogic should transcode video streams.  For codecs,
                        # multiple values may be used (separate with a space).
                        #
                        # Note: see also 'video.max_res_movie' and 'video.max_res_tv'
                       videos.transcode.video_bitrate_over = 10000000000
                    `,
                    'videos.transcode.video_codec': `
                       # Rules for when VideoLogic should transcode video streams.  For codecs,
                        # multiple values may be used (separate with a space).
                        #
                        # Note: see also 'video.max_res_movie' and 'video.max_res_tv'
                       videos.transcode.video_codec =
                    `,
                     'videos.transcode.video_codec_not': `
                         # Rules for when VideoLogic should transcode video streams.  For codecs,
                         # multiple values may be used (separate with a space).
                         #
                         # Note: see also 'video.max_res_movie' and 'video.max_res_tv'
                         videos.transcode.video_codec_not = x265
                     `
            };

            return docs[setting] || "No specific documentation available.";
        }

    

        function convertIni(iniText) {
            const config = {};
            const lines = iniText.split('\n');
            let currentSection = '';

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#') || trimmedLine === '') {
                    continue; //skip comments and empty lines
                }

                if (trimmedLine.startsWith('[')) {
                    currentSection = trimmedLine.slice(1, -1);
                    config[currentSection] = {};
                    continue;
                }

                const eqIndex = trimmedLine.indexOf('=');
                if (eqIndex !== -1) {
                    const key = trimmedLine.slice(0, eqIndex).trim();
                    const value = trimmedLine.slice(eqIndex + 1).trim();
                    config[currentSection][key] = value;
                }
            }
            return config;
        }

        function updateIni(settings) {
            let iniText = '';
            for (const section in settings) {
                iniText += `[${section}]\n`;
                for (const key in settings[section]) {
                    iniText += `${key} = ${settings[section][key]}\n`;
                }
                iniText += '\n';
            }
            return iniText;
        }

        function addAssistantMessage(message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add('assistant-message');
            messageElement.textContent = message;
            chatMessages.appendChild(messageElement);
           chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        function addUserMessage(message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add('user-message');
            messageElement.textContent = message;
             chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

		async function fetchAiResponse(message) {
				 chatHistory.push({ role: "user", content: message });
				let doc;
			   if(currentHelpSetting) {
					doc = getRelevantDocumentation(currentHelpSetting, 3000);
			   } else {
				   doc = getGeneralDocumentation(message, 3000);
			  }
				 const requestBody = {
					  messages: [
						 {
							  role: "system",
							  content: `You are an expert in explaining and configuring VideoLogic, an application that processes video files using FFmpeg. Your goal is to help users configure the app to their needs. Answer with useful, actionable info. Be conversational. Do not give output like JSON format.`,
						},
						 {
							 role: "system",
							 content: `Here is the documentation for the setting you are asking about: \n ${doc}`,
						 },
					   ...chatHistory,
				   ],
					  model: 'openai',
					  code: 'beesknees',
					 seed: Math.floor(Math.random() * 100000)
				 };

				 try {
					const response = await fetch("https://text.pollinations.ai/", {
						method: "POST",
						headers: {
							 "Content-Type": "application/json",
						 },
					   body: JSON.stringify({
							...requestBody,
						}),
					});
				   if (!response.ok) {
						 addAssistantMessage(`Error contacting the AI.`);
						return;
					}
					const data = await response.json();
					 if (data && data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
						const message = data.choices[0].message.content;
						  chatHistory.push({ role: "assistant", content: message });
						 addAssistantMessage(message);
					 } else {
						  addAssistantMessage(`Error parsing AI response.`);
				   }
			   } catch (error) {
				 addAssistantMessage(`Error contacting the AI: ${error}`);
			   }
		}
		function getRelevantDocumentation(setting, maxChunkSize = 3000) {
			 const allDocs = Object.values(docs).join("\n");
			 const settingParts = setting.split('.');
			  if (settingParts.length !== 2) {
				 return "No specific documentation available.";
		   }
		   const section = settingParts[0];
			const key = settingParts[1];

			const regex = new RegExp(`(?:^|\\n)(?:#.*\\n)*${section}\\.${key}\\s*=\\s*[^\\n]*(?:\\n(?:#.*\\n)*|$)`, 'm');
			const match = allDocs.match(regex);
			if (!match) return "No specific documentation available.";

		   const doc = match[0];
			if (doc.length <= maxChunkSize) {
				 return doc.trim();
			} else {
			   return doc.substring(0, maxChunkSize) + `\n\n... (truncated due to length)`
			}
		}
 
		function getGeneralDocumentation(query, maxChunkSize = 3000){
			const allDocs = Object.entries(docs);
			const relevantDocs = allDocs.filter(([key, doc]) => {
				return doc.toLowerCase().includes(query.toLowerCase());
			})
			const combinedDocs = relevantDocs.map(([key, doc]) => doc).join("\n\n");
				if (combinedDocs.length <= maxChunkSize) {
					return combinedDocs.trim();
			} else {
				return combinedDocs.substring(0, maxChunkSize) + \n\n... (truncated due to length)
			}
		}

		 function renderSettings() {
			currentHelpSetting = null;
			panelContent.innerHTML = '';
			pageCountDisplay.innerText = `${currentPage + 1}/${Object.keys(currentSettings).length + 1}`;

			  const allSections = Object.keys(currentSettings);

			 if (currentPage === allSections.length) {
				 currentPanelTitle.innerText = "Summary and Export";
				  panelSummary.innerText = `Please review the settings and export them if you are happy.`;
				for (const section in currentSettings) {
				   const sectionDiv = document.createElement('div');
				   sectionDiv.innerHTML = `<h2>${section}</h2>`;
					 for (const key in currentSettings[section]) {
						  const settingDiv = document.createElement('div');
							settingDiv.classList.add('setting');
							 const label = document.createElement('label');
							  label.textContent = `${key}:`;
						  settingDiv.appendChild(label);
							const valueDisplay = document.createElement('span');
							  valueDisplay.textContent = currentSettings[section][key];
							 settingDiv.appendChild(valueDisplay);
							  sectionDiv.appendChild(settingDiv);
						 }
					   panelContent.appendChild(sectionDiv);
					}
				   return;
				 }


			  const panelSettings = Object.keys(currentSettings)[currentPage];
			 currentPanelTitle.innerText = panelSettings;
				let summaryText = "";
			  switch (panelSettings) {
				   case 'app':
					  summaryText = "The app section includes settings for general app behavior, such as branding and console options.";
					  break;
					case 'files':
						 summaryText = "This section allows you to define how files are handled, such as extensions, keep original settings and nested files.";
						 break;
					 case 'path':
						   summaryText = "The path section sets the output location for the converted files.";
						   break;
					 case 'video':
						   summaryText = "The video section sets the options for video processing like black bar removal and frame rate.";
							break;
					 case 'ffmpeg':
							summaryText = "This configures the FFMPEG options for quality, bitrate, codec and profile.";
							break;
					case 'videos':
							 summaryText = "This controls the transcode settings for audio and video based on a variety of parameters.";
						   break;
				  }
				panelSummary.innerText = summaryText;


				const section = Object.keys(currentSettings)[currentPage];
				for(const key in currentSettings[section]) {
					  const settingDiv = document.createElement('div');
						  settingDiv.classList.add('setting');
						   const label = document.createElement('label');
						   label.textContent = `${key}:`;
						  settingDiv.appendChild(label);
						   let inputElement;
							 if (currentSettings[section][key] === "yes" || currentSettings[section][key] === "no") {
									inputElement = document.createElement('select');
									inputElement.innerHTML = `<option value="yes">Yes</option>
														  <option value="no">No</option>`;
									 inputElement.value = currentSettings[section][key];

							  } else {
									inputElement = document.createElement('input');
									inputElement.type = 'text';
									inputElement.value = currentSettings[section][key];
							  }
						   inputElement.setAttribute('data-section', section);
						  inputElement.setAttribute('data-key', key);
								inputElement.addEventListener('change', (e) => {
								  currentSettings[e.target.dataset.section][e.target.dataset.key] = e.target.value;
							  });
								settingDiv.appendChild(inputElement);

							   const helpButton = document.createElement('button');
							   helpButton.classList.add('help-button');
								helpButton.textContent = '?';
								helpButton.setAttribute('data-help', `${section}.${key}`);
								helpButton.addEventListener('click', (e) => {
									currentHelpSetting = e.target.dataset.help;
									 chatPopup.style.display = 'block';
									  chatHistory = [];
									  chatMessages.innerHTML = "";
									 addAssistantMessage("How can I help with " + currentHelpSetting + "?");
								});
							   settingDiv.appendChild(helpButton);

					   panelContent.appendChild(settingDiv);

				}

			  leftPanelContent.innerHTML = "";
			   for(let i = 0; i < allSections.length; i++){
				   const sectionKey = allSections[i];
					const sectionDiv = document.createElement('div');
					  sectionDiv.textContent = sectionKey;
					  sectionDiv.style.padding = '10px';
					  sectionDiv.style.cursor = 'pointer';
					 sectionDiv.addEventListener('click', ()=>{
						currentPage = i;
						renderSettings();
						if(window.innerWidth < 768){
							  toggleLeftPanel()
						  }
					 });

					   leftPanelContent.appendChild(sectionDiv);
				}
				 const summaryDiv = document.createElement('div');
					summaryDiv.textContent = "Summary";
					summaryDiv.style.padding = '10px';
				   summaryDiv.style.cursor = 'pointer';
			   summaryDiv.addEventListener('click', ()=>{
					currentPage = allSections.length;
					 renderSettings();
					  if(window.innerWidth < 768){
							  toggleLeftPanel()
						 }
				});
				leftPanelContent.appendChild(summaryDiv);
		}
		
        function loadSettings(iniText) {
              if(!iniText && iniFileInput.files.length === 0) return;
              try {
                   if(iniFileInput.files.length > 0){
                         const file = iniFileInput.files[0];
                           const reader = new FileReader();
                           reader.onload = (event) => {
                               const iniText = event.target.result;
                                currentSettings = convertIni(iniText);
                                 renderSettings();
                                 statusMessage.textContent = `Settings Loaded`;
                           }
                         reader.onerror = (error) => {
                                statusMessage.textContent = `Error reading file: ${error}`
                            }
                           reader.readAsText(file)
                      } else if(iniText){
                        currentSettings = convertIni(iniText);
                         renderSettings()
                        statusMessage.textContent = `Settings Loaded`;
                     }

              } catch (error) {
                   statusMessage.textContent = `Error reading settings`
              }
           }
		   
         document.addEventListener('DOMContentLoaded', () => {
            renderSettings();

			chatSendButton.addEventListener('click', async () => {
				const userMessage = chatInputText.value.trim();
				if (!userMessage) return;

				addUserMessage(userMessage);
				chatInputText.value = '';
				fetchAiResponse(userMessage)
			});
			  
			closeChatButton.addEventListener('click', () => {
				chatPopup.style.display = 'none';
			});
			
			prevButton.addEventListener('click', () => {
			   if (currentPage > 0) {
				   currentPage--;
					renderSettings();
			   }
			});

			nextButton.addEventListener('click', () => {
				if (currentPage < Object.keys(currentSettings).length) {
					currentPage++;
					 renderSettings();
				}
			});
			firstButton.addEventListener('click', () => {
			 currentPage = 0;
			  renderSettings();
			});
			lastButton.addEventListener('click', () => {
			 currentPage = Object.keys(currentSettings).length;
			   renderSettings();
			});
			if(window.innerWidth < 768){
				leftPanel.addEventListener('click', toggleLeftPanel);
			} else {
			   leftPanel.removeEventListener('click', toggleLeftPanel)
			}
			
            pasteText.addEventListener('change', (e) => {
                loadSettings(e.target.value)
              });
             iniFileInput.addEventListener('change', () => {
                  loadSettings(null);
              });
			  
             const saveButton = document.getElementById('saveButton');
               saveButton.addEventListener('click', () => {
                if (Object.keys(currentSettings).length === 0) {
                     statusMessage.textContent = 'No settings loaded.';
                     return;
                 }
                const iniText = updateIni(currentSettings);
                const blob = new Blob([iniText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'VideoLogic.ini';
                a.click();
                URL.revokeObjectURL(url);
                statusMessage.textContent = 'INI File Downloaded.';
              })
           });
		   
    </script>
</body>

</html>